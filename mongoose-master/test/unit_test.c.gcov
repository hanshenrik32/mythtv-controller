        -:    0:Source:unit_test.c
        -:    0:Programs:3
        -:    1:/*
        -:    2: * Copyright (c) 2014 Cesanta Software Limited
        -:    3: * All rights reserved
        -:    4: * This software is dual-licensed: you can redistribute it and/or modify
        -:    5: * it under the terms of the GNU General Public License version 2 as
        -:    6: * published by the Free Software Foundation. For the terms of this
        -:    7: * license, see <http://www.gnu.org/licenses/>.
        -:    8: *
        -:    9: * You are free to use this software under the terms of the GNU General
        -:   10: * Public License, but WITHOUT ANY WARRANTY; without even the implied
        -:   11: * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
        -:   12: * See the GNU General Public License for more details.
        -:   13: *
        -:   14: * Alternatively, you can license this software under a commercial
        -:   15: * license, as set out in <https://www.cesanta.com/license>.
        -:   16: */
        -:   17:
        -:   18:#include "unit_test.h"
        -:   19:#include "common/cs_md5.h"
        -:   20:#include "common/test_main.h"
        -:   21:#include "common/test_util.h"
        -:   22:#include "mongoose.h"
        -:   23:#include "src/mg_internal.h"
        -:   24:
        -:   25:#if defined(__STDC_VERSION__) && __STDC_VERSION__ < 199901L && !defined(WIN32)
        -:   26:#define __func__ ""
        -:   27:#endif
        -:   28:
        -:   29:#define FETCH_BUF_SIZE (1024 * 16)
        -:   30:
        -:   31:#define HTTP_PORT "45772"
        -:   32:#define LOOPBACK_IP "127.0.0.1"
        -:   33:#define LISTENING_ADDR LOOPBACK_IP ":" HTTP_PORT
        -:   34:
        -:   35:static struct mg_serve_http_opts s_http_server_opts;
        -:   36:static int s_listening_port = 23456;
        -:   37:
        -:   38:#define TEST_MG_MALLOC malloc
        -:   39:#define TEST_MG_CALLOC calloc
        -:   40:
        -:   41:#ifndef intptr_t
        -:   42:#define intptr_t long
        -:   43:#endif
        -:   44:
        -:   45:void *(*test_malloc)(size_t) = TEST_MG_MALLOC;
        -:   46:void *(*test_calloc)(size_t, size_t) = TEST_MG_CALLOC;
        -:   47:
    #####:   48:void *failing_malloc(size_t size) {
        -:   49:  (void) size;
    #####:   50:  return NULL;
        -:   51:}
        -:   52:
        1:   53:void *failing_calloc(size_t count, size_t size) {
        -:   54:  (void) count;
        -:   55:  (void) size;
        1:   56:  return NULL;
        -:   57:}
        -:   58:
        9:   59:static char *read_file(const char *path, size_t *size) {
        -:   60:  FILE *fp;
        -:   61:  struct stat st;
        9:   62:  char *data = NULL;
        9:   63:  if ((fp = mg_fopen(path, "rb")) != NULL && !fstat(fileno(fp), &st)) {
        9:   64:    *size = st.st_size;
        9:   65:    data = (char *) malloc(*size);
        9:   66:    fread(data, 1, *size, fp);
        9:   67:    fclose(fp);
        -:   68:  }
        9:   69:  return data;
        -:   70:}
        -:   71:
       16:   72:void msleep(int millis) {
        -:   73:#if defined(_WIN32)
        -:   74:  Sleep(millis);
        -:   75:#else
       16:   76:  usleep(millis * 1000);
        -:   77:#endif
       16:   78:}
        -:   79:
        -:   80:static struct mg_iface *test_iface = NULL;
        -:   81:
       22:   82:static void init_test_connection(struct mg_connection *nc) {
       22:   83:  memset(nc, 0, sizeof(*nc));
       22:   84:  nc->iface = test_iface;
       22:   85:}
        -:   86:
       17:   87:static struct mg_connection *create_test_connection() {
       17:   88:  struct mg_connection *nc = (struct mg_connection *) calloc(1, sizeof(*nc));
       17:   89:  init_test_connection(nc);
       17:   90:  return nc;
        -:   91:}
        -:   92:
        -:   93:void mg_destroy_conn(struct mg_connection *conn, int destroy_if);
       16:   94:static void destroy_test_connection(struct mg_connection *nc) {
       16:   95:  mg_destroy_conn(nc, 0 /* destroy_if */);
       16:   96:}
        -:   97:
        1:   98:static const char *test_mbuf(void) {
        -:   99:  struct mbuf io;
        1:  100:  const char *data = "TEST";
        1:  101:  const char *prefix = "MY";
        1:  102:  const char *big_prefix = "Some long prefix: ";
        -:  103:  size_t old_size;
        -:  104:
        1:  105:  mbuf_init(&io, 0);
        1:  106:  ASSERT(io.buf == NULL);
        1:  107:  ASSERT_EQ(io.len, 0);
        1:  108:  ASSERT_EQ(io.size, 0);
        1:  109:  mbuf_free(&io);
        1:  110:  ASSERT(io.buf == NULL);
        1:  111:  ASSERT_EQ(io.len, 0);
        1:  112:  ASSERT_EQ(io.size, 0);
        -:  113:
        1:  114:  mbuf_init(&io, 10);
        1:  115:  ASSERT(io.buf != NULL);
        1:  116:  ASSERT_EQ(io.len, 0);
        1:  117:  ASSERT_EQ(io.size, 10);
        1:  118:  mbuf_free(&io);
        1:  119:  ASSERT(io.buf == NULL);
        1:  120:  ASSERT_EQ(io.len, 0);
        1:  121:  ASSERT_EQ(io.size, 0);
        -:  122:
        1:  123:  mbuf_init(&io, 10);
        1:  124:  ASSERT_EQ(mbuf_append(&io, NULL, 0), 0);
        -:  125:  /* test allocation failure */
        1:  126:  ASSERT_EQ(mbuf_append(&io, NULL, 1125899906842624), 0);
        -:  127:
        1:  128:  ASSERT_EQ(mbuf_append(&io, data, strlen(data)), strlen(data));
        -:  129:
        1:  130:  mbuf_resize(&io, 2);
        1:  131:  ASSERT_EQ(io.size, 10);
        1:  132:  ASSERT_EQ(io.len, strlen(data));
        -:  133:
        1:  134:  ASSERT_EQ(mbuf_insert(&io, 0, prefix, strlen(prefix)), strlen(prefix));
        1:  135:  ASSERT_EQ(io.size, 10);
        1:  136:  ASSERT_EQ(io.len, strlen(data) + strlen(prefix));
        -:  137:
        1:  138:  ASSERT_EQ(mbuf_insert(&io, 0, big_prefix, strlen(big_prefix)),
        -:  139:            strlen(big_prefix));
        1:  140:  ASSERT_EQ(io.size, MBUF_SIZE_MULTIPLIER *
        -:  141:                         (strlen(big_prefix) + strlen(prefix) + strlen(data)));
        1:  142:  ASSERT_STREQ_NZ(io.buf, "Some long prefix: MYTEST");
        -:  143:
        1:  144:  old_size = io.size;
        1:  145:  ASSERT_EQ(mbuf_insert(&io, strlen(big_prefix), data, strlen(data)),
        -:  146:            strlen(data));
        1:  147:  ASSERT_EQ(io.size, old_size);
        1:  148:  ASSERT_STREQ_NZ(io.buf, "Some long prefix: TESTMYTEST");
        -:  149:
        -:  150:  /* test allocation failure */
        1:  151:  ASSERT_EQ(mbuf_insert(&io, 0, NULL, 1125899906842624), 0);
        -:  152:
        -:  153:  /* test overflow */
        1:  154:  ASSERT_EQ(mbuf_insert(&io, 0, NULL, -1), 0);
        1:  155:  mbuf_free(&io);
        1:  156:  return NULL;
        -:  157:}
        -:  158:
      106:  159:static void eh1(struct mg_connection *nc, int ev, void *ev_data) {
      106:  160:  struct mbuf *io = &nc->recv_mbuf;
        -:  161:
      106:  162:  switch (ev) {
        3:  163:    case MG_EV_CONNECT: {
        3:  164:      int res = *((int *) ev_data);
        3:  165:      if (res == 0) {
        3:  166:        mg_printf(nc, "%d %s there", *(int *) ev_data, "hi");
        -:  167:      } else {
    #####:  168:        sprintf((char *) nc->user_data, "connect failed! %d", res);
        -:  169:      }
        3:  170:      break;
        -:  171:    }
        6:  172:    case MG_EV_RECV: {
        6:  173:      if (nc->listener != NULL) {
        3:  174:        mg_printf(nc, "%d", (int) io->len);
        3:  175:        mbuf_remove(io, io->len);
        3:  176:      } else if (io->len > 0) {
        6:  177:        sprintf((char *) nc->user_data, "%sok!",
        6:  178:                (io->len == 2 && memcmp(io->buf, "10", 2) == 0) ? "" : "NOT ");
        3:  179:        DBG(("%s", (const char *) nc->user_data));
        3:  180:        nc->flags |= MG_F_CLOSE_IMMEDIATELY;
        -:  181:      }
        6:  182:      break;
        -:  183:    }
       97:  184:    default:
       97:  185:      break;
        -:  186:  }
      106:  187:}
        -:  188:
        -:  189:#define S_PEM "server.pem"
        -:  190:#define C_PEM "client.pem"
        -:  191:#define CA_PEM "ca.pem"
        -:  192:
        2:  193:static const char *test_mgr_with_ssl(int use_ssl) {
        2:  194:  char addr[100] = "127.0.0.1:0", ip[sizeof(addr)], buf[100] = "",
        -:  195:       short_addr[5];
        -:  196:  struct mg_mgr mgr;
        -:  197:  struct mg_connection *nc;
        -:  198:  struct mg_bind_opts bopts;
        -:  199:  int port, port2;
        -:  200:#if !MG_ENABLE_SSL
        -:  201:  (void) use_ssl;
        -:  202:#endif
        -:  203:
        2:  204:  mg_mgr_init(&mgr, NULL);
        -:  205:  /* mgr.hexdump_file = "-"; */
        -:  206:
        2:  207:  memset(&bopts, 0, sizeof(bopts));
        -:  208:#if MG_ENABLE_SSL
        2:  209:  if (use_ssl) {
        1:  210:    bopts.ssl_cert = S_PEM;
        1:  211:    bopts.ssl_ca_cert = CA_PEM;
        -:  212:  }
        -:  213:#endif
        2:  214:  ASSERT((nc = mg_bind_opt(&mgr, addr, eh1, bopts)) != NULL);
        2:  215:  port2 = htons(nc->sa.sin.sin_port);
        2:  216:  ASSERT(port2 > 0);
        -:  217:
        2:  218:  mg_sock_to_str(nc->sock, addr, sizeof(addr), 3);
        2:  219:  ASSERT_EQ(sscanf(addr, "%[^:]:%d", ip, &port), 2);
        2:  220:  ASSERT_STREQ(ip, "127.0.0.1");
        2:  221:  ASSERT_EQ(port, port2);
        -:  222:
        2:  223:  mg_sock_to_str(nc->sock, short_addr, sizeof(short_addr), 3);
        -:  224:#ifndef _WIN32
        2:  225:  ASSERT_STREQ(short_addr, "");
        -:  226:#else
        -:  227:  /* We use `inet_ntoa` in Windows, so, can get partial result */
        -:  228:  ASSERT_STREQ(short_addr, "127.");
        -:  229:#endif
        -:  230:
        2:  231:  ASSERT((nc = mg_connect(&mgr, addr, eh1)) != NULL);
        -:  232:#if MG_ENABLE_SSL
        2:  233:  if (use_ssl) {
        1:  234:    ASSERT(mg_set_ssl(nc, C_PEM, CA_PEM) == NULL);
        -:  235:  }
        -:  236:#endif
        2:  237:  nc->user_data = buf;
        2:  238:  poll_until(&mgr, 1, c_str_ne, buf, (void *) "");
        2:  239:  ASSERT_STREQ(buf, "ok!");
        2:  240:  buf[0] = '\0';
        -:  241:
        -:  242:#if MG_ENABLE_SSL
        2:  243:  if (use_ssl) {
        -:  244:    struct mg_connect_opts opts;
        1:  245:    memset(&opts, 0, sizeof(opts));
        1:  246:    opts.user_data = buf;
        1:  247:    opts.ssl_cert = C_PEM;
        1:  248:    opts.ssl_ca_cert = CA_PEM;
        1:  249:    opts.ssl_server_name = "*"; /* TODO(rojer): Test this too. */
        1:  250:    ASSERT((nc = mg_connect_opt(&mgr, addr, eh1, opts)) != NULL);
        1:  251:    poll_until(&mgr, 1, c_str_ne, buf, (void *) "");
        1:  252:    ASSERT_STREQ(buf, "ok!");
        1:  253:    buf[0] = '\0';
        -:  254:  }
        -:  255:#endif
        -:  256:
        2:  257:  mg_mgr_free(&mgr);
        2:  258:  return NULL;
        -:  259:}
        -:  260:
        1:  261:static const char *test_mgr(void) {
        1:  262:  return test_mgr_with_ssl(0);
        -:  263:}
        -:  264:
        -:  265:#if MG_ENABLE_SSL
    #####:  266:void *run_manager(void *param) {
    #####:  267:  struct mg_mgr *mgr = (struct mg_mgr *) param;
    #####:  268:  while (((intptr_t) mgr->user_data) == 0) {
    #####:  269:    mg_mgr_poll(mgr, 1000);
        -:  270:  }
    #####:  271:  mg_mgr_free(mgr);
    #####:  272:  free(mgr);
    #####:  273:  return NULL;
        -:  274:}
        -:  275:
        1:  276:static const char *test_ssl(void) {
        1:  277:  return test_mgr_with_ssl(1);
        -:  278:}
        -:  279:
        -:  280:/*
        -:  281: * unfortunately krypton has no BIO so it's hard to test this way
        -:  282: * We still set MG_ENABLE_SSL so that vc6 has a binary to build
        -:  283: */
        -:  284:#ifdef OPENSSL_VERSION_NUMBER
        -:  285:static void eh_hello_server(struct mg_connection *nc, int ev, void *ev_data) {
        -:  286:  (void) ev_data;
        -:  287:  if (ev == MG_EV_ACCEPT) mg_printf(nc, "hello");
        -:  288:}
        -:  289:
        -:  290:static const char *test_modern_crypto(void) {
        -:  291:  char addr[100] = "127.0.0.1:8000";
        -:  292:  struct mg_mgr *mgr = (struct mg_mgr *) malloc(sizeof(*mgr));
        -:  293:  struct mg_connection *nc;
        -:  294:  int port;
        -:  295:
        -:  296:  mg_mgr_init(mgr, NULL);
        -:  297:
        -:  298:  ASSERT((nc = mg_bind(mgr, addr, eh_hello_server)) != NULL);
        -:  299:  port = htons(nc->sa.sin.sin_port);
        -:  300:  ASSERT(port > 0);
        -:  301:  ASSERT(mg_set_ssl(nc, S_PEM, NULL /* no client certs */) == NULL);
        -:  302:  mg_sock_to_str(nc->sock, addr, sizeof(addr),
        -:  303:                 MG_SOCK_STRINGIFY_IP | MG_SOCK_STRINGIFY_PORT);
        -:  304:  mg_start_thread(run_manager, mgr);
        -:  305:
        -:  306:  {
        -:  307:    char buf[100];
        -:  308:/* For older OpenSSL version we have to allow older digests. Then it still tests
        -:  309: * DH. */
        -:  310:#if OPENSSL_VERSION_NUMBER < 0x10000000
        -:  311:    const char *ciphers = "DH:!ADH:AES:MD5:SHA1";
        -:  312:#else
        -:  313:    const char *ciphers = "DH:!ADH:AES:!MD5:!SHA1";
        -:  314:#endif
        -:  315:
        -:  316:    SSL_CTX *ctx = NULL;
        -:  317:    BIO *bio = NULL;
        -:  318:    SSL *ssl = NULL;
        -:  319:
        -:  320:    ctx = SSL_CTX_new(SSLv23_client_method());
        -:  321:    ASSERT(ctx != NULL);
        -:  322:    SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, NULL);
        -:  323:    SSL_CTX_set_verify_depth(ctx, 1);
        -:  324:    /*
        -:  325:     * These are pretty restrictive settings and should satisfy e.g.
        -:  326:     * Chrome's "modern cryptography" requirements.
        -:  327:     */
        -:  328:    ASSERT_EQ(SSL_CTX_set_cipher_list(nc->ssl_ctx, ciphers), 1);
        -:  329:    ASSERT_EQ(SSL_CTX_load_verify_locations(ctx, CA_PEM, NULL), 1);
        -:  330:    bio = BIO_new_ssl_connect(ctx);
        -:  331:    ASSERT(bio != NULL);
        -:  332:    BIO_get_ssl(bio, &ssl);
        -:  333:    ASSERT(ssl != NULL);
        -:  334:    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);
        -:  335:    BIO_set_conn_hostname(bio, addr);
        -:  336:    ASSERT_EQ(BIO_do_connect(bio), 1);
        -:  337:    ASSERT_EQ(BIO_do_handshake(bio), 1);
        -:  338:    ASSERT_EQ(SSL_get_verify_result(ssl), X509_V_OK);
        -:  339:    ASSERT_EQ(BIO_read(bio, buf, 5), 5);
        -:  340:    ASSERT_STREQ_NZ(buf, "hello");
        -:  341:    BIO_free_all(bio);
        -:  342:    SSL_CTX_free(ctx);
        -:  343:  }
        -:  344:
        -:  345:  mgr->user_data = (void *) 1;
        -:  346:  return NULL;
        -:  347:}
        -:  348:#endif /* OPENSSL_VERSION_NUMBER */
        -:  349:#endif /* MG_ENABLE_SSL */
        -:  350:
        1:  351:static const char *test_to64(void) {
        1:  352:  ASSERT_EQ(to64("0"), 0);
        1:  353:  ASSERT_EQ(to64(""), 0);
        1:  354:  ASSERT_EQ(to64("123"), 123);
        1:  355:  ASSERT_EQ(to64("-34"), -34);
        1:  356:  ASSERT_EQ(to64("3566626116"), 3566626116U);
        1:  357:  return NULL;
        -:  358:}
        -:  359:
        1:  360:static const char *test_check_ip_acl(void) {
        1:  361:  uint32_t ip = 0x01020304;
        1:  362:  ASSERT_EQ(mg_check_ip_acl(NULL, ip), 1);
        1:  363:  ASSERT_EQ(mg_check_ip_acl("", ip), 1);
        1:  364:  ASSERT_EQ(mg_check_ip_acl("invalid", ip), -1);
        1:  365:  ASSERT_EQ(mg_check_ip_acl("-0.0.0.0/0", ip), 0);
        1:  366:  ASSERT_EQ(mg_check_ip_acl("-0.0.0.0/0,+1.0.0.0/8", ip), 1);
        1:  367:  ASSERT_EQ(mg_check_ip_acl("-0.0.0.0/0,+1.2.3.4", ip), 1);
        1:  368:  ASSERT_EQ(mg_check_ip_acl("-0.0.0.0/0,+1.0.0.0/16", ip), 0);
        1:  369:  return NULL;
        -:  370:}
        -:  371:
        1:  372:static const char *test_parse_uri(void) {
        -:  373:  struct mg_str uri_out;
        -:  374:  struct mg_str scheme, user_info, host, path, query, fragment;
        -:  375:  unsigned int port;
        -:  376:  {
        1:  377:    struct mg_str uri = MG_MK_STR("foo");
        1:  378:    ASSERT_EQ(mg_parse_uri(uri, NULL, NULL, NULL, NULL, NULL, NULL, NULL), 0);
        -:  379:  }
        -:  380:
        -:  381:  {
        1:  382:    struct mg_str uri = MG_MK_STR("http://user:pw@host:80/foo?bar#baz");
        2:  383:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  384:                           &query, &fragment),
        -:  385:              0);
        -:  386:
        1:  387:    ASSERT_MG_STREQ(scheme, "http");
        1:  388:    ASSERT_MG_STREQ(user_info, "user:pw");
        1:  389:    ASSERT_MG_STREQ(host, "host");
        1:  390:    ASSERT_EQ(port, 80);
        1:  391:    ASSERT_MG_STREQ(path, "/foo");
        1:  392:    ASSERT_MG_STREQ(query, "bar");
        1:  393:    ASSERT_MG_STREQ(fragment, "baz");
        -:  394:
        1:  395:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  396:                              &fragment, 0, &uri_out),
        -:  397:              0);
        1:  398:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  399:    free((void *) uri_out.p);
        -:  400:  }
        -:  401:
        -:  402:  {
        1:  403:    struct mg_str uri = MG_MK_STR("http://host:80/foo?bar");
        2:  404:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  405:                           &query, &fragment),
        -:  406:              0);
        -:  407:
        1:  408:    ASSERT_MG_STREQ(scheme, "http");
        1:  409:    ASSERT_MG_STREQ(user_info, "");
        1:  410:    ASSERT_MG_STREQ(host, "host");
        1:  411:    ASSERT_EQ(port, 80);
        1:  412:    ASSERT_MG_STREQ(path, "/foo");
        1:  413:    ASSERT_MG_STREQ(query, "bar");
        1:  414:    ASSERT_MG_STREQ(fragment, "");
        -:  415:
        1:  416:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  417:                              &fragment, 0, &uri_out),
        -:  418:              0);
        1:  419:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  420:    free((void *) uri_out.p);
        -:  421:  }
        -:  422:
        -:  423:  {
        1:  424:    struct mg_str uri = MG_MK_STR("http://host:80/foo#baz");
        2:  425:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  426:                           &query, &fragment),
        -:  427:              0);
        -:  428:
        1:  429:    ASSERT_MG_STREQ(scheme, "http");
        1:  430:    ASSERT_MG_STREQ(user_info, "");
        1:  431:    ASSERT_MG_STREQ(host, "host");
        1:  432:    ASSERT_EQ(port, 80);
        1:  433:    ASSERT_MG_STREQ(path, "/foo");
        1:  434:    ASSERT_MG_STREQ(query, "");
        1:  435:    ASSERT_MG_STREQ(fragment, "baz");
        -:  436:
        1:  437:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  438:                              &fragment, 0, &uri_out),
        -:  439:              0);
        1:  440:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  441:    free((void *) uri_out.p);
        -:  442:  }
        -:  443:
        -:  444:  {
        1:  445:    struct mg_str uri = MG_MK_STR("http://host:80/foo");
        2:  446:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  447:                           &query, &fragment),
        -:  448:              0);
        -:  449:
        1:  450:    ASSERT_MG_STREQ(scheme, "http");
        1:  451:    ASSERT_MG_STREQ(user_info, "");
        1:  452:    ASSERT_MG_STREQ(host, "host");
        1:  453:    ASSERT_EQ(port, 80);
        1:  454:    ASSERT_MG_STREQ(path, "/foo");
        1:  455:    ASSERT_MG_STREQ(query, "");
        1:  456:    ASSERT_MG_STREQ(fragment, "");
        -:  457:
        1:  458:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  459:                              &fragment, 0, &uri_out),
        -:  460:              0);
        1:  461:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  462:    free((void *) uri_out.p);
        -:  463:  }
        -:  464:
        -:  465:  {
        1:  466:    struct mg_str uri = MG_MK_STR("http://host/foo");
        2:  467:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  468:                           &query, &fragment),
        -:  469:              0);
        -:  470:
        1:  471:    ASSERT_MG_STREQ(scheme, "http");
        1:  472:    ASSERT_MG_STREQ(user_info, "");
        1:  473:    ASSERT_MG_STREQ(host, "host");
        1:  474:    ASSERT_EQ(port, 0);
        1:  475:    ASSERT_MG_STREQ(path, "/foo");
        1:  476:    ASSERT_MG_STREQ(query, "");
        1:  477:    ASSERT_MG_STREQ(fragment, "");
        -:  478:
        1:  479:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  480:                              &fragment, 0, &uri_out),
        -:  481:              0);
        1:  482:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  483:    free((void *) uri_out.p);
        -:  484:  }
        -:  485:
        -:  486:  {
        1:  487:    struct mg_str uri = MG_MK_STR("http://host");
        2:  488:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  489:                           &query, &fragment),
        -:  490:              0);
        1:  491:    ASSERT_MG_STREQ(scheme, "http");
        1:  492:    ASSERT_MG_STREQ(user_info, "");
        1:  493:    ASSERT_MG_STREQ(host, "host");
        1:  494:    ASSERT_EQ(port, 0);
        1:  495:    ASSERT_MG_STREQ(path, "");
        1:  496:    ASSERT_MG_STREQ(query, "");
        1:  497:    ASSERT_MG_STREQ(fragment, "");
        -:  498:
        1:  499:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  500:                              &fragment, 0, &uri_out),
        -:  501:              0);
        1:  502:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  503:    free((void *) uri_out.p);
        -:  504:  }
        -:  505:
        -:  506:  {
        1:  507:    struct mg_str uri = MG_MK_STR("http://host:80");
        2:  508:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  509:                           &query, &fragment),
        -:  510:              0);
        1:  511:    ASSERT_MG_STREQ(scheme, "http");
        1:  512:    ASSERT_MG_STREQ(user_info, "");
        1:  513:    ASSERT_MG_STREQ(host, "host");
        1:  514:    ASSERT_EQ(port, 80);
        1:  515:    ASSERT_MG_STREQ(path, "");
        1:  516:    ASSERT_MG_STREQ(query, "");
        1:  517:    ASSERT_MG_STREQ(fragment, "");
        -:  518:
        1:  519:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  520:                              &fragment, 0, &uri_out),
        -:  521:              0);
        1:  522:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  523:    free((void *) uri_out.p);
        -:  524:  }
        -:  525:
        -:  526:  {
        1:  527:    struct mg_str uri = MG_MK_STR("tcp://1.2.3.4:5678");
        2:  528:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  529:                           &query, &fragment),
        -:  530:              0);
        1:  531:    ASSERT_MG_STREQ(scheme, "tcp");
        1:  532:    ASSERT_MG_STREQ(user_info, "");
        1:  533:    ASSERT_MG_STREQ(host, "1.2.3.4");
        1:  534:    ASSERT_EQ(port, 5678);
        1:  535:    ASSERT_MG_STREQ(path, "");
        1:  536:    ASSERT_MG_STREQ(query, "");
        1:  537:    ASSERT_MG_STREQ(fragment, "");
        -:  538:
        1:  539:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  540:                              &fragment, 0, &uri_out),
        -:  541:              0);
        1:  542:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  543:    free((void *) uri_out.p);
        -:  544:  }
        -:  545:
        -:  546:  {
        -:  547:    const struct mg_str uri = MG_MK_STR("tcp://[::1]:234");
        2:  548:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  549:                           &query, &fragment),
        -:  550:              0);
        1:  551:    ASSERT_MG_STREQ(scheme, "tcp");
        1:  552:    ASSERT_MG_STREQ(user_info, "");
        1:  553:    ASSERT_MG_STREQ(host, "[::1]");
        1:  554:    ASSERT_EQ(port, 234);
        1:  555:    ASSERT_EQ(path.len, 0);
        1:  556:    ASSERT_EQ(query.len, 0);
        1:  557:    ASSERT_EQ(fragment.len, 0);
        1:  558:    ASSERT_MG_STREQ(path, "");
        1:  559:    ASSERT_MG_STREQ(query, "");
        1:  560:    ASSERT_MG_STREQ(fragment, "");
        -:  561:
        1:  562:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  563:                              &fragment, 0, &uri_out),
        -:  564:              0);
        1:  565:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  566:    free((void *) uri_out.p);
        -:  567:  }
        -:  568:
        -:  569:  {
        -:  570:    const struct mg_str uri = MG_MK_STR("tcp://[::1]");
        1:  571:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  572:                           &query, &fragment),
        -:  573:              0);
        1:  574:    ASSERT_MG_STREQ(scheme, "tcp");
        1:  575:    ASSERT_MG_STREQ(user_info, "");
        1:  576:    ASSERT_MG_STREQ(host, "[::1]");
        1:  577:    ASSERT_EQ(port, 0);
        1:  578:    ASSERT_MG_STREQ(path, "");
        1:  579:    ASSERT_MG_STREQ(query, "");
        1:  580:    ASSERT_MG_STREQ(fragment, "");
        -:  581:
        1:  582:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  583:                              &fragment, 0, &uri_out),
        -:  584:              0);
        1:  585:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  586:    free((void *) uri_out.p);
        -:  587:  }
        -:  588:
        -:  589:  {
        -:  590:    const struct mg_str uri = MG_MK_STR("tcp://[::1");
        1:  591:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  592:                           &query, &fragment),
        -:  593:              -1);
        -:  594:  }
        -:  595:
        -:  596:  {
        1:  597:    struct mg_str uri = MG_MK_STR("host:80");
        1:  598:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  599:                           &query, &fragment),
        -:  600:              0);
        1:  601:    ASSERT_MG_STREQ(scheme, "");
        1:  602:    ASSERT_MG_STREQ(user_info, "");
        1:  603:    ASSERT_MG_STREQ(host, "host");
        1:  604:    ASSERT_EQ(port, 80);
        1:  605:    ASSERT_MG_STREQ(path, "");
        1:  606:    ASSERT_MG_STREQ(query, "");
        1:  607:    ASSERT_MG_STREQ(fragment, "");
        -:  608:
        1:  609:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  610:                              &fragment, 0, &uri_out),
        -:  611:              0);
        1:  612:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  613:    free((void *) uri_out.p);
        -:  614:  }
        -:  615:
        -:  616:  {
        -:  617:    const struct mg_str uri = MG_MK_STR("1.2.3.4:56789");
        2:  618:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  619:                           &query, &fragment),
        -:  620:              0);
        1:  621:    ASSERT_MG_STREQ(scheme, "");
        1:  622:    ASSERT_MG_STREQ(user_info, "");
        1:  623:    ASSERT_MG_STREQ(host, "1.2.3.4");
        1:  624:    ASSERT_EQ(port, 56789);
        1:  625:    ASSERT_MG_STREQ(path, "");
        1:  626:    ASSERT_MG_STREQ(query, "");
        1:  627:    ASSERT_MG_STREQ(fragment, "");
        -:  628:
        1:  629:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  630:                              &fragment, 0, &uri_out),
        -:  631:              0);
        1:  632:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  633:    free((void *) uri_out.p);
        -:  634:  }
        -:  635:
        -:  636:  {
        -:  637:    const struct mg_str uri = MG_MK_STR("[::1]:2345");
        1:  638:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  639:                           &query, &fragment),
        -:  640:              0);
        1:  641:    ASSERT_MG_STREQ(scheme, "");
        1:  642:    ASSERT_MG_STREQ(user_info, "");
        1:  643:    ASSERT_MG_STREQ(host, "[::1]");
        1:  644:    ASSERT_EQ(port, 2345);
        1:  645:    ASSERT_MG_STREQ(path, "");
        1:  646:    ASSERT_MG_STREQ(query, "");
        1:  647:    ASSERT_MG_STREQ(fragment, "");
        -:  648:
        1:  649:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  650:                              &fragment, 0, &uri_out),
        -:  651:              0);
        1:  652:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  653:    free((void *) uri_out.p);
        -:  654:  }
        -:  655:
        -:  656:  {
        -:  657:    const struct mg_str uri = MG_MK_STR("[::1]");
        1:  658:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  659:                           &query, &fragment),
        -:  660:              0);
        1:  661:    ASSERT_MG_STREQ(scheme, "");
        1:  662:    ASSERT_MG_STREQ(user_info, "");
        1:  663:    ASSERT_MG_STREQ(host, "[::1]");
        1:  664:    ASSERT_EQ(port, 0);
        1:  665:    ASSERT_MG_STREQ(path, "");
        1:  666:    ASSERT_MG_STREQ(query, "");
        1:  667:    ASSERT_MG_STREQ(fragment, "");
        -:  668:
        1:  669:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  670:                              &fragment, 0, &uri_out),
        -:  671:              0);
        1:  672:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  673:    free((void *) uri_out.p);
        -:  674:  }
        -:  675:
        -:  676:  {
        1:  677:    struct mg_str uri = MG_MK_STR("host/foo");
        1:  678:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  679:                           &query, &fragment),
        -:  680:              0);
        1:  681:    ASSERT_MG_STREQ(scheme, "");
        1:  682:    ASSERT_MG_STREQ(user_info, "");
        1:  683:    ASSERT_MG_STREQ(host, "host");
        1:  684:    ASSERT_EQ(port, 0);
        1:  685:    ASSERT_MG_STREQ(path, "/foo");
        1:  686:    ASSERT_EQ(query.len, 0);
        1:  687:    ASSERT_EQ(fragment.len, 0);
        -:  688:
        1:  689:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  690:                              &fragment, 0, &uri_out),
        -:  691:              0);
        1:  692:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  693:    free((void *) uri_out.p);
        -:  694:  }
        -:  695:
        -:  696:  {
        1:  697:    struct mg_str uri = MG_MK_STR("https://a.com/foo/x@y.z/fw.zip");
        2:  698:    ASSERT_EQ(mg_parse_uri(uri, &scheme, &user_info, &host, &port, &path,
        -:  699:                           &query, &fragment),
        -:  700:              0);
        1:  701:    ASSERT_MG_STREQ(scheme, "https");
        1:  702:    ASSERT_MG_STREQ(user_info, "");
        1:  703:    ASSERT_MG_STREQ(host, "a.com");
        1:  704:    ASSERT_EQ(port, 0);
        1:  705:    ASSERT_MG_STREQ(path, "/foo/x@y.z/fw.zip");
        1:  706:    ASSERT_EQ(query.len, 0);
        1:  707:    ASSERT_EQ(fragment.len, 0);
        -:  708:
        1:  709:    ASSERT_EQ(mg_assemble_uri(&scheme, &user_info, &host, port, &path, &query,
        -:  710:                              &fragment, 0, &uri_out),
        -:  711:              0);
        1:  712:    ASSERT_MG_STREQ(uri_out, uri.p);
        1:  713:    free((void *) uri_out.p);
        -:  714:  }
        -:  715:
        1:  716:  return NULL;
        -:  717:}
        -:  718:
        1:  719:static const char *test_assemble_uri(void) {
        -:  720:  struct mg_str scheme, path, uri;
        -:  721:  {
        1:  722:    ASSERT_EQ(mg_assemble_uri(NULL, NULL, NULL, 0, NULL, NULL, NULL, 0, &uri),
        -:  723:              0);
        1:  724:    ASSERT_MG_STREQ(uri, "");
        -:  725:  }
        -:  726:
        -:  727:  {
        1:  728:    scheme = mg_mk_str("file");
        1:  729:    path = mg_mk_str("/foo/bar");
        1:  730:    ASSERT_EQ(
        -:  731:        mg_assemble_uri(&scheme, NULL, NULL, 0, &path, NULL, NULL, 0, &uri), 0);
        1:  732:    ASSERT_MG_STREQ(uri, "file:///foo/bar");
        1:  733:    free((void *) uri.p);
        -:  734:  }
        -:  735:
        -:  736:  {
        1:  737:    scheme = mg_mk_str("file");
        1:  738:    path = mg_mk_str("/foo/.././bar/baz");
        1:  739:    ASSERT_EQ(
        -:  740:        mg_assemble_uri(&scheme, NULL, NULL, 0, &path, NULL, NULL, 0, &uri), 0);
        1:  741:    ASSERT_MG_STREQ(uri, "file:///foo/.././bar/baz");
        1:  742:    free((void *) uri.p);
        1:  743:    ASSERT_EQ(
        -:  744:        mg_assemble_uri(&scheme, NULL, NULL, 0, &path, NULL, NULL, 1, &uri), 0);
        1:  745:    ASSERT_MG_STREQ(uri, "file:///bar/baz");
        1:  746:    free((void *) uri.p);
        -:  747:  }
        -:  748:
        1:  749:  return NULL;
        -:  750:}
        -:  751:
        -:  752:/* TODO(mkm) port these test cases to the new async parse_address */
        1:  753:static const char *test_parse_address(void) {
        -:  754:  static const char *valid[] = {
        -:  755:    "1",
        -:  756:    "1.2.3.4:1",
        -:  757:    "tcp://123",
        -:  758:    "udp://0.0.0.0:99",
        -:  759:#ifndef _WIN32 /* No /etc/hosts on Windows. */
        -:  760:    "tcp://localhost:99",
        -:  761:#endif
        -:  762:    ":8080",
        -:  763:#if MG_ENABLE_IPV6
        -:  764:    "udp://[::1]:123",
        -:  765:    "[3ffe:2a00:100:7031::1]:900",
        -:  766:#endif
        -:  767:    NULL
        -:  768:  };
        -:  769:  static const int protos[] = {
        -:  770:    SOCK_STREAM,
        -:  771:    SOCK_STREAM,
        -:  772:    SOCK_STREAM,
        -:  773:    SOCK_DGRAM,
        -:  774:    SOCK_STREAM,
        -:  775:    SOCK_STREAM
        -:  776:#if MG_ENABLE_IPV6
        -:  777:    ,
        -:  778:    SOCK_DGRAM,
        -:  779:    SOCK_STREAM
        -:  780:#endif
        -:  781:  };
        -:  782:  static const char *need_lookup[] = {"udp://a.com:53", "locl_host:12", NULL};
        -:  783:  static const char *invalid[] = {
        -:  784:      "99999", "1k", "1.2.3", "1.2.3.4:", "1.2.3.4:2p", "blah://12", ":123x",
        -:  785:      "veeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeery.long:12345",
        -:  786:      "udp://missingport", NULL};
        -:  787:  char host[50];
        -:  788:  union socket_address sa;
        -:  789:  int i, proto;
        -:  790:
        9:  791:  for (i = 0; valid[i] != NULL; i++) {
        8:  792:    ASSERT(mg_parse_address(valid[i], &sa, &proto, host, sizeof(host)) > 0);
        8:  793:    ASSERT_EQ(proto, protos[i]);
        -:  794:  }
        -:  795:
       10:  796:  for (i = 0; invalid[i] != NULL; i++) {
        9:  797:    ASSERT_EQ(mg_parse_address(invalid[i], &sa, &proto, host, sizeof(host)),
        -:  798:              -1);
        -:  799:  }
        -:  800:
        3:  801:  for (i = 0; need_lookup[i] != NULL; i++) {
        2:  802:    ASSERT_EQ(mg_parse_address(need_lookup[i], &sa, &proto, host, sizeof(host)),
        -:  803:              0);
        -:  804:  }
        -:  805:
        1:  806:  return NULL;
        -:  807:}
        -:  808:
        -:  809:#define CHECK_MGNP(in, exp_rv, exp_out)     \
        -:  810:  do {                                      \
        -:  811:    int rv;                                 \
        -:  812:    struct mg_str mgs;                      \
        -:  813:    char *in_copy = strdup(in);             \
        -:  814:    mgs.p = in_copy;                        \
        -:  815:    mgs.len = strlen(in);                   \
        -:  816:    rv = mg_normalize_uri_path(&mgs, &mgs); \
        -:  817:    ASSERT_EQ(rv, exp_rv);                  \
        -:  818:    if (rv > 0) {                           \
        -:  819:      ASSERT_MG_STREQ(mgs, exp_out);        \
        -:  820:    }                                       \
        -:  821:    MG_FREE(in_copy);                       \
        -:  822:  } while (0)
        -:  823:
        1:  824:static const char *test_mg_normalize_uri_path(void) {
        1:  825:  CHECK_MGNP("", 0, "");
        2:  826:  CHECK_MGNP("x", 0, "");
        2:  827:  CHECK_MGNP("/", 1, "/");
        2:  828:  CHECK_MGNP("//", 1, "//");
        2:  829:  CHECK_MGNP("/.", 1, "/");
        2:  830:  CHECK_MGNP("//.", 1, "//");
        2:  831:  CHECK_MGNP("/..", 1, "/");
        2:  832:  CHECK_MGNP("//..", 1, "/");
        2:  833:  CHECK_MGNP("///..", 1, "//");
        2:  834:  CHECK_MGNP("/./", 1, "/");
        2:  835:  CHECK_MGNP("/.//", 1, "//");
        2:  836:  CHECK_MGNP("/./.", 1, "/");
        2:  837:  CHECK_MGNP("/.//.", 1, "//");
        2:  838:  CHECK_MGNP("/foo", 1, "/foo");
        2:  839:  CHECK_MGNP("/foo/", 1, "/foo/");
        2:  840:  CHECK_MGNP("/foo/.", 1, "/foo/");
        2:  841:  CHECK_MGNP("/foo/./", 1, "/foo/");
        2:  842:  CHECK_MGNP("/foo/..", 1, "/");
        2:  843:  CHECK_MGNP("/foo/../", 1, "/");
        2:  844:  CHECK_MGNP("/foo/../bar", 1, "/bar");
        2:  845:  CHECK_MGNP("/foo/../bar/", 1, "/bar/");
        2:  846:  CHECK_MGNP("/foo/../../bar", 1, "/bar");
        2:  847:  CHECK_MGNP("/foo////bar/", 1, "/foo////bar/");
        -:  848:  /* No percent-decoding. */
        2:  849:  CHECK_MGNP("/fo%2fo/%2e%2e/%2e/bar", 1, "/fo%2fo/%2e%2e/%2e/bar");
        1:  850:  return NULL;
        -:  851:}
        -:  852:
        -:  853:#define CHECK_U2LP(u, exp_rv, exp_lp, exp_rem)      \
        -:  854:  do {                                              \
        -:  855:    int rv;                                         \
        -:  856:    char *lp = NULL;                                \
        -:  857:    struct mg_str r;                                \
        -:  858:    hm.uri.p = u;                                   \
        -:  859:    hm.uri.len = strlen(u);                         \
        -:  860:    rv = mg_uri_to_local_path(&hm, &opts, &lp, &r); \
        -:  861:    ASSERT_EQ(rv, exp_rv);                          \
        -:  862:    if (rv == 1) {                                  \
        -:  863:      ASSERT_STREQ(lp, exp_lp);                     \
        -:  864:      ASSERT_MG_STREQ(r, exp_rem);                  \
        -:  865:      MG_FREE(lp);                                  \
        -:  866:    }                                               \
        -:  867:  } while (0)
        -:  868:
        -:  869:#ifdef _WIN32
        -:  870:#define DS "\\"
        -:  871:#else
        -:  872:#define DS "/"
        -:  873:#endif
        -:  874:
        1:  875:static const char *test_mg_uri_to_local_path(void) {
        -:  876:  struct http_message hm;
        -:  877:  struct mg_serve_http_opts opts;
        1:  878:  memset(&hm, 0, sizeof(hm));
        1:  879:  memset(&opts, 0, sizeof(opts));
        1:  880:  opts.document_root = ".";
        1:  881:  CHECK_U2LP("/", 1, ".", "");
        2:  882:  CHECK_U2LP("//", 1, ".", "");
        2:  883:  CHECK_U2LP("/.", 1, ".", "");
        2:  884:  CHECK_U2LP("/%2e", 1, ".", "");
        2:  885:  CHECK_U2LP("//.", 1, ".", "");
        2:  886:  CHECK_U2LP("/..", 1, ".", "");
        2:  887:  CHECK_U2LP("//..", 1, ".", "");
        2:  888:  CHECK_U2LP("/./", 1, ".", "");
        2:  889:  CHECK_U2LP("/%2E/", 1, ".", "");
        2:  890:  CHECK_U2LP("/.//", 1, ".", "");
        2:  891:  CHECK_U2LP("/./.", 1, ".", "");
        2:  892:  CHECK_U2LP("/.//.", 1, ".", "");
        2:  893:  CHECK_U2LP("/data", 1, "." DS "data", "");
        2:  894:  CHECK_U2LP("/data/", 1, "." DS "data", "");
        2:  895:  CHECK_U2LP("/data/.", 1, "." DS "data", "");
        2:  896:  CHECK_U2LP("/data/./", 1, "." DS "data", "");
        2:  897:  CHECK_U2LP("/data/..", 1, ".", "");
        2:  898:  CHECK_U2LP("/data/../", 1, ".", "");
        2:  899:  CHECK_U2LP("/data/../data", 1, "." DS "data", "");
        2:  900:  CHECK_U2LP("/data/../../data", 1, "." DS "data", "");
        2:  901:  CHECK_U2LP("/no/such/file", 1, "." DS "no" DS "such" DS "file", "");
        2:  902:  CHECK_U2LP("/data/no/such/file", 1, "." DS "data" DS "no" DS "such" DS "file",
        -:  903:             "");
        2:  904:  CHECK_U2LP("/data/dummy.xml/", 1, "." DS "data" DS "dummy.xml", "/");
        2:  905:  CHECK_U2LP("/./data/./%2E/dummy.xml", 1, "." DS "data" DS "dummy.xml", "");
        -:  906:  /* No DIRSEPs in path. */
        2:  907:  CHECK_U2LP("/data%2Fdummy%2Exml/in%2Ffo/", 0, "", "");
        -:  908:  /* Ok in PATH_INFO. */
        2:  909:  CHECK_U2LP("/data/dummy%2Exml/in%2Ffo/", 1, "." DS "data" DS "dummy.xml",
        -:  910:             "/in%2Ffo/");
        -:  911:  /* Test rewrites */
        1:  912:  opts.url_rewrites = "/foo=/bar,/=/xxx";
        2:  913:  CHECK_U2LP("/", 1, "/xxx", "");
        2:  914:  CHECK_U2LP("/yyy", 1, "/xxx" DS "yyy", "");
        2:  915:  CHECK_U2LP("/foo/baz", 1, "/bar" DS "baz", "");
        -:  916:  /* /foo does not match - must fall on the boundary, / matches. */
        2:  917:  CHECK_U2LP("/foobario/baz", 1, "/xxx" DS "foobario" DS "baz", "");
        1:  918:  opts.url_rewrites = "**=/xxx";
        2:  919:  CHECK_U2LP("/", 1, "/xxx", "");
        2:  920:  CHECK_U2LP("/yyy", 1, "/xxx", "");
        1:  921:  hm.header_names[0] = mg_mk_str("Host");
        1:  922:  hm.header_values[0] = mg_mk_str("example.org");
        1:  923:  opts.url_rewrites = "@EXAMPLE.org=/test";
        2:  924:  CHECK_U2LP("/hello", 1, "/test" DS "hello", "");
        1:  925:  return NULL;
        -:  926:}
        -:  927:
        1:  928:static const char *test_mg_url_encode(void) {
        -:  929:  const struct mg_str encode_me =
        -:  930:      MG_MK_STR("I'm a.little_tea-pot,here's$my;spout~oink(oink)oink/!");
        -:  931:  {
        1:  932:    struct mg_str encoded = mg_url_encode(encode_me);
        1:  933:    ASSERT_MG_STREQ(
        -:  934:        encoded,
        -:  935:        "I%27m%20a.little_tea-pot,here%27s$my;spout~oink(oink)oink/%21");
        1:  936:    free((void *) encoded.p);
        -:  937:  }
        -:  938:  {
        1:  939:    struct mg_str encoded = mg_url_encode_opt(encode_me, mg_mk_str(NULL), 0);
        1:  940:    ASSERT_MG_STREQ(encoded,
        -:  941:                    "I%27m%20a%2elittle%5ftea%2dpot%2chere%27s%24my%3bspout%"
        -:  942:                    "7eoink%28oink%29oink%2f%21");
        1:  943:    free((void *) encoded.p);
        -:  944:  }
        -:  945:  {
        1:  946:    struct mg_str encoded = mg_url_encode_opt(encode_me, mg_mk_str(" /!"),
        -:  947:                                              MG_URL_ENCODE_F_UPPERCASE_HEX);
        1:  948:    ASSERT_MG_STREQ(encoded,
        -:  949:                    "I%27m "
        -:  950:                    "a%2Elittle%5Ftea%2Dpot%2Chere%27s%24my%3Bspout%7Eoink%"
        -:  951:                    "28oink%29oink/!");
        1:  952:    free((void *) encoded.p);
        -:  953:  }
        -:  954:  {
        1:  955:    struct mg_str encoded = mg_url_encode_opt(
        -:  956:        encode_me, mg_mk_str("/!"),
        -:  957:        MG_URL_ENCODE_F_SPACE_AS_PLUS | MG_URL_ENCODE_F_UPPERCASE_HEX);
        1:  958:    ASSERT_MG_STREQ(encoded,
        -:  959:                    "I%27m+a%2Elittle%5Ftea%2Dpot%2Chere%27s%24my%3Bspout%"
        -:  960:                    "7Eoink%28oink%29oink/!");
        1:  961:    free((void *) encoded.p);
        -:  962:  }
        1:  963:  return NULL;
        -:  964:}
        -:  965:
        2:  966:static void connect_fail_cb(struct mg_connection *nc, int ev, void *p) {
        2:  967:  switch (ev) {
        1:  968:    case MG_EV_CONNECT:
        -:  969:      /* On connection success, set flag 1, else set 4 */
        1:  970:      *(int *) nc->user_data |= *(int *) p == 0 ? 1 : 4;
        1:  971:      break;
        1:  972:    case MG_EV_CLOSE:
        1:  973:      *(int *) nc->user_data |= 2;
        1:  974:      break;
        -:  975:  }
        2:  976:}
        -:  977:
    #####:  978:static void ev_handler_empty(struct mg_connection *nc, int ev, void *p) {
        -:  979:  (void) nc;
        -:  980:  (void) ev;
        -:  981:  (void) p;
    #####:  982:}
        -:  983:
        1:  984:static const char *test_connection_errors(void) {
        -:  985:  struct mg_mgr mgr;
        -:  986:  struct mg_bind_opts bopts;
        -:  987:  struct mg_connect_opts copts;
        -:  988:  struct mg_connection *nc;
        -:  989:  const char *error_string;
        1:  990:  int data = 0;
        -:  991:
        1:  992:  mg_mgr_init(&mgr, NULL);
        -:  993:
        1:  994:  memset(&bopts, 0, sizeof(bopts));
        1:  995:  bopts.error_string = &error_string;
        -:  996:
        1:  997:  ASSERT(mg_bind_opt(&mgr, "blah://12", NULL, bopts) == NULL);
        1:  998:  ASSERT_STREQ(error_string, "handler is required");
        -:  999:
        1: 1000:  ASSERT(mg_bind_opt(&mgr, "blah://12", ev_handler_empty, bopts) == NULL);
        1: 1001:  ASSERT_STREQ(error_string, "cannot parse address");
        -: 1002:
        1: 1003:  ASSERT(mg_bind_opt(&mgr, "tcp://8.8.8.8:88", ev_handler_empty, bopts) ==
        -: 1004:         NULL);
        1: 1005:  ASSERT_STREQ(error_string, "failed to open listener");
        -: 1006:
        -: 1007:#if MG_ENABLE_SSL
        1: 1008:  bopts.ssl_cert = S_PEM;
        1: 1009:  ASSERT(mg_bind_opt(&mgr, "udp://:0", ev_handler_empty, bopts) == NULL);
        1: 1010:  ASSERT_STREQ(error_string, "SSL for UDP is not supported");
        1: 1011:  bopts.ssl_cert = "no_such_file";
        1: 1012:  ASSERT(mg_bind_opt(&mgr, "tcp://:0", ev_handler_empty, bopts) == NULL);
        1: 1013:  ASSERT_STREQ(error_string, "Invalid SSL cert");
        1: 1014:  bopts.ssl_cert = NULL;
        1: 1015:  bopts.ssl_ca_cert = "no_such_file";
        1: 1016:  ASSERT(mg_bind_opt(&mgr, "tcp://:0", ev_handler_empty, bopts) == NULL);
        1: 1017:  ASSERT_STREQ(error_string, "Invalid SSL CA cert");
        -: 1018:#endif
        -: 1019:
        1: 1020:  memset(&copts, 0, sizeof(copts));
        1: 1021:  copts.error_string = &error_string;
        -: 1022:
        -: 1023:#if 0
        -: 1024:  copts.error_string = &error_string;
        -: 1025:  ASSERT(mg_connect_opt(&mgr, "tcp://255.255.255.255:0", NULL, copts) == NULL);
        -: 1026:  ASSERT_STREQ(error_string, "cannot connect to socket");
        -: 1027:
        -: 1028:  copts.user_data = &data;
        -: 1029:  ASSERT(mg_connect_opt(&mgr, "tcp://255.255.255.255:0", connect_fail_cb,
        -: 1030:                        copts) == NULL);
        -: 1031:  ASSERT_STREQ(error_string, "cannot connect to socket");
        -: 1032:  /* handler isn't invoked when it fails synchronously */
        -: 1033:  ASSERT_EQ(data, 0);
        -: 1034:#endif
        -: 1035:
        1: 1036:  data = 0;
        1: 1037:  copts.user_data = &data;
        1: 1038:  ASSERT((nc = mg_connect_opt(&mgr, "tcp://does.not.exist:8080",
        -: 1039:                              connect_fail_cb, copts)) != NULL);
        -: 1040:
        -: 1041:  /* handler is invoked when it fails asynchronously */
        1: 1042:  poll_until(&mgr, 5, c_int_eq, &data, (void *) 6);
        1: 1043:  ASSERT_EQ(data, 6);
        -: 1044:
        -: 1045:  /* mg_bind() does not use MG_CALLOC, but async resolver does */
        1: 1046:  test_calloc = failing_calloc;
        -: 1047:#ifndef _WIN32
        1: 1048:  ASSERT(mg_connect(&mgr, "some.domain.needs.async.resolv:777", NULL) == NULL);
        1: 1049:  ASSERT(mg_bind(&mgr, ":4321", NULL) == NULL);
        -: 1050:#endif
        1: 1051:  test_calloc = TEST_MG_CALLOC;
        -: 1052:
        -: 1053:#if MG_ENABLE_SSL
        1: 1054:  copts.ssl_cert = "no_such_file";
        1: 1055:  ASSERT((nc = mg_connect_opt(&mgr, "tcp://google.com:80", connect_fail_cb,
        -: 1056:                              copts)) == NULL);
        1: 1057:  ASSERT_STREQ(error_string, "Invalid SSL cert");
        1: 1058:  copts.ssl_cert = NULL;
        1: 1059:  copts.ssl_ca_cert = "no_such_file";
        1: 1060:  ASSERT((nc = mg_connect_opt(&mgr, "tcp://google.com:80", connect_fail_cb,
        -: 1061:                              copts)) == NULL);
        1: 1062:  ASSERT_STREQ(error_string, "Invalid SSL CA cert");
        -: 1063:#endif
        -: 1064:
        1: 1065:  mg_mgr_free(&mgr);
        1: 1066:  return NULL;
        -: 1067:}
        -: 1068:
        2: 1069:static int avt(char **buf, size_t buf_size, const char *fmt, ...) {
        -: 1070:  int result;
        -: 1071:  va_list ap;
        2: 1072:  va_start(ap, fmt);
        2: 1073:  result = mg_avprintf(buf, buf_size, fmt, ap);
        2: 1074:  va_end(ap);
        2: 1075:  return result;
        -: 1076:}
        -: 1077:
        1: 1078:static const char *test_alloc_vprintf(void) {
        1: 1079:  char buf[5], *p = buf;
        -: 1080:
        1: 1081:  ASSERT_EQ(avt(&p, sizeof(buf), "%d", 123), 3);
        1: 1082:  ASSERT(p == buf);
        1: 1083:  ASSERT_STREQ(p, "123");
        -: 1084:
        1: 1085:  ASSERT_EQ(avt(&p, sizeof(buf), "%d", 123456789), 9);
        1: 1086:  ASSERT(p != buf);
        1: 1087:  ASSERT_STREQ(p, "123456789");
        1: 1088:  free(p);
        -: 1089:
        1: 1090:  return NULL;
        -: 1091:}
        -: 1092:
        1: 1093:static const char *test_socketpair(void) {
        -: 1094:  sock_t sp[2];
        -: 1095:  static const char foo[] = "hi there";
        -: 1096:  char buf[20];
        -: 1097:
        1: 1098:  ASSERT_EQ(mg_socketpair(sp, SOCK_DGRAM), 1);
        1: 1099:  ASSERT(sizeof(foo) < sizeof(buf));
        -: 1100:
        -: 1101:  /* Send string in one direction */
        1: 1102:  ASSERT_EQ(send(sp[0], foo, sizeof(foo), 0), sizeof(foo));
        1: 1103:  ASSERT_EQ(recv(sp[1], buf, sizeof(buf), 0), sizeof(foo));
        1: 1104:  ASSERT_STREQ(buf, "hi there");
        -: 1105:
        -: 1106:  /* Now in opposite direction */
        1: 1107:  ASSERT_EQ(send(sp[1], foo, sizeof(foo), 0), sizeof(foo));
        1: 1108:  ASSERT_EQ(recv(sp[0], buf, sizeof(buf), 0), sizeof(foo));
        1: 1109:  ASSERT_STREQ(buf, "hi there");
        -: 1110:
        1: 1111:  closesocket(sp[0]);
        1: 1112:  closesocket(sp[1]);
        -: 1113:
        1: 1114:  return NULL;
        -: 1115:}
        -: 1116:
        8: 1117:static void ev_timer_handler(struct mg_connection *c, int ev, void *ev_data) {
        -: 1118:  (void) ev_data;
        8: 1119:  switch (ev) {
        2: 1120:    case MG_EV_TIMER:
        2: 1121:      (*(int *) c->user_data)++;
        2: 1122:      break;
        2: 1123:    case MG_EV_CLOSE:
        -: 1124:      /* Make sure we're alive. Make the ASSERTs fail if we're here. */
        2: 1125:      (*(int *) c->user_data) += 100;
        2: 1126:      break;
        -: 1127:  }
        8: 1128:}
        -: 1129:
        1: 1130:static const char *test_timer(void) {
        -: 1131:  struct mg_mgr m;
        -: 1132:  struct mg_connection *c;
        -: 1133:  double begin, end;
        1: 1134:  int n = 0, i;
        -: 1135:
        1: 1136:  mg_mgr_init(&m, NULL);
        1: 1137:  ASSERT((c = mg_add_sock(&m, INVALID_SOCKET, ev_timer_handler)) != NULL);
        1: 1138:  c->user_data = &n;
        -: 1139:
        -: 1140:  /* MG_EV_TIMER should not fire - we did not set it up */
        1: 1141:  mg_mgr_poll(&m, 1);
        1: 1142:  ASSERT_EQ(n, 0);
        -: 1143:
        -: 1144:  /*
        -: 1145:   * Now, set it up. Make sure MG_EV_TIMER event fires.
        -: 1146:   * Also, it brings forward the poll timeout.
        -: 1147:   */
        1: 1148:  ASSERT_EQ(mg_set_timer(c, mg_time() + 0.1), 0.0);
        1: 1149:  begin = mg_time();
        -: 1150:  /*
        -: 1151:   * Windows is a bit sloppy about select() timeouts, so it may take
        -: 1152:   * a couple iterations for the timer to actually fire.
        -: 1153:   */
        2: 1154:  for (i = 0; n != 1 && i < 5; i++) {
        1: 1155:    mg_mgr_poll(&m, 1000);
        -: 1156:  }
        1: 1157:  end = mg_time();
        1: 1158:  ASSERT_EQ(n, 1);
        1: 1159:  ASSERT_LT(end - begin, 0.9);
        1: 1160:  ASSERT_GT(end - begin, 0.09);
        -: 1161:
        -: 1162:  /* Make sure that timer is reset - second time it does not fire */
        1: 1163:  ASSERT_EQ(c->ev_timer_time, 0.0);
        1: 1164:  mg_mgr_poll(&m, 1);
        1: 1165:  ASSERT_EQ(n, 1);
        -: 1166:
        1: 1167:  c->flags |= MG_F_CLOSE_IMMEDIATELY;
        1: 1168:  mg_mgr_poll(&m, 1);
        1: 1169:  ASSERT_EQ(n, 101);
        -: 1170:
        -: 1171:  /* Async resolver codepath */
        1: 1172:  n = 0;
        1: 1173:  ASSERT((c = mg_connect(&m, "awful.sad:1234", ev_timer_handler)) != NULL);
        1: 1174:  c->user_data = &n;
        1: 1175:  mg_set_timer(c, 1);
        1: 1176:  poll_until(&m, 1, c_int_eq, &n, (void *) 101);
        1: 1177:  ASSERT_EQ(n, 101);
        -: 1178:
        1: 1179:  mg_mgr_free(&m);
        -: 1180:
        1: 1181:  return NULL;
        -: 1182:}
        -: 1183:
        -: 1184:struct simple_data {
        -: 1185:  int num_accept;
        -: 1186:  int num_connect;
        -: 1187:  int num_recv;
        -: 1188:  int num_send;
        -: 1189:  int num_close;
        -: 1190:  int num_timer;
        -: 1191:  char to_send[100];
        -: 1192:  char data_rcvd[100];
        -: 1193:  char fail[200];
        -: 1194:  struct simple_data *sclient_data;
        -: 1195:  struct mg_connection *sclient_nc;
        -: 1196:};
        -: 1197:
        -: 1198:#ifndef __APPLE__
       21: 1199:static void count_events(struct simple_data *d, int ev) {
       21: 1200:  switch (ev) {
       12: 1201:    case MG_EV_POLL:
       12: 1202:      break;
        1: 1203:    case MG_EV_ACCEPT:
        1: 1204:      d->num_accept++;
        1: 1205:      break;
        1: 1206:    case MG_EV_CONNECT:
        1: 1207:      d->num_connect++;
        1: 1208:      break;
        2: 1209:    case MG_EV_RECV:
        2: 1210:      d->num_recv++;
        2: 1211:      break;
        2: 1212:    case MG_EV_SEND:
        2: 1213:      d->num_send++;
        2: 1214:      break;
        3: 1215:    case MG_EV_CLOSE:
        3: 1216:      d->num_close++;
        3: 1217:      break;
    #####: 1218:    case MG_EV_TIMER:
    #####: 1219:      d->num_timer++;
    #####: 1220:      break;
    #####: 1221:    default: {
        -: 1222:      char msg[100];
    #####: 1223:      sprintf(msg, "(unexpected event: %d)", ev);
    #####: 1224:      strcat(d->fail, msg);
        -: 1225:    }
        -: 1226:  }
       21: 1227:}
        -: 1228:
        2: 1229:static void do_send(struct simple_data *d, struct mg_connection *nc) {
        2: 1230:  if (d->to_send[0] != '\0') {
        2: 1231:    mg_printf(nc, "%s", d->to_send);
        -: 1232:  }
        2: 1233:}
        -: 1234:
        2: 1235:static void do_recv(struct simple_data *d, struct mg_connection *nc,
        -: 1236:                    void *ev_data) {
        2: 1237:  if (*((int *) ev_data) != (int) nc->recv_mbuf.len) {
        -: 1238:    char msg[100];
    #####: 1239:    sprintf(msg, "(num recv wrong: %d vs %d)", *((int *) ev_data),
    #####: 1240:            (int) strlen(d->to_send));
    #####: 1241:    strcat(d->fail, msg);
    #####: 1242:    return;
        -: 1243:  }
        2: 1244:  strncat(d->data_rcvd, nc->recv_mbuf.buf, nc->recv_mbuf.len);
        2: 1245:  mbuf_remove(&nc->recv_mbuf, nc->recv_mbuf.len);
        -: 1246:}
        -: 1247:
        2: 1248:static void check_sent(struct simple_data *d, struct mg_connection *nc,
        -: 1249:                       void *ev_data) {
        2: 1250:  if (*((int *) ev_data) != (int) strlen(d->to_send)) {
        -: 1251:    char msg[100];
    #####: 1252:    sprintf(msg, "(num sent wrong: %d vs %d)", *((int *) ev_data),
    #####: 1253:            (int) strlen(d->to_send));
    #####: 1254:    strcat(d->fail, msg);
        -: 1255:  } else {
        2: 1256:    d->to_send[0] = '\0';
        -: 1257:  }
        2: 1258:  if (nc->send_mbuf.len != 0) strcat(d->fail, "(send buf not empty)");
        2: 1259:}
        -: 1260:
        8: 1261:static void cb_client(struct mg_connection *nc, int ev, void *ev_data) {
        8: 1262:  struct simple_data *d = (struct simple_data *) nc->user_data;
        8: 1263:  count_events(d, ev);
        8: 1264:  switch (ev) {
        1: 1265:    case MG_EV_CONNECT:
        1: 1266:      do_send(d, nc);
        1: 1267:      break;
        1: 1268:    case MG_EV_SEND:
        1: 1269:      check_sent(d, nc, ev_data);
        1: 1270:      break;
        1: 1271:    case MG_EV_RECV:
        1: 1272:      do_recv(d, nc, ev_data);
        1: 1273:      break;
        -: 1274:  }
        8: 1275:}
        -: 1276:
        5: 1277:static void cb_sclient(struct mg_connection *nc, int ev, void *ev_data) {
        5: 1278:  struct simple_data *d = (struct simple_data *) nc->user_data;
        5: 1279:  count_events(d, ev);
        5: 1280:  switch (ev) {
        1: 1281:    case MG_EV_RECV: {
        1: 1282:      do_recv(d, nc, ev_data);
        1: 1283:      do_send(d, nc);
        1: 1284:      nc->flags |= MG_F_SEND_AND_CLOSE;
        1: 1285:      break;
        -: 1286:    }
        1: 1287:    case MG_EV_SEND: {
        1: 1288:      check_sent(d, nc, ev_data);
        1: 1289:      break;
        -: 1290:    }
        -: 1291:  }
        5: 1292:}
        -: 1293:
        8: 1294:static void cb_server(struct mg_connection *nc, int ev, void *ev_data) {
        8: 1295:  struct simple_data *d = (struct simple_data *) nc->user_data;
        -: 1296:  (void) ev_data;
        8: 1297:  if (ev == MG_EV_ACCEPT) {
        1: 1298:    d->sclient_nc = nc;
        1: 1299:    nc->user_data = d = d->sclient_data;
        1: 1300:    nc->handler = cb_sclient;
        -: 1301:  }
        8: 1302:  count_events(d, ev);
        8: 1303:}
        -: 1304:#endif
        -: 1305:
        -: 1306:/* The following test is only reliable on Linux. */
        -: 1307:#ifdef __linux__
        1: 1308:static const char *test_simple(void) {
        -: 1309:  struct mg_mgr mgr;
        -: 1310:  struct mg_connection *nc_server, *nc_client, *nc_sclient;
        1: 1311:  const char *address = "tcp://127.0.0.1:8910";
        -: 1312:  struct simple_data client_data, server_data, sclient_data;
        -: 1313:
        -: 1314:  (void) nc_sclient;
        1: 1315:  mg_mgr_init(&mgr, NULL);
        -: 1316:
        1: 1317:  ASSERT((nc_server = mg_bind(&mgr, address, cb_server)) != NULL);
        1: 1318:  nc_server->user_data = &server_data;
        1: 1319:  memset(&server_data, 0, sizeof(server_data));
        1: 1320:  server_data.sclient_data = &sclient_data;
        1: 1321:  memset(&sclient_data, 0, sizeof(sclient_data));
        -: 1322:
        1: 1323:  mg_mgr_poll(&mgr, 1); /* 1 - nothing */
        -: 1324:
        1: 1325:  ASSERT((nc_client = mg_connect(&mgr, address, cb_client)) != NULL);
        1: 1326:  nc_client->user_data = &client_data;
        1: 1327:  memset(&client_data, 0, sizeof(client_data));
        1: 1328:  strcpy(client_data.to_send, "hi");
        -: 1329:
        1: 1330:  mg_mgr_poll(&mgr, 1); /* 2 - client connects and sends, server accepts */
        1: 1331:  ASSERT_EQ(server_data.num_accept, 0);
        1: 1332:  ASSERT_EQ(sclient_data.num_accept, 1);
        1: 1333:  ASSERT_EQ(client_data.num_connect, 1);
        1: 1334:  ASSERT_EQ(client_data.num_send, 1);
        1: 1335:  ASSERT_STREQ(client_data.fail, "");
        1: 1336:  ASSERT_STREQ(server_data.fail, "");
        -: 1337:
        1: 1338:  ASSERT(server_data.sclient_nc != NULL);
        1: 1339:  nc_sclient = server_data.sclient_nc;
        1: 1340:  ASSERT_EQ(sclient_data.num_send, 0);
        1: 1341:  ASSERT_EQ(sclient_data.num_recv, 0);
        -: 1342:
        1: 1343:  strcpy(sclient_data.to_send, "hello");
        1: 1344:  mg_mgr_poll(&mgr, 1); /* 3 - server receives, buffers response, closes */
        1: 1345:  ASSERT_STREQ(sclient_data.fail, "");
        1: 1346:  ASSERT_EQ(sclient_data.num_recv, 1);
        1: 1347:  ASSERT_EQ(sclient_data.num_send, 0);
        1: 1348:  ASSERT_EQ(client_data.num_recv, 0);
        1: 1349:  ASSERT_STREQ(sclient_data.data_rcvd, "hi");
        -: 1350:
        1: 1351:  mg_mgr_poll(&mgr, 1); /* 4 - server sends */
        1: 1352:  ASSERT_STREQ(sclient_data.fail, "");
        1: 1353:  ASSERT_EQ(sclient_data.num_send, 1);
        -: 1354:
        1: 1355:  mg_mgr_poll(&mgr, 1); /* 5 - client receives */
        1: 1356:  ASSERT_STREQ(client_data.fail, "");
        1: 1357:  ASSERT_EQ(client_data.num_recv, 1);
        1: 1358:  ASSERT_STREQ(client_data.data_rcvd, "hello");
        -: 1359:
        1: 1360:  mg_mgr_free(&mgr);
        -: 1361:
        1: 1362:  ASSERT_STREQ(client_data.fail, "");
        1: 1363:  ASSERT_STREQ(server_data.fail, "");
        1: 1364:  ASSERT_STREQ(sclient_data.fail, "");
        -: 1365:
        1: 1366:  ASSERT_EQ(server_data.num_accept, 0);
        1: 1367:  ASSERT_EQ(server_data.num_connect, 0);
        1: 1368:  ASSERT_EQ(server_data.num_recv, 0);
        1: 1369:  ASSERT_EQ(server_data.num_send, 0);
        1: 1370:  ASSERT_EQ(server_data.num_close, 1);
        -: 1371:
        1: 1372:  ASSERT_EQ(client_data.num_accept, 0);
        1: 1373:  ASSERT_EQ(client_data.num_connect, 1);
        1: 1374:  ASSERT_EQ(client_data.num_recv, 1);
        1: 1375:  ASSERT_EQ(client_data.num_send, 1);
        1: 1376:  ASSERT_EQ(client_data.num_close, 1);
        -: 1377:
        1: 1378:  ASSERT_EQ(sclient_data.num_accept, 1);
        1: 1379:  ASSERT_EQ(sclient_data.num_connect, 0);
        1: 1380:  ASSERT_EQ(sclient_data.num_recv, 1);
        1: 1381:  ASSERT_EQ(sclient_data.num_send, 1);
        1: 1382:  ASSERT_EQ(sclient_data.num_close, 1);
        -: 1383:
        1: 1384:  return NULL;
        -: 1385:}
        -: 1386:#endif
        -: 1387:
        -: 1388:#if MG_ENABLE_THREADS
        9: 1389:static void eh2(struct mg_connection *nc, int ev, void *p) {
        -: 1390:  (void) p;
        9: 1391:  switch (ev) {
        1: 1392:    case MG_EV_RECV:
        1: 1393:      strcpy((char *) nc->user_data, nc->recv_mbuf.buf);
        1: 1394:      break;
        8: 1395:    default:
        8: 1396:      break;
        -: 1397:  }
        9: 1398:}
        -: 1399:
        1: 1400:static void *thread_func(void *param) {
        1: 1401:  sock_t sock = *(sock_t *) param;
        1: 1402:  send(sock, ":-)", 4, 0);
        1: 1403:  return NULL;
        -: 1404:}
        -: 1405:
        1: 1406:static const char *test_thread(void) {
        -: 1407:  struct mg_mgr mgr;
        -: 1408:  struct mg_connection *nc;
        -: 1409:  sock_t sp[2];
        1: 1410:  char buf[20] = "";
        -: 1411:
        1: 1412:  ASSERT_EQ(mg_socketpair(sp, SOCK_STREAM), 1);
        1: 1413:  mg_start_thread(thread_func, &sp[1]);
        -: 1414:
        1: 1415:  mg_mgr_init(&mgr, NULL);
        1: 1416:  ASSERT((nc = mg_add_sock(&mgr, sp[0], eh2)) != NULL);
        1: 1417:  nc->user_data = buf;
        1: 1418:  poll_until(&mgr, 1, c_str_ne, buf, (void *) "");
        1: 1419:  ASSERT_STREQ(buf, ":-)");
        1: 1420:  mg_mgr_free(&mgr);
        1: 1421:  closesocket(sp[1]);
        -: 1422:
        1: 1423:  return NULL;
        -: 1424:}
        -: 1425:#endif /* MG_ENABLE_THREADS */
        -: 1426:
        -: 1427:struct udp_res {
        -: 1428:  struct mbuf buf_srv;
        -: 1429:  struct mg_connection *srv_recv_conn;
        -: 1430:  struct mbuf buf_clnt;
        -: 1431:  struct mg_connection *clt_recv_conn;
        -: 1432:};
        -: 1433:
       17: 1434:static void eh3_srv(struct mg_connection *nc, int ev, void *p) {
       17: 1435:  struct udp_res *ur = (struct udp_res *) nc->mgr->user_data;
       17: 1436:  struct mbuf *io = &nc->recv_mbuf;
        -: 1437:  (void) p;
        -: 1438:
       17: 1439:  if (nc->flags & MG_F_LISTENING) {
       12: 1440:    if (ev != MG_EV_POLL && ev != MG_EV_CLOSE) {
    #####: 1441:      mbuf_append(&ur->buf_srv, "BUG", 3);
        -: 1442:    }
       12: 1443:    return;
        -: 1444:  }
        -: 1445:
        5: 1446:  if (ev == MG_EV_ACCEPT) {
        1: 1447:    mbuf_append(&ur->buf_srv, "ACCEPT", 6);
        4: 1448:  } else if (ev == MG_EV_RECV) {
        1: 1449:    mbuf_append(&ur->buf_srv, (nc->flags & MG_F_SEND_AND_CLOSE ? "+" : "-"), 1);
        1: 1450:    mbuf_append(&ur->buf_srv, " RECV ", 6);
        1: 1451:    mbuf_append(&ur->buf_srv, io->buf, io->len);
        1: 1452:    mg_send(nc, io->buf, io->len);
        1: 1453:    mbuf_remove(io, io->len);
        3: 1454:  } else if (ev == MG_EV_CLOSE) {
        1: 1455:    mbuf_append(&ur->buf_srv, " CLOSE", 6);
        -: 1456:  }
        -: 1457:}
        -: 1458:
        8: 1459:static void eh3_clnt(struct mg_connection *nc, int ev, void *p) {
        8: 1460:  struct udp_res *ur = (struct udp_res *) nc->mgr->user_data;
        8: 1461:  struct mbuf *io = &nc->recv_mbuf;
        -: 1462:  (void) p;
        -: 1463:
        8: 1464:  if (ev == MG_EV_CONNECT) {
        1: 1465:    mbuf_append(&ur->buf_clnt, "CONNECT", 7);
        1: 1466:    mg_printf(nc, "%s", "boo!");
        7: 1467:  } else if (ev == MG_EV_RECV) {
        1: 1468:    mbuf_append(&ur->buf_clnt, " RECV ", 6);
        1: 1469:    mbuf_append(&ur->buf_clnt, io->buf, io->len);
        1: 1470:    mbuf_remove(io, io->len);
        1: 1471:    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
        6: 1472:  } else if (ev == MG_EV_CLOSE) {
        1: 1473:    mbuf_append(&ur->buf_clnt, " CLOSE", 6);
        -: 1474:  }
        8: 1475:}
        -: 1476:
        1: 1477:static const char *test_udp(void) {
        -: 1478:  struct mg_mgr mgr;
        -: 1479:  struct mg_connection *nc1, *nc2;
        1: 1480:  const char *address = "udp://127.0.0.1:7878";
        -: 1481:  struct udp_res res;
        1: 1482:  memset(&res, 0, sizeof(res));
        1: 1483:  mbuf_init(&res.buf_srv, 100);
        1: 1484:  mbuf_init(&res.buf_clnt, 100);
        -: 1485:
        1: 1486:  mg_mgr_init(&mgr, &res);
        1: 1487:  ASSERT((nc1 = mg_bind(&mgr, address, eh3_srv)) != NULL);
        1: 1488:  ASSERT((nc2 = mg_connect(&mgr, address, eh3_clnt)) != NULL);
        -: 1489:
        1: 1490:  poll_until(&mgr, 1, c_int_eq, &res.buf_clnt.len, (void *) 23);
        1: 1491:  ASSERT_STREQ_NZ(res.buf_srv.buf, "ACCEPT+ RECV boo! CLOSE");
        1: 1492:  ASSERT_STREQ_NZ(res.buf_clnt.buf, "CONNECT RECV boo! CLOSE");
        -: 1493:
        1: 1494:  mbuf_free(&res.buf_srv);
        1: 1495:  mbuf_free(&res.buf_clnt);
        1: 1496:  mg_mgr_free(&mgr);
        -: 1497:
        1: 1498:  return NULL;
        -: 1499:}
        -: 1500:
        1: 1501:static const char *test_parse_http_message(void) {
        -: 1502:  static const char *a = "GET / HTTP/1.0\n\n";
        -: 1503:  static const char *b = "GET /blah HTTP/1.0\r\nFoo:  bar  \r\n\r\n";
        -: 1504:  static const char *c = "get b c\nz:  k \nb: t\nvvv\n\n xx";
        -: 1505:  static const char *d = "a b c\nContent-Length: 21 \nb: t\nvvv\n\n";
        -: 1506:  static const char *e = "GET /foo?a=b&c=d HTTP/1.0\n\n";
        -: 1507:  static const char *f = "POST /x HTTP/1.0\n\n";
        -: 1508:  static const char *g = "WOHOO /x HTTP/1.0\n\n";
        -: 1509:  static const char *h = "HTTP/1.0 200 OK\n\n";
        -: 1510:  static const char *i = "HTTP/1.0 999 OMGWTFBBQ\n\n";
        -: 1511:  static const char *j =
        -: 1512:      "GET / HTTP/1.0\r\nHost: 127.0.0.1:18888\r\nCookie:\r\nX-PlayID: "
        -: 1513:      "45455\r\nRange: 0-1\r\n\r\n";
        -: 1514:  int idx, len;
        -: 1515:  struct mg_str *v;
        -: 1516:  struct http_message req;
        -: 1517:
        1: 1518:  len = strlen(b);
       36: 1519:  for (idx = 0; idx < len; idx++) {
       35: 1520:    ASSERT_EQ(mg_parse_http(b, idx, &req, 1), 0);
        -: 1521:  }
        -: 1522:
        1: 1523:  ASSERT_EQ(mg_parse_http("\b23", 3, &req, 1), -1);
        1: 1524:  ASSERT_EQ(mg_parse_http("\b23", 3, &req, 0), -1);
        1: 1525:  ASSERT_EQ(mg_parse_http("get\n\n", 5, &req, 1), -1);
        1: 1526:  ASSERT_EQ(mg_parse_http("get\n\n", 5, &req, 0), -1);
        1: 1527:  ASSERT_EQ(mg_parse_http(a, strlen(a) - 1, &req, 1), 0);
        1: 1528:  ASSERT_EQ(mg_parse_http(a, strlen(a), &req, 0), -1);
        -: 1529:
        1: 1530:  ASSERT_EQ(mg_parse_http(a, strlen(a), &req, 1), (int) strlen(a));
        1: 1531:  ASSERT_EQ(req.message.len, strlen(a));
        1: 1532:  ASSERT_EQ(req.body.len, 0);
        -: 1533:
        1: 1534:  ASSERT_EQ(mg_parse_http(b, strlen(b), &req, 0), -1);
        1: 1535:  ASSERT_EQ(mg_parse_http(b, strlen(b), &req, 1), (int) strlen(b));
        1: 1536:  ASSERT_EQ(req.header_names[0].len, 3);
        1: 1537:  ASSERT_EQ(req.header_values[0].len, 3);
        1: 1538:  ASSERT(req.header_names[1].p == NULL);
        1: 1539:  ASSERT_EQ(req.query_string.len, 0);
        1: 1540:  ASSERT_EQ(req.message.len, strlen(b));
        1: 1541:  ASSERT_EQ(req.body.len, 0);
        -: 1542:
        1: 1543:  ASSERT_EQ(mg_parse_http(c, strlen(c), &req, 1), (int) strlen(c) - 3);
        1: 1544:  ASSERT(req.header_names[2].p == NULL);
        1: 1545:  ASSERT(req.header_names[0].p != NULL);
        1: 1546:  ASSERT(req.header_names[1].p != NULL);
        1: 1547:  ASSERT_EQ(memcmp(req.header_values[1].p, "t", 1), 0);
        1: 1548:  ASSERT_EQ(req.header_names[1].len, 1);
        1: 1549:  ASSERT_EQ(req.body.len, 0);
        -: 1550:
        1: 1551:  ASSERT_EQ(mg_parse_http(d, strlen(d), &req, 1), (int) strlen(d));
        1: 1552:  ASSERT_EQ(req.body.len, 21);
        1: 1553:  ASSERT_EQ(req.message.len, 21 + strlen(d));
        1: 1554:  ASSERT(mg_get_http_header(&req, "foo") == NULL);
        1: 1555:  ASSERT((v = mg_get_http_header(&req, "contENT-Length")) != NULL);
        1: 1556:  ASSERT_EQ(v->len, 2);
        1: 1557:  ASSERT_STREQ_NZ(v->p, "21");
        -: 1558:
        1: 1559:  ASSERT_EQ(mg_parse_http(e, strlen(e), &req, 1), (int) strlen(e));
        1: 1560:  ASSERT_EQ(mg_vcmp(&req.uri, "/foo"), 0);
        1: 1561:  ASSERT_EQ(mg_vcmp(&req.query_string, "a=b&c=d"), 0);
        -: 1562:
        1: 1563:  ASSERT_EQ(mg_parse_http(f, strlen(f), &req, 1), (int) strlen(f));
        1: 1564:  ASSERT_EQ64(req.body.len, (size_t) ~0);
        -: 1565:
        1: 1566:  ASSERT_EQ(mg_parse_http(g, strlen(g), &req, 1), (int) strlen(g));
        1: 1567:  ASSERT_EQ(req.body.len, 0);
        -: 1568:
        1: 1569:  ASSERT_EQ(mg_parse_http(h, strlen(h), &req, 0), (int) strlen(h));
        1: 1570:  ASSERT_EQ(mg_vcmp(&req.proto, "HTTP/1.0"), 0);
        1: 1571:  ASSERT_EQ(req.resp_code, 200);
        1: 1572:  ASSERT_EQ(mg_vcmp(&req.resp_status_msg, "OK"), 0);
        1: 1573:  ASSERT_EQ64(req.body.len, (size_t) ~0);
        -: 1574:
        1: 1575:  ASSERT_EQ(mg_parse_http(i, strlen(i), &req, 0), -1);
        -: 1576:
        1: 1577:  ASSERT_EQ(mg_parse_http(j, strlen(j), &req, 1), (int) strlen(j));
        1: 1578:  ASSERT(mg_get_http_header(&req, "Host") != NULL);
        1: 1579:  ASSERT(mg_get_http_header(&req, "Cookie") == NULL);
        1: 1580:  ASSERT(mg_get_http_header(&req, "Range") != NULL);
        -: 1581:
        1: 1582:  return NULL;
        -: 1583:}
        -: 1584:
        1: 1585:static const char *test_get_http_var(void) {
        -: 1586:  char buf[256];
        -: 1587:  struct mg_str body;
        1: 1588:  body.p = "key1=value1&key2=value2&key3=value%203&key4=value+4";
        1: 1589:  body.len = strlen(body.p);
        -: 1590:
        1: 1591:  ASSERT(mg_get_http_var(&body, "key1", buf, sizeof(buf)) > 0);
        1: 1592:  ASSERT_STREQ(buf, "value1");
        1: 1593:  ASSERT(mg_get_http_var(&body, "KEY1", buf, sizeof(buf)) > 0);
        1: 1594:  ASSERT_STREQ(buf, "value1");
        1: 1595:  ASSERT(mg_get_http_var(&body, "key2", buf, sizeof(buf)) > 0);
        1: 1596:  ASSERT_STREQ(buf, "value2");
        1: 1597:  ASSERT(mg_get_http_var(&body, "key3", buf, sizeof(buf)) > 0);
        1: 1598:  ASSERT_STREQ(buf, "value 3");
        1: 1599:  ASSERT(mg_get_http_var(&body, "key4", buf, sizeof(buf)) > 0);
        1: 1600:  ASSERT_STREQ(buf, "value 4");
        -: 1601:
        1: 1602:  ASSERT_EQ(mg_get_http_var(&body, "key1", NULL, sizeof(buf)), -2);
        1: 1603:  ASSERT_EQ(mg_get_http_var(&body, "key1", buf, 0), -2);
        1: 1604:  ASSERT_EQ(mg_get_http_var(&body, NULL, buf, sizeof(buf)), -1);
        1: 1605:  ASSERT_EQ(mg_get_http_var(&body, "key1", buf, 1), -3);
        -: 1606:
        1: 1607:  body.p = "key=broken%2";
        1: 1608:  body.len = strlen(body.p);
        1: 1609:  ASSERT(mg_get_http_var(&body, "key", buf, sizeof(buf)) < 0);
        -: 1610:
        1: 1611:  body.p = "key=broken%2x";
        1: 1612:  body.len = strlen(body.p);
        1: 1613:  ASSERT(mg_get_http_var(&body, "key", buf, sizeof(buf)) < 0);
        -: 1614:
        1: 1615:  ASSERT_EQ(mg_get_http_var(&body, "inexistent", buf, sizeof(buf)), -4);
        -: 1616:
        1: 1617:  return NULL;
        -: 1618:}
        -: 1619:
     7095: 1620:static void cb1(struct mg_connection *nc, int ev, void *ev_data) {
     7095: 1621:  if (ev == MG_EV_HTTP_REQUEST) {
       43: 1622:    struct http_message *hm = (struct http_message *) ev_data;
       43: 1623:    if (mg_vcmp(&hm->uri, "/foo") == 0) {
        1: 1624:      mg_printf(nc, "HTTP/1.0 200 OK\r\n\r\n[%.*s %d]", (int) hm->uri.len,
        1: 1625:                hm->uri.p, (int) hm->body.len);
        1: 1626:      nc->flags |= MG_F_SEND_AND_CLOSE;
        -: 1627:    } else {
       42: 1628:      s_http_server_opts.document_root = ".";
       42: 1629:      s_http_server_opts.per_directory_auth_file = "passwords.txt";
       42: 1630:      s_http_server_opts.auth_domain = "foo.com";
       42: 1631:      s_http_server_opts.dav_document_root = "./data/dav";
       42: 1632:      s_http_server_opts.hidden_file_pattern = "hidden_file.*$";
       42: 1633:      s_http_server_opts.custom_mime_types =
        -: 1634:          ".txt=text/plain; charset=windows-1251,"
        -: 1635:          ".c=text/plain; charset=utf-8";
       42: 1636:      mg_serve_http(nc, hm, s_http_server_opts);
        -: 1637:    }
     7052: 1638:  } else if (ev == MG_EV_SSI_CALL) {
        1: 1639:    mg_printf_html_escape(nc, "[ssi call: %s]", (char *) ev_data);
     7051: 1640:  } else if (ev == MG_EV_SSI_CALL_CTX) {
        1: 1641:    struct mg_ssi_call_ctx *cctx = (struct mg_ssi_call_ctx *) ev_data;
        5: 1642:    mg_printf_html_escape(nc, "[ssi call w/ ctx: %.*s %.*s %.*s]",
        2: 1643:                          (int) cctx->req->uri.len, cctx->req->uri.p,
        1: 1644:                          (int) cctx->file.len, cctx->file.p,
        1: 1645:                          (int) cctx->arg.len, cctx->arg.p);
        -: 1646:  }
     7095: 1647:}
        -: 1648:
        4: 1649:static void secret_endpoint_cb(struct mg_connection *nc, int ev,
        -: 1650:                               void *ev_data) {
        4: 1651:  if (ev != MG_EV_HTTP_REQUEST) return;
        1: 1652:  mg_send_response_line(nc, 200, "Content-Type: text/plain\r\n");
        1: 1653:  mg_printf(nc, "%s", "Secret!");
        1: 1654:  nc->flags |= MG_F_SEND_AND_CLOSE;
        -: 1655:  (void) ev_data;
        -: 1656:}
        -: 1657:
       97: 1658:static void cb2(struct mg_connection *nc, int ev, void *ev_data) {
       97: 1659:  struct http_message *hm = (struct http_message *) ev_data;
        -: 1660:
       97: 1661:  if (ev == MG_EV_HTTP_REPLY) {
        8: 1662:    sprintf((char *) nc->user_data, "%.*s %lu", (int) hm->body.len, hm->body.p,
        8: 1663:            (unsigned long) hm->message.len);
        8: 1664:    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
        -: 1665:  }
       97: 1666:}
        -: 1667:
     4644: 1668:static void cb7(struct mg_connection *nc, int ev, void *ev_data) {
     4644: 1669:  struct http_message *hm = (struct http_message *) ev_data;
        -: 1670:  size_t size;
     4644: 1671:  char *data, *user_data = (char *) nc->user_data;
        -: 1672:
     4644: 1673:  if (ev == MG_EV_HTTP_REPLY) {
        -: 1674:    /* Make sure that we've downloaded this executable, byte-to-byte */
        2: 1675:    data = read_file(g_argv_0, &size);
        2: 1676:    DBG(("file %s, size %d; got %d", g_argv_0, (int) size, (int) hm->body.len));
        4: 1677:    if (data != NULL && size == hm->body.len &&
        2: 1678:        memcmp(hm->body.p, data, size) == 0) {
        2: 1679:      strcpy(user_data, "success");
        -: 1680:    } else {
    #####: 1681:      strcpy(user_data, "fail");
        -: 1682:    }
        2: 1683:    free(data);
        2: 1684:    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
        -: 1685:  } else if (ev == MG_EV_RECV) {
        -: 1686:#if 0
        -: 1687:    LOG(LL_INFO, ("%d", (int) nc->recv_mbuf.len));
        -: 1688:#endif
        -: 1689:  }
     4644: 1690:}
        -: 1691:
      456: 1692:static void cb8(struct mg_connection *nc, int ev, void *ev_data) {
      456: 1693:  struct http_message *hm = (struct http_message *) ev_data;
      456: 1694:  DBG(("%p ev=%d", (void *) nc, ev));
        -: 1695:
      456: 1696:  if (ev == MG_EV_HTTP_REPLY) {
       86: 1697:    snprintf((char *) nc->user_data, FETCH_BUF_SIZE, "%.*s",
       43: 1698:             (int) hm->message.len, hm->message.p);
       43: 1699:    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
        -: 1700:  }
      456: 1701:}
        -: 1702:
     1556: 1703:static void cb10(struct mg_connection *nc, int ev, void *ev_data) {
     1556: 1704:  struct http_message *hm = (struct http_message *) ev_data;
        -: 1705:  struct mg_str *s;
        -: 1706:
     1556: 1707:  if (ev == MG_EV_HTTP_REPLY &&
        -: 1708:      (s = mg_get_http_header(hm, "Content-Type")) != NULL) {
        2: 1709:    sprintf((char *) nc->user_data, "%.*s", (int) s->len, s->p);
        -: 1710:  }
     1556: 1711:}
        -: 1712:
      125: 1713:static void endpoint_handler(struct mg_connection *nc, int ev, void *ev_data) {
      125: 1714:  struct http_message *hm = (struct http_message *) ev_data;
        -: 1715:  (void) ev_data;
        -: 1716:
      125: 1717:  if (ev == MG_EV_HTTP_REQUEST) {
        4: 1718:    if (mg_vcmp(&hm->uri, "/") == 0 || mg_vcmp(&hm->uri, "/foo") == 0) {
       12: 1719:      mg_printf(nc, "HTTP/1.0 200 OK\r\n\r\n[%.*s%s%.*s %d]", (int) hm->uri.len,
        4: 1720:                hm->uri.p, hm->query_string.len > 0 ? "?" : "",
        4: 1721:                (int) hm->query_string.len, hm->query_string.p,
        4: 1722:                (int) hm->body.len);
        4: 1723:      nc->flags |= MG_F_SEND_AND_CLOSE;
        -: 1724:    }
      121: 1725:  } else if (ev == MG_EV_CLOSE) {
        8: 1726:    if (nc->listener != NULL) {
        7: 1727:      (*(int *) nc->listener->user_data) += 100;
        -: 1728:    }
        -: 1729:  }
      125: 1730:}
        -: 1731:
        1: 1732:static void handle_hello1(struct mg_connection *nc, int ev, void *ev_data) {
        -: 1733:  (void) ev_data;
        1: 1734:  switch (ev) {
        1: 1735:    case MG_EV_HTTP_REQUEST:
        1: 1736:      mg_printf(nc, "HTTP/1.0 200 OK\r\n\r\n[I am Hello1]");
        1: 1737:      nc->flags |= MG_F_SEND_AND_CLOSE;
        1: 1738:      break;
    #####: 1739:    case MG_EV_CLOSE:
    #####: 1740:      (*(int *) nc->listener->user_data)++;
    #####: 1741:      break;
        -: 1742:  }
        1: 1743:}
        -: 1744:
        1: 1745:static void handle_hello2(struct mg_connection *nc, int ev, void *ev_data) {
        -: 1746:  (void) ev_data;
        1: 1747:  switch (ev) {
        1: 1748:    case MG_EV_HTTP_REQUEST:
        1: 1749:      mg_printf(nc, "HTTP/1.0 200 OK\r\n\r\n[I am Hello two]");
        1: 1750:      nc->flags |= MG_F_SEND_AND_CLOSE;
        1: 1751:      break;
    #####: 1752:    case MG_EV_CLOSE:
    #####: 1753:      (*(int *) nc->listener->user_data)++;
    #####: 1754:      break;
        -: 1755:  }
        1: 1756:}
        -: 1757:
        1: 1758:static void handle_hello5(struct mg_connection *nc, int ev, void *ev_data) {
        -: 1759:  (void) ev_data;
        1: 1760:  switch (ev) {
        1: 1761:    case MG_EV_HTTP_REQUEST:
        1: 1762:      mg_printf(nc, "HTTP/1.0 200 OK\r\n\r\n[I am Hello again]");
        1: 1763:      nc->flags |= MG_F_SEND_AND_CLOSE;
        1: 1764:      break;
    #####: 1765:    case MG_EV_CLOSE:
    #####: 1766:      (*(int *) nc->listener->user_data)++;
    #####: 1767:      break;
        -: 1768:  }
        1: 1769:}
        -: 1770:
       40: 1771:static void vfetch_http(char *buf, const char *auth_file,
        -: 1772:                        const char *request_fmt, va_list ap) {
        -: 1773:  struct mg_mgr mgr;
        -: 1774:  struct mg_connection *nc;
        -: 1775:  struct mg_http_endpoint_opts ep_opts;
        -: 1776:  char local_addr[50];
        -: 1777:
        -: 1778:  /* Setup server. Use different local port for the next invocation. */
       40: 1779:  mg_mgr_init(&mgr, NULL);
        -: 1780:  /* mgr.hexdump_file = "-"; */
       40: 1781:  snprintf(local_addr, sizeof(local_addr), "127.0.0.1:%d", s_listening_port++);
       40: 1782:  nc = mg_bind(&mgr, local_addr, cb1);
       40: 1783:  mg_set_protocol_http_websocket(nc);
       40: 1784:  memset(&ep_opts, 0, sizeof(ep_opts));
       40: 1785:  ep_opts.auth_file = auth_file;
       40: 1786:  ep_opts.auth_domain = "foo.com";
       40: 1787:  mg_register_http_endpoint_opt(nc, "/secret", secret_endpoint_cb, ep_opts);
        -: 1788:
        -: 1789:  /* Setup client */
       40: 1790:  nc = mg_connect(&mgr, local_addr, cb8);
       40: 1791:  mg_set_protocol_http_websocket(nc);
       40: 1792:  nc->user_data = buf;
       40: 1793:  mg_vprintf(nc, request_fmt, ap);
        -: 1794:
        -: 1795:  /* Run event loop, destroy server */
       40: 1796:  buf[0] = '\0';
       40: 1797:  poll_until(&mgr, 5, c_str_ne, buf, (void *) "");
        -: 1798:
       40: 1799:  mg_mgr_free(&mgr);
       40: 1800:}
        -: 1801:
       38: 1802:static void fetch_http(char *buf, const char *request_fmt, ...) {
        -: 1803:  va_list ap;
       38: 1804:  va_start(ap, request_fmt);
       38: 1805:  vfetch_http(buf, "data/auth/passwords.txt", request_fmt, ap);
       38: 1806:  va_end(ap);
       38: 1807:}
        -: 1808:
        2: 1809:static void fetch_http2(char *buf, const char *auth_file,
        -: 1810:                        const char *request_fmt, ...) {
        -: 1811:  va_list ap;
        2: 1812:  va_start(ap, request_fmt);
        2: 1813:  vfetch_http(buf, auth_file, request_fmt, ap);
        2: 1814:  va_end(ap);
        2: 1815:}
        -: 1816:
        1: 1817:static const char *test_http_endpoints(void) {
        -: 1818:  struct mg_mgr mgr;
        -: 1819:  struct mg_connection *nc;
        1: 1820:  const char *local_addr = "127.0.0.1:7778";
        -: 1821:  char buf[50];
        1: 1822:  int close_count = 0;
        -: 1823:
        1: 1824:  mg_mgr_init(&mgr, NULL);
        -: 1825:  /* mgr.hexdump_file = "-"; */
        1: 1826:  ASSERT((nc = mg_bind(&mgr, local_addr, endpoint_handler)) != NULL);
        1: 1827:  mg_register_http_endpoint(nc, "/hello1", handle_hello1 MG_UD_ARG(NULL));
        1: 1828:  mg_register_http_endpoint(nc, "/hello1/hello2",
        -: 1829:                            handle_hello2 MG_UD_ARG(NULL));
        1: 1830:  mg_register_http_endpoint(nc, "/hello5/*", handle_hello5 MG_UD_ARG(NULL));
        1: 1831:  nc->user_data = &close_count;
        -: 1832:
        1: 1833:  mg_set_protocol_http_websocket(nc);
        -: 1834:  /* Valid HTTP request. Pass test buffer to the callback. */
        1: 1835:  ASSERT((nc = mg_connect_http(&mgr, cb2, "127.0.0.1:7778", NULL,
        -: 1836:                               "0123456789")) != NULL);
        1: 1837:  memset(buf, 0, sizeof(buf));
        1: 1838:  nc->user_data = buf;
        1: 1839:  DBG(("== WAIT =="));
        1: 1840:  poll_until(&mgr, 1, c_str_ne, buf, (void *) "");
        1: 1841:  ASSERT_STREQ(buf, "[/ 10] 25");
        -: 1842:
        1: 1843:  ASSERT((nc = mg_connect_http(&mgr, cb2, "http://127.0.0.1:7778/", NULL,
        -: 1844:                               "0123456789")) != NULL);
        1: 1845:  memset(buf, 0, sizeof(buf));
        1: 1846:  nc->user_data = buf;
        1: 1847:  DBG(("== WAIT =="));
        1: 1848:  poll_until(&mgr, 1, c_str_ne, buf, (void *) "");
        1: 1849:  ASSERT_STREQ(buf, "[/ 10] 25");
        -: 1850:
        1: 1851:  ASSERT((nc = mg_connect_http(&mgr, cb2, "http://127.0.0.1:7778/foo?a=b", NULL,
        -: 1852:                               "foo")) != NULL);
        1: 1853:  memset(buf, 0, sizeof(buf));
        1: 1854:  nc->user_data = buf;
        1: 1855:  DBG(("== WAIT =="));
        1: 1856:  poll_until(&mgr, 1, c_str_ne, buf, (void *) "");
        1: 1857:  ASSERT_STREQ(buf, "[/foo?a=b 3] 31");
        -: 1858:
        1: 1859:  ASSERT((nc = mg_connect_http(&mgr, cb2, "http://127.0.0.1:7778/foo", NULL,
        -: 1860:                               "0123456789")) != NULL);
        1: 1861:  memset(buf, 0, sizeof(buf));
        1: 1862:  nc->user_data = buf;
        1: 1863:  DBG(("== WAIT =="));
        1: 1864:  poll_until(&mgr, 1, c_str_ne, buf, (void *) "");
        1: 1865:  ASSERT_STREQ(buf, "[/foo 10] 28");
        -: 1866:
        1: 1867:  ASSERT((nc = mg_connect_http(&mgr, cb2, "http://127.0.0.1:7778/hello1", NULL,
        -: 1868:                               "0123456789")) != NULL);
        1: 1869:  memset(buf, 0, sizeof(buf));
        1: 1870:  nc->user_data = buf;
        1: 1871:  DBG(("== WAIT =="));
        1: 1872:  poll_until(&mgr, 1, c_str_ne, buf, (void *) "");
        1: 1873:  ASSERT_STREQ(buf, "[I am Hello1] 32");
        -: 1874:
        1: 1875:  ASSERT((nc = mg_connect_http(&mgr, cb2, "http://127.0.0.1:7778/hello1/hello2",
        -: 1876:                               NULL, "0123456789")) != NULL);
        1: 1877:  memset(buf, 0, sizeof(buf));
        1: 1878:  nc->user_data = buf;
        1: 1879:  DBG(("== WAIT =="));
        1: 1880:  poll_until(&mgr, 1, c_str_ne, buf, (void *) "");
        1: 1881:  ASSERT_STREQ(buf, "[I am Hello two] 35");
        -: 1882:
        1: 1883:  ASSERT((nc = mg_connect_http(&mgr, cb2, "http://127.0.0.1:7778/hello5/dummy",
        -: 1884:                               NULL, "0123456789")) != NULL);
        1: 1885:  memset(buf, 0, sizeof(buf));
        1: 1886:  nc->user_data = buf;
        -: 1887:
        1: 1888:  poll_until(&mgr, 1, c_str_ne, buf, (void *) "");
        1: 1889:  ASSERT_STREQ(buf, "[I am Hello again] 37");
        -: 1890:
        1: 1891:  ASSERT_EQ(close_count, 700);
        -: 1892:
        1: 1893:  mg_mgr_free(&mgr);
        -: 1894:
        1: 1895:  return NULL;
        -: 1896:}
        -: 1897:
        1: 1898:static const char *serve_file_verify(struct http_message *hm) {
        -: 1899:  size_t size;
        1: 1900:  char *data = read_file("unit_test.c", &size);
        2: 1901:  if (data == NULL || size != hm->body.len ||
        1: 1902:      memcmp(hm->body.p, data, size) != 0) {
    #####: 1903:    return "wrong data";
        -: 1904:  }
        1: 1905:  free(data);
        -: 1906:
        -: 1907:  {
        -: 1908:    char buf[20];
        1: 1909:    struct mg_str *h = mg_get_http_header(hm, "Content-Length");
        1: 1910:    ASSERT(h != NULL);
        1: 1911:    snprintf(buf, sizeof(buf), "%d", (int) hm->body.len);
        1: 1912:    ASSERT_MG_STREQ(*h, buf);
        -: 1913:  }
        -: 1914:  {
        1: 1915:    struct mg_str *h = mg_get_http_header(hm, "Connection");
        1: 1916:    ASSERT(h != NULL);
        1: 1917:    ASSERT_MG_STREQ(*h, "keep-alive");
        -: 1918:  }
        1: 1919:  return "success";
        -: 1920:}
        -: 1921:
      791: 1922:static void serve_file_cb(struct mg_connection *nc, int ev, void *ev_data) {
      791: 1923:  struct http_message *hm = (struct http_message *) ev_data;
      791: 1924:  char *user_data = (char *) nc->user_data;
        -: 1925:
      791: 1926:  if (ev == MG_EV_HTTP_REQUEST) {
        1: 1927:    mg_http_serve_file(nc, hm, "unit_test.c", mg_mk_str("text/plain"),
        -: 1928:                       mg_mk_str(""));
      790: 1929:  } else if (ev == MG_EV_HTTP_REPLY) {
        1: 1930:    strcpy(user_data, serve_file_verify(hm));
        1: 1931:    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
        -: 1932:  }
      791: 1933:}
        -: 1934:
        1: 1935:static const char *test_http_serve_file(void) {
        -: 1936:  struct mg_mgr mgr;
        -: 1937:  struct mg_connection *lc, *nc;
        1: 1938:  const char *local_addr = "127.0.0.1:7777";
        -: 1939:  char status[100];
        1: 1940:  mg_mgr_init(&mgr, NULL);
        -: 1941:  /* mgr.hexdump_file = "-"; */
        1: 1942:  ASSERT((lc = mg_bind(&mgr, local_addr, serve_file_cb)) != NULL);
        1: 1943:  mg_set_protocol_http_websocket(lc);
        1: 1944:  ASSERT((nc = mg_connect(&mgr, local_addr, serve_file_cb)) != NULL);
        1: 1945:  mg_set_protocol_http_websocket(nc);
        1: 1946:  status[0] = '\0';
        1: 1947:  nc->user_data = status;
        1: 1948:  mg_printf(nc, "GET / HTTP/1.1\r\n\r\n");
        1: 1949:  poll_until(&mgr, 5, c_str_ne, status, (void *) "");
        1: 1950:  ASSERT_STREQ(status, "success");
        1: 1951:  mg_mgr_free(&mgr);
        1: 1952:  return NULL;
        -: 1953:}
        -: 1954:
      407: 1955:static void srv1(struct mg_connection *c, int ev, void *ev_data) {
      407: 1956:  if (ev == MG_EV_HTTP_REQUEST) {
        1: 1957:    mg_http_serve_file(c, (struct http_message *) ev_data, "unit_test.c",
        -: 1958:                       mg_mk_str("text/plain"), mg_mk_str(""));
        -: 1959:  }
      407: 1960:}
        -: 1961:
      400: 1962:static void srv2(struct mg_connection *c, int ev, void *ev_data) {
        -: 1963:  static cs_md5_ctx c1, c2;
      400: 1964:  struct http_message *hm = (struct http_message *) ev_data;
        -: 1965:
      400: 1966:  switch (ev) {
        1: 1967:    case MG_EV_CONNECT:
        1: 1968:      cs_md5_init(&c1);
        1: 1969:      cs_md5_init(&c2);
        1: 1970:      break;
      130: 1971:    case MG_EV_HTTP_CHUNK:
      130: 1972:      cs_md5_update(&c1, (const unsigned char *) hm->body.p, hm->body.len);
      130: 1973:      c->flags |= MG_F_DELETE_CHUNK;
      130: 1974:      break;
        2: 1975:    case MG_EV_HTTP_REPLY: {
        -: 1976:      unsigned char sig1[16], sig2[sizeof(sig1)];
        -: 1977:      size_t size;
        2: 1978:      char *data = read_file("unit_test.c", &size);
        2: 1979:      if (data != NULL) cs_md5_update(&c2, (const unsigned char *) data, size);
        2: 1980:      free(data);
        2: 1981:      cs_md5_final(sig1, &c1);
        2: 1982:      cs_md5_final(sig2, &c2);
        2: 1983:      *(int *) c->user_data = (memcmp(sig1, sig2, sizeof(sig1)) == 0) ? 1 : 2;
        2: 1984:      break;
        -: 1985:    }
        -: 1986:  }
      400: 1987:}
        -: 1988:
        1: 1989:static const char *test_http_serve_file_streaming(void) {
        -: 1990:  struct mg_mgr mgr;
        -: 1991:  struct mg_connection *lc, *nc;
        1: 1992:  const char *local_addr = "127.0.0.1:7732";
        1: 1993:  int status = 0;
        1: 1994:  mg_mgr_init(&mgr, NULL);
        1: 1995:  ASSERT((lc = mg_bind(&mgr, local_addr, srv1)) != NULL);
        1: 1996:  mg_set_protocol_http_websocket(lc);
        1: 1997:  ASSERT((nc = mg_connect(&mgr, local_addr, srv2)) != NULL);
        1: 1998:  mg_set_protocol_http_websocket(nc);
        1: 1999:  nc->user_data = &status;
        1: 2000:  mg_printf(nc, "GET / HTTP/1.1\r\n\r\n");
        1: 2001:  poll_until(&mgr, 30, c_int_ne, &status, (void *) 0);
        1: 2002:  ASSERT_EQ(status, 1);
        1: 2003:  mg_mgr_free(&mgr);
        1: 2004:  return NULL;
        -: 2005:}
        -: 2006:
        1: 2007:static const char *test_http(void) {
        -: 2008:  struct mg_mgr mgr;
        -: 2009:  struct mg_connection *nc;
        1: 2010:  const char *this_binary, *local_addr = "127.0.0.1:7777";
        1: 2011:  char buf[50] = "", status[100] = "", mime1[20] = "", mime2[100] = "";
        1: 2012:  char opt_buf[1024] = "";
        1: 2013:  const char *opt_answer =
        -: 2014:      "HTTP/1.1 200 OK\r\nServer: Mongoose/" MG_VERSION
        -: 2015:      "\r\nAllow: GET, POST, HEAD, CONNECT, OPTIONS, MKCOL, "
        -: 2016:      "PUT, DELETE, PROPFIND, MOVE";
        -: 2017:  char url[1000];
        -: 2018:
        1: 2019:  mg_mgr_init(&mgr, NULL);
        -: 2020:  /* mgr.hexdump_file = "-"; */
        1: 2021:  ASSERT((nc = mg_bind(&mgr, local_addr, cb1)) != NULL);
        -: 2022:
        1: 2023:  mg_set_protocol_http_websocket(nc);
        -: 2024:  /* Valid HTTP request. Pass test buffer to the callback. */
        1: 2025:  ASSERT((nc = mg_connect_http(&mgr, cb2, "http://127.0.0.1:7777/foo", NULL,
        -: 2026:                               "0123456789")) != NULL);
        1: 2027:  nc->user_data = buf;
        1: 2028:  DBG(("== WAIT =="));
        1: 2029:  poll_until(&mgr, 1, c_str_ne, buf, (void *) "");
        1: 2030:  ASSERT_STREQ(buf, "[/foo 10] 28");
        -: 2031:
        -: 2032:  /* OPTIONS request */
        1: 2033:  ASSERT((nc = mg_connect(&mgr, local_addr, cb8)) != NULL);
        1: 2034:  mg_set_protocol_http_websocket(nc);
        1: 2035:  nc->user_data = opt_buf;
        -: 2036:
        1: 2037:  mg_printf(nc, "%s", "OPTIONS / HTTP 1.0\n\n");
        -: 2038:
        1: 2039:  poll_until(&mgr, 1, c_str_ne, opt_buf, (void *) "");
        1: 2040:  ASSERT_STREQ_NZ(opt_buf, opt_answer);
        -: 2041:
        -: 2042:  /* Invalid HTTP request */
        1: 2043:  ASSERT((nc = mg_connect(&mgr, local_addr, cb2)) != NULL);
        1: 2044:  mg_set_protocol_http_websocket(nc);
        -: 2045:
        1: 2046:  mg_printf(nc, "%s", "bl\x03\n\n");
        -: 2047:  /* Test static file download by downloading this executable, argv[0] */
        1: 2048:  ASSERT((nc = mg_connect(&mgr, local_addr, cb7)) != NULL);
        1: 2049:  mg_set_protocol_http_websocket(nc);
        1: 2050:  nc->user_data = status;
        1: 2051:  mbuf_resize(&nc->recv_mbuf, 10000000);
        -: 2052:
        -: 2053:  /* Wine and GDB set argv0 to full path: strip the dir component */
        1: 2054:  if ((this_binary = strrchr(g_argv_0, '\\')) != NULL) {
    #####: 2055:    this_binary++;
        1: 2056:  } else if ((this_binary = strrchr(g_argv_0, '/')) != NULL) {
        1: 2057:    this_binary++;
        -: 2058:  } else {
    #####: 2059:    this_binary = g_argv_0;
        -: 2060:  }
        1: 2061:  mg_printf(nc, "GET /%s HTTP/1.0\n\n", this_binary);
        -: 2062:  /* Test mime type for static file */
        1: 2063:  snprintf(url, sizeof(url), "http://%s/data/dummy.xml", local_addr);
        1: 2064:  ASSERT((nc = mg_connect_http(&mgr, cb10, url, NULL, NULL)) != NULL);
        1: 2065:  nc->user_data = mime1;
        -: 2066:
        -: 2067:  /* Test custom mime type for static file */
        1: 2068:  snprintf(url, sizeof(url), "http://%s/data/range.txt", local_addr);
        1: 2069:  ASSERT((nc = mg_connect_http(&mgr, cb10, url, NULL, NULL)) != NULL);
        1: 2070:  nc->user_data = mime2;
        -: 2071:
        -: 2072:  /* Run event loop. Use more cycles to let file download complete. */
        1: 2073:  poll_until(&mgr, 15, c_str_ne, status, (void *) "");
        1: 2074:  mg_mgr_free(&mgr);
        -: 2075:
        -: 2076:  /* Check that test buffer has been filled by the callback properly. */
        1: 2077:  ASSERT_STREQ(status, "success");
        1: 2078:  ASSERT_STREQ(mime1, "text/xml");
        1: 2079:  ASSERT_STREQ(mime2, "text/plain; charset=windows-1251");
        -: 2080:
        1: 2081:  return NULL;
        -: 2082:}
        -: 2083:
       46: 2084:static void http_pipeline_handler(struct mg_connection *c, int ev,
        -: 2085:                                  void *ev_data) {
        -: 2086:  (void) ev_data;
       46: 2087:  int *status = (int *) c->mgr->user_data;
       46: 2088:  if (ev == MG_EV_HTTP_REQUEST) {
        -: 2089:    /* Server request handler */
        2: 2090:    mg_send_response_line(c, 200,
        -: 2091:                          "Content-Type: text/plain\r\nContent-Length: 5\r\n");
        2: 2092:    mg_printf(c, "Hello");
        2: 2093:    *status = *status + 1;
       44: 2094:  } else if (ev == MG_EV_HTTP_REPLY) {
        -: 2095:    /* Client reply handler */
        2: 2096:    *status = *status + 10;
        -: 2097:  }
       46: 2098:}
        -: 2099:
        1: 2100:static const char *test_http_pipeline(void) {
        -: 2101:  struct mg_mgr mgr;
        -: 2102:  struct mg_connection *lc, *nc1;
        1: 2103:  const char *local_addr = "127.0.0.1:7777";
        1: 2104:  int status = 0;
        -: 2105:
        1: 2106:  mg_mgr_init(&mgr, (void *) &status);
        1: 2107:  ASSERT(lc = mg_bind(&mgr, local_addr, http_pipeline_handler));
        1: 2108:  mg_set_protocol_http_websocket(lc);
        1: 2109:  ASSERT(nc1 = mg_connect(&mgr, local_addr, http_pipeline_handler));
        1: 2110:  mg_set_protocol_http_websocket(nc1);
        1: 2111:  mg_printf(nc1, "GET / HTTP/1.1\r\n\r\nGET / HTTP/1.1\r\n\r\n");
        1: 2112:  poll_until(&mgr, 1, c_int_eq, &status, (void *) 22);
        1: 2113:  ASSERT_EQ(status, 22);
        1: 2114:  mg_mgr_free(&mgr);
        1: 2115:  return NULL;
        -: 2116:}
        -: 2117:
        1: 2118:static const char *test_http_send_redirect(void) {
        -: 2119:  struct mg_connection nc;
        1: 2120:  init_test_connection(&nc);
        -: 2121:
        1: 2122:  mg_http_send_redirect(&nc, 301, mg_mk_str("http://foo"), mg_mk_str(NULL));
        1: 2123:  mg_send(&nc, "", 1); /* NUL */
        1: 2124:  ASSERT_STREQ_NZ(nc.send_mbuf.buf,
        -: 2125:                  "HTTP/1.1 301 Moved\r\n"
        -: 2126:                  "Server: Mongoose/" MG_VERSION
        -: 2127:                  "\r\n"
        -: 2128:                  "Location: http://foo\r\n"
        -: 2129:                  "Content-Type: text/html\r\n"
        -: 2130:                  "Content-Length: 41\r\n"
        -: 2131:                  "Cache-Control: no-cache\r\n"
        -: 2132:                  "\r\n"
        -: 2133:                  "<p>Moved <a href='http://foo'>here</a>.\r\n");
        1: 2134:  ASSERT_EQ(nc.send_mbuf.len, 179);
        1: 2135:  mbuf_remove(&nc.send_mbuf, nc.send_mbuf.len);
        -: 2136:
        1: 2137:  mg_http_send_redirect(&nc, 302, mg_mk_str("/bar"), mg_mk_str("O-M-G: WTF?!"));
        1: 2138:  mg_send(&nc, "", 1); /* NUL */
        1: 2139:  ASSERT_STREQ_NZ(nc.send_mbuf.buf,
        -: 2140:                  "HTTP/1.1 302 Found\r\n"
        -: 2141:                  "Server: Mongoose/" MG_VERSION
        -: 2142:                  "\r\n"
        -: 2143:                  "Location: /bar\r\n"
        -: 2144:                  "Content-Type: text/html\r\n"
        -: 2145:                  "Content-Length: 35\r\n"
        -: 2146:                  "Cache-Control: no-cache\r\n"
        -: 2147:                  "O-M-G: WTF?!\r\n"
        -: 2148:                  "\r\n"
        -: 2149:                  "<p>Moved <a href='/bar'>here</a>.\r\n");
        1: 2150:  ASSERT_EQ(nc.send_mbuf.len, 181);
        1: 2151:  mbuf_remove(&nc.send_mbuf, nc.send_mbuf.len);
        -: 2152:
        1: 2153:  mbuf_free(&nc.send_mbuf);
        1: 2154:  return NULL;
        -: 2155:}
        -: 2156:
        1: 2157:static const char *test_http_digest_auth(void) {
        -: 2158:  char buf[FETCH_BUF_SIZE], auth_hdr[200];
        -: 2159:  char nonce[40];
        -: 2160:  struct mg_str bufstr;
        -: 2161:
        -: 2162:  /* Test digest authorization popup - per-directory auth file */
        1: 2163:  fetch_http(buf, "%s", "GET /data/auth/a.txt?a=b HTTP/1.0\r\n\r\n");
        1: 2164:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 401");
        1: 2165:  bufstr = mg_mk_str(buf);
        1: 2166:  ASSERT_GT(mg_http_parse_header(&bufstr, "nonce", nonce, sizeof(nonce)), 0);
        1: 2167:  buf[0] = '\0';
        -: 2168:  /* Per-endpoint auth config */
        1: 2169:  fetch_http(buf, "%s", "GET /secret HTTP/1.0\r\n\r\n");
        1: 2170:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 401");
        -: 2171:#if MG_ENABLE_HTTP_STREAMING_MULTIPART
        1: 2172:  fetch_http(buf, "%s",
        -: 2173:             "POST /secret/upload HTTP/1.0\r\n"
        -: 2174:             "Content-Type: multipart/form-data;boundary=omgwtf\r\n"
        -: 2175:             "\r\n--omgwtf\r\n");
        1: 2176:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 401");
        -: 2177:#endif
        -: 2178:
        -: 2179:  /* Test digest authorization success */
        1: 2180:  mg_http_create_digest_auth_header(auth_hdr, sizeof(auth_hdr), "GET",
        -: 2181:                                    "/data/auth/a.txt?a=b", "foo.com", "joe",
        -: 2182:                                    "doe", nonce);
        1: 2183:  fetch_http(buf, "GET /data/auth/a.txt?a=b HTTP/1.0\r\n%s\r\n\r\n", auth_hdr);
        1: 2184:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 200");
        1: 2185:  ASSERT_STREQ(buf + strlen(buf) - 7, "\r\n\r\nhi\n");
        1: 2186:  mg_http_create_digest_auth_header(auth_hdr, sizeof(auth_hdr), "GET",
        -: 2187:                                    "/secret", "foo.com", "joe", "doe", nonce);
        1: 2188:  fetch_http(buf, "GET /secret HTTP/1.0\r\n%s\r\n\r\n", auth_hdr);
        1: 2189:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 200");
        1: 2190:  ASSERT_STREQ(buf + strlen(buf) - 7, "Secret!");
        -: 2191:
        -: 2192:  /* Test digest authorization failure with non-existing passwords file */
        1: 2193:  mg_http_create_digest_auth_header(auth_hdr, sizeof(auth_hdr), "GET",
        -: 2194:                                    "/data/auth/a.txt?a=b", "foo.com", "joe",
        -: 2195:                                    "doe", nonce);
        1: 2196:  fetch_http2(buf, "data/auth/non-existing-passwords.txt",
        -: 2197:              "GET /data/auth/a.txt?a=b HTTP/1.0\r\n%s\r\n\r\n", auth_hdr);
        1: 2198:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 200");
        1: 2199:  ASSERT_STREQ(buf + strlen(buf) - 7, "\r\n\r\nhi\n");
        1: 2200:  mg_http_create_digest_auth_header(auth_hdr, sizeof(auth_hdr), "GET",
        -: 2201:                                    "/secret", "foo.com", "joe", "doe", nonce);
        1: 2202:  fetch_http2(buf, "data/auth/non-existing-passwords.txt",
        -: 2203:              "GET /secret HTTP/1.0\r\n%s\r\n\r\n", auth_hdr);
        1: 2204:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 401");
        -: 2205:
        -: 2206:  /* Test digest authorization failure with old nonce */
        -: 2207:  {
        -: 2208:    /*
        -: 2209:     * Add 10 seconds to the nonce value, so that it'll be in the future
        -: 2210:     * and mg_check_nonce() should fail.
        -: 2211:     */
        1: 2212:    unsigned long nonce_val = strtoul(nonce, NULL, 16);
        1: 2213:    sprintf(nonce, "%lx", nonce_val + 10);
        -: 2214:
        1: 2215:    mg_http_create_digest_auth_header(auth_hdr, sizeof(auth_hdr), "GET",
        -: 2216:                                      "/data/auth/a.txt?a=b", "foo.com", "joe",
        -: 2217:                                      "doe", nonce);
        1: 2218:    fetch_http(buf, "GET /data/auth/a.txt?a=b HTTP/1.0\r\n%s\r\n\r\n",
        -: 2219:               auth_hdr);
        1: 2220:    ASSERT_STREQ_NZ(buf, "HTTP/1.1 401");
        -: 2221:
        1: 2222:    mg_http_create_digest_auth_header(auth_hdr, sizeof(auth_hdr), "GET",
        -: 2223:                                      "/secret", "foo.com", "joe", "doe",
        -: 2224:                                      nonce);
        -: 2225:
        1: 2226:    fetch_http(buf, "GET /secret HTTP/1.0\r\n%s\r\n\r\n", auth_hdr);
        1: 2227:    ASSERT_STREQ_NZ(buf, "HTTP/1.1 401");
        -: 2228:
        -: 2229:    /* Make nonce 1-hour-old, so mg_check_nonce() should fail again. */
        1: 2230:    sprintf(nonce, "%lx", nonce_val - 60 * 60);
        -: 2231:
        1: 2232:    mg_http_create_digest_auth_header(auth_hdr, sizeof(auth_hdr), "GET",
        -: 2233:                                      "/data/auth/a.txt?a=b", "foo.com", "joe",
        -: 2234:                                      "doe", nonce);
        1: 2235:    fetch_http(buf, "GET /data/auth/a.txt?a=b HTTP/1.0\r\n%s\r\n\r\n",
        -: 2236:               auth_hdr);
        1: 2237:    ASSERT_STREQ_NZ(buf, "HTTP/1.1 401");
        -: 2238:
        -: 2239:    /* Renew nonce to represent the actual nonce from the server */
        1: 2240:    bufstr = mg_mk_str(buf);
        1: 2241:    ASSERT_GT(mg_http_parse_header(&bufstr, "nonce", nonce, sizeof(nonce)), 0);
        -: 2242:  }
        -: 2243:
        -: 2244:  /* Test that passwords file is hidden from view */
        1: 2245:  mg_http_create_digest_auth_header(auth_hdr, sizeof(auth_hdr), "GET",
        -: 2246:                                    "/data/auth/p%61sswords%2etxt", "foo.com",
        -: 2247:                                    "joe", "doe", nonce);
        1: 2248:  fetch_http(buf,
        -: 2249:             "GET /data/auth/p%%61sswords%%2etxt HTTP/1.0\r\n"
        -: 2250:             "%s\r\n\r\n",
        -: 2251:             auth_hdr);
        1: 2252:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 404");
        -: 2253:  /* On case-insensitive filesystems too. */
        1: 2254:  mg_http_create_digest_auth_header(auth_hdr, sizeof(auth_hdr), "GET",
        -: 2255:                                    "/data/auth/Passwords.txt", "foo.com",
        -: 2256:                                    "joe", "doe", nonce);
        1: 2257:  fetch_http(buf,
        -: 2258:             "GET /data/auth/Passwords.txt HTTP/1.0\r\n"
        -: 2259:             "%s\r\n\r\n",
        -: 2260:             auth_hdr);
        1: 2261:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 404");
        -: 2262:
        1: 2263:  return NULL;
        -: 2264:}
        -: 2265:
        1: 2266:static const char *test_http_errors(void) {
        -: 2267:  struct mg_mgr mgr;
        -: 2268:  struct mg_connection *nc;
        1: 2269:  const char *local_addr = "127.0.0.1:7777";
        1: 2270:  char status[1000] = "";
        -: 2271:
        1: 2272:  mg_mgr_init(&mgr, NULL);
        1: 2273:  s_http_server_opts.enable_directory_listing = NULL;
        1: 2274:  ASSERT((nc = mg_bind(&mgr, local_addr, cb1)) != NULL);
        1: 2275:  mg_set_protocol_http_websocket(nc);
        -: 2276:
        -: 2277:#if !defined(TEST_UNDER_VIRTUALBOX) && !defined(_WIN32)
        -: 2278:  /* Test file which exists but cannot be opened */
        1: 2279:  ASSERT((nc = mg_connect(&mgr, local_addr, cb8)) != NULL);
        1: 2280:  mg_set_protocol_http_websocket(nc);
        1: 2281:  nc->user_data = status;
        1: 2282:  system("touch test_unreadable; chmod 000 test_unreadable");
        1: 2283:  mg_printf(nc, "GET /%s HTTP/1.0\n\n", "../test_unreadable");
        -: 2284:
        -: 2285:  /* Run event loop. Use more cycles to let file download complete. */
        1: 2286:  poll_until(&mgr, 1, c_str_ne, status, (void *) "");
        1: 2287:  system("rm -f test_unreadable");
        -: 2288:
        -: 2289:  /* Check that it failed */
        1: 2290:  ASSERT_STREQ_NZ(status, "HTTP/1.1 403");
        -: 2291:#endif
        -: 2292:
        -: 2293:  /* Test non existing file */
        1: 2294:  ASSERT((nc = mg_connect(&mgr, local_addr, cb8)) != NULL);
        1: 2295:  mg_set_protocol_http_websocket(nc);
        1: 2296:  status[0] = '\0';
        1: 2297:  nc->user_data = status;
        1: 2298:  mg_printf(nc, "GET /%s HTTP/1.0\n\n", "/please_dont_create_this_file_srsly");
        -: 2299:
        1: 2300:  poll_until(&mgr, 1, c_str_ne, status, (void *) "");
        -: 2301:
        -: 2302:  /* Check that it failed */
        1: 2303:  ASSERT_STREQ_NZ(status, "HTTP/1.1 404");
        -: 2304:
        -: 2305:  /* Cleanup */
        1: 2306:  mg_mgr_free(&mgr);
        -: 2307:
        1: 2308:  return NULL;
        -: 2309:}
        -: 2310:
        1: 2311:static const char *test_http_index(void) {
        -: 2312:  char buf[FETCH_BUF_SIZE];
        1: 2313:  fetch_http(buf, "%s", "GET /data/dir_with_index/ HTTP/1.0\r\n\r\n");
        1: 2314:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 200");
        1: 2315:  ASSERT(strstr(buf, "Content-Length: 3\r\n") != 0);
        1: 2316:  ASSERT_STREQ(buf + strlen(buf) - 5, "\r\nfoo");
        -: 2317:  /* Directory listing: allowed by default. */
        1: 2318:  s_http_server_opts.enable_directory_listing = NULL;
        1: 2319:  fetch_http(buf, "%s", "GET /data/dir_no_index/ HTTP/1.0\r\n\r\n");
        1: 2320:  ASSERT_STREQ_NZ(buf,
        -: 2321:                  "HTTP/1.1 200 OK\r\n"
        -: 2322:                  "Server: Mongoose/" MG_VERSION
        -: 2323:                  "\r\n"
        -: 2324:                  "Transfer-Encoding: chunked\r\n");
        1: 2325:  ASSERT(strstr(buf, "<html><head><title>") != NULL);
        -: 2326:  /* Allowed explicitly. */
        1: 2327:  s_http_server_opts.enable_directory_listing = "yes";
        1: 2328:  fetch_http(buf, "%s", "GET /data/dir_no_index/ HTTP/1.0\r\n\r\n");
        1: 2329:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 200");
        -: 2330:  /* Disallowed. */
        1: 2331:  s_http_server_opts.enable_directory_listing = "no";
        1: 2332:  fetch_http(buf, "%s", "GET /data/dir_no_index/ HTTP/1.0\r\n\r\n");
        1: 2333:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 403");
        1: 2334:  return NULL;
        -: 2335:}
        -: 2336:
        1: 2337:static const char *test_ssi(void) {
        -: 2338:  char buf[FETCH_BUF_SIZE];
        1: 2339:  fetch_http(buf, "%s", "GET /data/ssi/ HTTP/1.0\n\n");
        1: 2340:  ASSERT_STREQ(buf,
        -: 2341:               "HTTP/1.1 200 OK\r\n"
        -: 2342:               "Server: Mongoose/" MG_VERSION
        -: 2343:               "\r\n"
        -: 2344:               "Content-Type: text/html\r\n"
        -: 2345:               "Connection: close\r\n\r\na\n\n"
        -: 2346:               "<b>[ssi call: foo(bar)]"
        -: 2347:               "[ssi call w/ ctx: /data/ssi/ ." DS "data" DS "ssi" DS
        -: 2348:               "nested.shtml foo(bar)]"
        -: 2349:               "</b>\nb\n\n\n");
        1: 2350:  return NULL;
        -: 2351:}
        -: 2352:
        -: 2353:#ifndef NO_CGI_TEST
        1: 2354:static const char *test_cgi(void) {
        -: 2355:  char buf[FETCH_BUF_SIZE];
        -: 2356:  char expected_server_port[100];
        1: 2357:  const char *post_data = "aa=1234&bb=hi there";
        -: 2358:
        1: 2359:  fetch_http(buf,
        -: 2360:             "POST /data/cgi/ HTTP/1.0\r\n"
        -: 2361:             "Content-Type: application/x-www-form-urlencoded\r\n"
        -: 2362:             "Content-Length: %d\n\n%s",
        1: 2363:             (int) strlen(post_data), post_data);
        -: 2364:
        -: 2365:  /* fprintf(stderr, "%s", buf); */
        -: 2366:
        1: 2367:  snprintf(expected_server_port, sizeof(expected_server_port),
        -: 2368:           "\nE: SERVER_PORT=%d\r\n", s_listening_port - 1);
        1: 2369:  ASSERT(strstr(buf, expected_server_port) != NULL);
        -: 2370:
        1: 2371:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 201 Created\r\n");
        1: 2372:  ASSERT(strstr(buf, "\nE: CONTENT_LENGTH=19\r\n") != NULL);
        1: 2373:  ASSERT(
        -: 2374:      strstr(buf, "\nE: CONTENT_TYPE=application/x-www-form-urlencoded\r\n") !=
        -: 2375:      NULL);
        1: 2376:  ASSERT(strstr(buf, "\nE: DOCUMENT_ROOT=.\r\n") != NULL);
        1: 2377:  ASSERT(strstr(buf, "\nE: HTTPS=off\r\n") != NULL);
        1: 2378:  ASSERT(strstr(buf, "\nE: HTTP_CONTENT_LENGTH=19\r\n") != NULL);
        1: 2379:  ASSERT(
        -: 2380:      strstr(buf,
        -: 2381:             "\nE: HTTP_CONTENT_TYPE=application/x-www-form-urlencoded\r\n") !=
        -: 2382:      NULL);
        1: 2383:  ASSERT(strstr(buf, "\nE: REMOTE_ADDR=127.0.0.1\r\n") != NULL);
        1: 2384:  ASSERT(strstr(buf, "\nE: REQUEST_METHOD=POST\r\n") != NULL);
        1: 2385:  ASSERT(strstr(buf, "\nE: REQUEST_URI=/data/cgi/\r\n") != NULL);
        1: 2386:  ASSERT(strstr(buf, "\nE: SCRIPT_NAME=/data/cgi/index.cgi\r\n") != NULL);
        1: 2387:  ASSERT(strstr(buf, "\nE: SCRIPT_FILENAME=." DS "data" DS "cgi" DS
        -: 2388:                     "index.cgi\r\n") != NULL);
        1: 2389:  ASSERT(strstr(buf, "\nE: PATH_INFO=") == NULL);
        1: 2390:  ASSERT(strstr(buf, "\nE: PATH_TRANSLATED=") == NULL);
        1: 2391:  ASSERT(strstr(buf, "\nE: SERVER_SOFTWARE=Mongoose/" MG_VERSION "\r\n") !=
        -: 2392:         NULL);
        1: 2393:  ASSERT(strstr(buf, "\nP: aa=1234\r\n") != NULL);
        1: 2394:  ASSERT(strstr(buf, "\nP: bb=hi there\r\n") != NULL);
        -: 2395:
        1: 2396:  fetch_http(buf,
        -: 2397:             "GET /data/cgi/index%%2ecgi/foo%%2fbar/baz/?x=y HTTP/1.0\r\n\r\n");
        -: 2398:
        1: 2399:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 201 Created\r\n");
        1: 2400:  ASSERT(strstr(buf, "\nE: CONTENT_LENGTH=") == NULL);
        1: 2401:  ASSERT(strstr(buf, "\nE: CONTENT_TYPE=") == NULL);
        1: 2402:  ASSERT(strstr(buf, "\nE: DOCUMENT_ROOT=.\r\n") != NULL);
        1: 2403:  ASSERT(strstr(buf, "\nE: HTTPS=off\r\n") != NULL);
        1: 2404:  ASSERT(strstr(buf, "\nE: HTTP_CONTENT_LENGTH=") == NULL);
        1: 2405:  ASSERT(strstr(buf, "\nE: HTTP_CONTENT_TYPE=") == NULL);
        1: 2406:  ASSERT(strstr(buf, "\nE: REQUEST_METHOD=GET\r\n") != NULL);
        1: 2407:  ASSERT(
        -: 2408:      strstr(buf,
        -: 2409:             "\nE: REQUEST_URI=/data/cgi/index%2ecgi/foo%2fbar/baz/?x=y\r\n") !=
        -: 2410:      NULL);
        1: 2411:  ASSERT(strstr(buf, "\nE: SCRIPT_NAME=/data/cgi/index%2ecgi\r\n") != NULL);
        1: 2412:  ASSERT(strstr(buf, "\nE: SCRIPT_FILENAME=." DS "data" DS "cgi" DS
        -: 2413:                     "index.cgi\r\n") != NULL);
        1: 2414:  ASSERT(strstr(buf, "\nE: PATH_INFO=/foo%2fbar/baz/") != NULL);
        1: 2415:  ASSERT(strstr(buf, "\nE: PATH_TRANSLATED=/foo%2fbar/baz/") != NULL);
        1: 2416:  ASSERT(strstr(buf, "\nE: SERVER_SOFTWARE=Mongoose/" MG_VERSION "\r\n") !=
        -: 2417:         NULL);
        1: 2418:  ASSERT(strstr(buf, "\nQ: x=y\r\n") != NULL);
        -: 2419:
        1: 2420:  return NULL;
        -: 2421:}
        -: 2422:#endif
        -: 2423:
        1: 2424:static const char *test_http_rewrites(void) {
        -: 2425:  char buf[FETCH_BUF_SIZE];
        -: 2426:
        1: 2427:  s_http_server_opts.url_rewrites =
        -: 2428:      "/~joe=./data/rewrites,"
        -: 2429:      "@foo.com=./data/rewrites/foo.com";
        -: 2430:
        -: 2431:  /* Test rewrite */
        1: 2432:  fetch_http(buf, "%s", "GET /~joe/msg.txt HTTP/1.0\nHost: foo.co\n\n");
        1: 2433:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 200 OK");
        1: 2434:  ASSERT(strstr(buf, "Content-Length: 6\r\n") != 0);
        1: 2435:  ASSERT_STREQ(buf + strlen(buf) - 8, "\r\nworks\n");
        -: 2436:
        -: 2437:  /* Test rewrite that points to directory, expect redirect */
        1: 2438:  fetch_http(buf, "%s", "GET /~joe HTTP/1.0\n\n");
        1: 2439:  ASSERT_STREQ(buf,
        -: 2440:               "HTTP/1.1 301 Moved\r\nLocation: /~joe/\r\n"
        -: 2441:               "Content-Length: 0\r\n\r\n");
        -: 2442:
        -: 2443:  /* Test domain-based rewrite */
        1: 2444:  fetch_http(buf, "%s", "GET / HTTP/1.0\nHost: foo.com\n\n");
        1: 2445:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 200 OK");
        1: 2446:  ASSERT(strstr(buf, "Content-Length: 9\r\n") != 0);
        1: 2447:  ASSERT_STREQ(buf + strlen(buf) - 11, "\r\nfoo_root\n");
        -: 2448:
        -: 2449:  /* Test port-based rewrites */
        1: 2450:  s_listening_port = 25555;
        1: 2451:  s_http_server_opts.url_rewrites = "%25555=https://foo";
        1: 2452:  fetch_http(buf, "%s", "GET / HTTP/1.0\n\n");
        1: 2453:  ASSERT_STREQ(buf,
        -: 2454:               "HTTP/1.1 301 Moved\r\n"
        -: 2455:               "Server: Mongoose/" MG_VERSION
        -: 2456:               "\r\n"
        -: 2457:               "Content-Length: 0\r\n"
        -: 2458:               "Location: https://foo/\r\n\r\n");
        -: 2459:
        1: 2460:  return NULL;
        -: 2461:}
        -: 2462:
        1: 2463:static const char *test_http_dav(void) {
        -: 2464:  char buf[FETCH_BUF_SIZE];
        -: 2465:  cs_stat_t st;
        -: 2466:
        1: 2467:  remove("./data/dav/b.txt");
        1: 2468:  rmdir("./data/dav/d");
        -: 2469:
        -: 2470:  /* Test PROPFIND  */
        1: 2471:  s_http_server_opts.enable_directory_listing = "yes";
        1: 2472:  fetch_http(buf, "%s", "PROPFIND / HTTP/1.0\n\n");
        1: 2473:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 207");
        1: 2474:  ASSERT(strstr(buf, "a.txt") != NULL);
        1: 2475:  ASSERT(strstr(buf, "hidden_file.txt") == NULL);
        -: 2476:
        -: 2477:  /* Test MKCOL */
        1: 2478:  fetch_http(buf, "%s", "MKCOL /d HTTP/1.0\nContent-Length:5\n\n12345");
        1: 2479:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 415");
        1: 2480:  fetch_http(buf, "%s", "MKCOL /d HTTP/1.0\n\n");
        1: 2481:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 201");
        1: 2482:  fetch_http(buf, "%s", "MKCOL /d HTTP/1.0\n\n");
        1: 2483:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 405");
        1: 2484:  fetch_http(buf, "%s", "MKCOL /x/d HTTP/1.0\n\n");
        1: 2485:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 409");
        -: 2486:
        -: 2487:  /* Test PUT */
        1: 2488:  fetch_http(buf, "%s", "PUT /b.txt HTTP/1.0\nContent-Length: 5\n\n12345");
        1: 2489:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 201");
        1: 2490:  fetch_http(buf, "%s", "GET /data/dav/b.txt HTTP/1.0\n\n");
        1: 2491:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 200");
        1: 2492:  ASSERT(strstr(buf, "Content-Length: 5\r\n") != 0);
        1: 2493:  ASSERT_STREQ(buf + strlen(buf) - 7, "\r\n12345");
        -: 2494:
        -: 2495:  /* Test DELETE */
        1: 2496:  fetch_http(buf, "%s", "DELETE /b.txt HTTP/1.0\n\n");
        1: 2497:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 204");
        1: 2498:  ASSERT(mg_stat("./data/dav/b.txt", &st) != 0);
        1: 2499:  fetch_http(buf, "%s", "DELETE /d HTTP/1.0\n\n");
        1: 2500:  ASSERT(mg_stat("./data/dav/d", &st) != 0);
        -: 2501:
        -: 2502:  /* Non-existing file */
        1: 2503:  fetch_http(buf, "%s", "PROPFIND /__blah.txt HTTP/1.0\n\n");
        1: 2504:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 404");
        -: 2505:
        1: 2506:  return NULL;
        -: 2507:}
        -: 2508:
        1: 2509:static const char *test_http_range(void) {
        -: 2510:  char buf[FETCH_BUF_SIZE];
        -: 2511:
        1: 2512:  fetch_http(buf, "%s", "GET /data/range.txt HTTP/1.0\n\n");
        1: 2513:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 200 OK");
        1: 2514:  ASSERT(strstr(buf, "Content-Length: 312\r\n") != 0);
        -: 2515:
        -: 2516:  /* Fetch a piece from the middle of the file */
        1: 2517:  fetch_http(buf, "%s", "GET /data/range.txt HTTP/1.0\nRange: bytes=5-10\n\n");
        1: 2518:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 206 Partial Content");
        1: 2519:  ASSERT(strstr(buf, "Content-Length: 6\r\n") != 0);
        1: 2520:  ASSERT(strstr(buf, "Content-Range: bytes 5-10/312\r\n") != 0);
        1: 2521:  ASSERT_STREQ(buf + strlen(buf) - 8, "\r\n of co");
        -: 2522:
        -: 2523:  /* Fetch till EOF */
        1: 2524:  fetch_http(buf, "%s", "GET /data/range.txt HTTP/1.0\nRange: bytes=300-\n\n");
        1: 2525:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 206 Partial Content");
        1: 2526:  ASSERT(strstr(buf, "Content-Length: 12\r\n") != 0);
        1: 2527:  ASSERT(strstr(buf, "Content-Range: bytes 300-311/312\r\n") != 0);
        1: 2528:  ASSERT_STREQ(buf + strlen(buf) - 14, "\r\nis disease.\n");
        -: 2529:
        -: 2530:  /* Fetch past EOF, must trigger 416 response */
        1: 2531:  fetch_http(buf, "%s", "GET /data/range.txt HTTP/1.0\nRange: bytes=1000-\n\n");
        1: 2532:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 416");
        1: 2533:  ASSERT(strstr(buf, "Content-Length: 0\r\n") != 0);
        1: 2534:  ASSERT(strstr(buf, "Content-Range: bytes */312\r\n") != 0);
        -: 2535:
        -: 2536:  /* Request range past EOF, must trigger 416 response */
        1: 2537:  fetch_http(buf, "%s", "GET /data/range.txt HTTP/1.0\nRange: bytes=0-312\n\n");
        1: 2538:  ASSERT_STREQ_NZ(buf, "HTTP/1.1 416");
        -: 2539:
        1: 2540:  return NULL;
        -: 2541:}
        -: 2542:
     1141: 2543:static void cb_ws_server(struct mg_connection *nc, int ev, void *ev_data) {
     1141: 2544:  struct websocket_message *wm = (struct websocket_message *) ev_data;
        -: 2545:
     1141: 2546:  if (ev == MG_EV_WEBSOCKET_FRAME || ev == MG_EV_WEBSOCKET_CONTROL_FRAME) {
       18: 2547:    mg_printf_websocket_frame(
        -: 2548:        nc, WEBSOCKET_OP_TEXT, "%s%.2x:{%.*s}",
        6: 2549:        (ev == MG_EV_WEBSOCKET_CONTROL_FRAME ? "CONTROL:" : ""), wm->flags,
        6: 2550:        (int) wm->size, wm->data);
        -: 2551:  }
     1141: 2552:}
        -: 2553:
        -: 2554:static int s_ws_client1_connected = false;
      813: 2555:static void cb_ws_client1(struct mg_connection *nc, int ev, void *ev_data) {
      813: 2556:  struct websocket_message *wm = (struct websocket_message *) ev_data;
        -: 2557:
      821: 2558:  if (ev == MG_EV_WEBSOCKET_FRAME || ev == MG_EV_WEBSOCKET_CONTROL_FRAME) {
        8: 2559:    char *tmp = NULL;
        -: 2560:    int tmplen;
        8: 2561:    tmplen =
       24: 2562:        mg_asprintf(&tmp, 0, "%s%.2x:[%.*s]",
        -: 2563:                    (ev == MG_EV_WEBSOCKET_CONTROL_FRAME ? "CONTROL:" : ""),
       16: 2564:                    wm->flags, (int) wm->size, wm->data);
        8: 2565:    mbuf_append((struct mbuf *) nc->user_data, tmp, tmplen);
        8: 2566:    free(tmp);
      805: 2567:  } else if (ev == MG_EV_CLOSE) {
        6: 2568:    s_ws_client1_connected = 0;
      799: 2569:  } else if (ev == MG_EV_WEBSOCKET_HANDSHAKE_DONE) {
        6: 2570:    s_ws_client1_connected = 1;
        -: 2571:  }
      813: 2572:}
        -: 2573:
        1: 2574:static const char *test_websocket(void) {
        -: 2575:  struct mg_mgr mgr;
        -: 2576:  struct mg_connection *nc;
        1: 2577:  const char *local_addr = "127.0.0.1:7778";
        -: 2578:  struct mbuf mb;
        1: 2579:  mbuf_init(&mb, 100);
        -: 2580:
        1: 2581:  mg_mgr_init(&mgr, NULL);
        -: 2582:  /* mgr.hexdump_file = "-"; */
        1: 2583:  ASSERT((nc = mg_bind(&mgr, local_addr, cb_ws_server)) != NULL);
        1: 2584:  mg_set_protocol_http_websocket(nc);
        -: 2585:
        -: 2586:  /*
        -: 2587:   * Websocket request "hi" via mg_send_websocket_framev()
        -: 2588:   */
        1: 2589:  mb.len = 0;
        1: 2590:  s_ws_client1_connected = 0;
        1: 2591:  ASSERT((nc = mg_connect(&mgr, local_addr, cb_ws_client1)) != NULL);
        1: 2592:  mg_set_protocol_http_websocket(nc);
        1: 2593:  nc->user_data = &mb;
        1: 2594:  mg_send_websocket_handshake(nc, "/ws", NULL);
        1: 2595:  poll_until(&mgr, 1, c_int_ne, &s_ws_client1_connected, (void *) 1);
        -: 2596:  {
        -: 2597:    /* Send "hi" to server. server must reply "A". */
        -: 2598:    struct mg_str h[2];
        1: 2599:    h[0].p = "h";
        1: 2600:    h[0].len = 1;
        1: 2601:    h[1].p = "i";
        1: 2602:    h[1].len = 1;
        1: 2603:    mg_send_websocket_framev(nc, WEBSOCKET_OP_TEXT, h, 2);
        -: 2604:  }
        1: 2605:  poll_until(&mgr, 1, c_int_ne, &mb.len, (void *) 0);
        1: 2606:  mbuf_append(&mb, "\0", 1);
        -: 2607:  /* Check that test buffer has been filled by the callback properly. */
        1: 2608:  ASSERT_STREQ(mb.buf, "81:[81:{hi}]");
        -: 2609:
        -: 2610:  /*
        -: 2611:   * Websocket request "hallloo", composed from two fragments
        -: 2612:   */
        1: 2613:  mb.len = 0;
        1: 2614:  s_ws_client1_connected = 0;
        1: 2615:  ASSERT((nc = mg_connect(&mgr, local_addr, cb_ws_client1)) != NULL);
        1: 2616:  mg_set_protocol_http_websocket(nc);
        1: 2617:  nc->user_data = &mb;
        1: 2618:  mg_send_websocket_handshake(nc, "/ws", NULL);
        1: 2619:  poll_until(&mgr, 1, c_int_ne, &s_ws_client1_connected, (void *) 1);
        1: 2620:  ASSERT_EQ(s_ws_client1_connected, 1);
        -: 2621:
        1: 2622:  mg_send_websocket_frame(nc, WEBSOCKET_OP_TEXT | WEBSOCKET_DONT_FIN, "hall",
        -: 2623:                          4);
        1: 2624:  mg_send_websocket_frame(nc, WEBSOCKET_OP_CONTINUE | WEBSOCKET_DONT_FIN, "--",
        -: 2625:                          2);
        -: 2626:
        -: 2627:  /* Poll 0.5 seconds, we don't expect c_str_ne predicate to return true */
        1: 2628:  poll_until(&mgr, 0.5, c_int_ne, &mb.len, (void *) 0);
        1: 2629:  ASSERT_EQ(mb.len, 0);
        -: 2630:
        1: 2631:  mg_send_websocket_frame(nc, WEBSOCKET_OP_CONTINUE, "loo", 3);
        -: 2632:
        1: 2633:  poll_until(&mgr, 1, c_int_ne, &mb.len, (void *) 0);
        1: 2634:  mbuf_append(&mb, "\0", 1);
        -: 2635:  /* Check that test buffer has been filled by the callback properly. */
        1: 2636:  ASSERT_STREQ(mb.buf, "81:[81:{hall--loo}]");
        -: 2637:
        -: 2638:  /*
        -: 2639:   * Ping request
        -: 2640:   */
        1: 2641:  mb.len = 0;
        1: 2642:  s_ws_client1_connected = 0;
        1: 2643:  ASSERT((nc = mg_connect(&mgr, local_addr, cb_ws_client1)) != NULL);
        1: 2644:  mg_set_protocol_http_websocket(nc);
        1: 2645:  nc->user_data = &mb;
        1: 2646:  mg_send_websocket_handshake(nc, "/ws", NULL);
        1: 2647:  poll_until(&mgr, 1, c_int_ne, &s_ws_client1_connected, (void *) 1);
        1: 2648:  ASSERT_EQ(s_ws_client1_connected, 1);
        -: 2649:
        1: 2650:  mg_send_websocket_frame(nc, WEBSOCKET_OP_PING, "myping", 6);
        -: 2651:
        -: 2652:  {
        -: 2653:    /*
        -: 2654:     * As a response to Ping, we should first receive Pong (0x8a),
        -: 2655:     * and then text message (0x81) with our Ping (0x89) echo.
        -: 2656:     */
        1: 2657:    const char *expected = "CONTROL:8a:[myping]81:[CONTROL:89:{myping}]";
        1: 2658:    poll_until(&mgr, 1, c_int_eq, &mb.len, (void *) strlen(expected));
        1: 2659:    mbuf_append(&mb, "\0", 1);
        1: 2660:    ASSERT_STREQ(mb.buf, expected);
        -: 2661:  }
        -: 2662:
        -: 2663:  /*
        -: 2664:   * Ping request injected in between of a fragmented message
        -: 2665:   */
        1: 2666:  mb.len = 0;
        1: 2667:  s_ws_client1_connected = 0;
        1: 2668:  ASSERT((nc = mg_connect(&mgr, local_addr, cb_ws_client1)) != NULL);
        1: 2669:  mg_set_protocol_http_websocket(nc);
        1: 2670:  nc->user_data = &mb;
        1: 2671:  mg_send_websocket_handshake(nc, "/ws", NULL);
        1: 2672:  poll_until(&mgr, 1, c_int_ne, &s_ws_client1_connected, (void *) 1);
        1: 2673:  ASSERT_EQ(s_ws_client1_connected, 1);
        -: 2674:
        1: 2675:  mg_send_websocket_frame(nc, WEBSOCKET_OP_TEXT | WEBSOCKET_DONT_FIN, "abc", 3);
        1: 2676:  mg_send_websocket_frame(nc, WEBSOCKET_OP_CONTINUE | WEBSOCKET_DONT_FIN, "def",
        -: 2677:                          3);
        -: 2678:
        1: 2679:  mg_send_websocket_frame(nc, WEBSOCKET_OP_PING, "0123", 4);
        -: 2680:
        1: 2681:  mg_send_websocket_frame(nc, WEBSOCKET_OP_CONTINUE, "ghi", 3);
        -: 2682:
        -: 2683:  {
        -: 2684:    /*
        -: 2685:     * As a response to Ping, we should first receive Pong (0x8a),
        -: 2686:     * and then text message (0x81) with our Ping (0x89) echo.
        -: 2687:     * And then, our fragmented text message: abcdefghi.
        -: 2688:     */
        1: 2689:    const char *expected =
        -: 2690:        "CONTROL:8a:[0123]81:[CONTROL:89:{0123}]81:[81:{abcdefghi}]";
        1: 2691:    poll_until(&mgr, 1, c_int_eq, &mb.len, (void *) strlen(expected));
        1: 2692:    mbuf_append(&mb, "\0", 1);
        1: 2693:    ASSERT_STREQ(mb.buf, expected);
        -: 2694:  }
        -: 2695:
        -: 2696:  /*
        -: 2697:   * Test illegal text frame in the middle of a fragmented message
        -: 2698:   */
        1: 2699:  mb.len = 0;
        1: 2700:  s_ws_client1_connected = 0;
        1: 2701:  ASSERT((nc = mg_connect(&mgr, local_addr, cb_ws_client1)) != NULL);
        1: 2702:  mg_set_protocol_http_websocket(nc);
        1: 2703:  nc->user_data = &mb;
        1: 2704:  mg_send_websocket_handshake(nc, "/ws", NULL);
        1: 2705:  poll_until(&mgr, 1, c_int_ne, &s_ws_client1_connected, (void *) 1);
        1: 2706:  ASSERT_EQ(s_ws_client1_connected, 1);
        -: 2707:
        -: 2708:  /* Send a few parts of a fragmented message */
        1: 2709:  mg_send_websocket_frame(nc, WEBSOCKET_OP_TEXT | WEBSOCKET_DONT_FIN, "abc", 3);
        1: 2710:  mg_send_websocket_frame(nc, WEBSOCKET_OP_CONTINUE | WEBSOCKET_DONT_FIN, "def",
        -: 2711:                          3);
        -: 2712:
        -: 2713:  /* Send (illegal) text frame in the middle of a fragmented message */
        1: 2714:  mg_send_websocket_frame(nc, WEBSOCKET_OP_TEXT, "ghi", 3);
        -: 2715:
        -: 2716:  /* Wait until connection is closed by the server */
        1: 2717:  poll_until(&mgr, 1, c_int_ne, &s_ws_client1_connected, (void *) 0);
        1: 2718:  ASSERT_EQ(s_ws_client1_connected, 0);
        -: 2719:
        -: 2720:  /* Verify the error message */
        1: 2721:  mbuf_append(&mb, "\0", 1);
        1: 2722:  ASSERT_STREQ(
        -: 2723:      mb.buf,
        -: 2724:      "CONTROL:88:[non-continuation in the middle of a fragmented message]");
        -: 2725:
        -: 2726:  /*
        -: 2727:   * Test closing by the client
        -: 2728:   */
        1: 2729:  mb.len = 0;
        1: 2730:  s_ws_client1_connected = 0;
        1: 2731:  ASSERT((nc = mg_connect(&mgr, local_addr, cb_ws_client1)) != NULL);
        1: 2732:  mg_set_protocol_http_websocket(nc);
        1: 2733:  nc->user_data = &mb;
        1: 2734:  mg_send_websocket_handshake(nc, "/ws", NULL);
        1: 2735:  poll_until(&mgr, 1, c_int_ne, &s_ws_client1_connected, (void *) 1);
        1: 2736:  ASSERT_EQ(s_ws_client1_connected, 1);
        -: 2737:
        -: 2738:  /* Send a few parts of a fragmented message */
        1: 2739:  mg_send_websocket_frame(nc, WEBSOCKET_OP_CLOSE, "bye", 3);
        -: 2740:
        -: 2741:  /* Wait until connection is closed by the server */
        1: 2742:  poll_until(&mgr, 1, c_int_ne, &s_ws_client1_connected, (void *) 0);
        1: 2743:  ASSERT_EQ(s_ws_client1_connected, 0);
        -: 2744:  /*
        -: 2745:   * TODO(dfrank): mongoose closes the connection automatically when
        -: 2746:   * mg_send_websocket_frame() is called with a WEBSOCKET_OP_CLOSE op, so we
        -: 2747:   * can't hear anything from the server. Server is actually obliged to send
        -: 2748:   * the control frame in response, but we can't test it here.
        -: 2749:   */
        -: 2750:
        1: 2751:  mg_mgr_free(&mgr);
        1: 2752:  mbuf_free(&mb);
        -: 2753:
        1: 2754:  return NULL;
        -: 2755:}
        -: 2756:
      140: 2757:static void cb3(struct mg_connection *nc, int ev, void *ev_data) {
      140: 2758:  struct websocket_message *wm = (struct websocket_message *) ev_data;
      140: 2759:  if (ev != MG_EV_WEBSOCKET_FRAME) return;
        3: 2760:  DBG(("server data '%.*s'", (int) wm->size, wm->data));
        3: 2761:  const char *reply = wm->size == 2 && !memcmp(wm->data, "hi", 2) ? "A" : "B";
        3: 2762:  mg_printf_websocket_frame(nc, WEBSOCKET_OP_TEXT, "%s", reply);
        -: 2763:}
        -: 2764:
       85: 2765:static void cb4(struct mg_connection *nc, int ev, void *ev_data) {
       85: 2766:  char *buf = (char *) nc->user_data;
       85: 2767:  if (ev == MG_EV_WEBSOCKET_FRAME) {
        4: 2768:    struct websocket_message *wm = (struct websocket_message *) ev_data;
        4: 2769:    DBG(("client data '%.*s'", (int) wm->size, wm->data));
        4: 2770:    memcpy(buf, wm->data, wm->size);
        4: 2771:    mg_send_websocket_frame(nc, WEBSOCKET_OP_CLOSE, NULL, 0);
       81: 2772:  } else if (ev == MG_EV_WEBSOCKET_HANDSHAKE_DONE) {
        5: 2773:    struct http_message *hm = (struct http_message *) ev_data;
        5: 2774:    DBG(("code %d", hm->resp_code));
        5: 2775:    if (hm->resp_code == 101) {
        -: 2776:      /* Send "hi" to server. server must reply "A". */
        -: 2777:      struct mg_str h[2];
        4: 2778:      h[0].p = "h";
        4: 2779:      h[0].len = 1;
        4: 2780:      h[1].p = "i";
        4: 2781:      h[1].len = 1;
        4: 2782:      mg_send_websocket_framev(nc, WEBSOCKET_OP_TEXT, h, 2);
        -: 2783:    } else {
        1: 2784:      snprintf(buf, 20, "code %d", hm->resp_code);
        -: 2785:    }
        -: 2786:  }
       85: 2787:}
        -: 2788:
       24: 2789:static void cbwep(struct mg_connection *c, int ev, void *ev_data) {
       24: 2790:  struct websocket_message *wm = (struct websocket_message *) ev_data;
       24: 2791:  char *buf = (char *) c->user_data;
        -: 2792:
       24: 2793:  switch (ev) {
        2: 2794:    case MG_EV_WEBSOCKET_HANDSHAKE_REQUEST:
        2: 2795:      strcat(buf, "R");
        2: 2796:      if (buf[0] != '0') {
        1: 2797:        mg_http_send_error(c, 403, "I don't like you");
        -: 2798:      }
        2: 2799:      break;
        1: 2800:    case MG_EV_WEBSOCKET_HANDSHAKE_DONE:
        1: 2801:      strcat(buf, "D");
        1: 2802:      break;
        1: 2803:    case MG_EV_WEBSOCKET_FRAME:
        1: 2804:      strcat(buf, "F");
        2: 2805:      mg_printf_websocket_frame(c, WEBSOCKET_OP_TEXT, "%s|%.*s", buf,
        1: 2806:                                (int) wm->size, wm->data);
        1: 2807:      break;
        -: 2808:  }
       24: 2809:}
        -: 2810:
        1: 2811:static const char *test_websocket_endpoint(void) {
        -: 2812:  struct mg_mgr mgr;
        -: 2813:  struct mg_connection *nc;
        1: 2814:  const char *local_addr = "127.0.0.1:7798";
        1: 2815:  char buf[20] = "", buf2[20] = "0";
        -: 2816:
        1: 2817:  mg_mgr_init(&mgr, NULL);
        -: 2818:  /* mgr.hexdump_file = "-"; */
        1: 2819:  ASSERT((nc = mg_bind(&mgr, local_addr, cb3)) != NULL);
        1: 2820:  mg_set_protocol_http_websocket(nc);
        1: 2821:  nc->user_data = buf2;
        1: 2822:  mg_register_http_endpoint(nc, "/boo", cbwep MG_UD_ARG(NULL));
        -: 2823:
        -: 2824:  /* Websocket request */
        1: 2825:  ASSERT((nc = mg_connect(&mgr, local_addr, cb4)) != NULL);
        1: 2826:  mg_set_protocol_http_websocket(nc);
        1: 2827:  nc->user_data = buf;
        1: 2828:  mg_send_websocket_handshake(nc, "/boo", NULL);
        1: 2829:  poll_until(&mgr, 1, c_str_ne, buf, (void *) "");
        -: 2830:  /* Check that test buffer has been filled by the callback properly. */
        1: 2831:  ASSERT_STREQ(buf, "0RDF|hi");
        -: 2832:
        -: 2833:  /* Test handshake failure */
        1: 2834:  ASSERT((nc = mg_connect(&mgr, local_addr, cb4)) != NULL);
        1: 2835:  mg_set_protocol_http_websocket(nc);
        1: 2836:  buf[0] = '\0';
        1: 2837:  buf2[0] = '1';
        1: 2838:  buf2[1] = '\0';
        1: 2839:  nc->user_data = buf;
        1: 2840:  mg_send_websocket_handshake(nc, "/boo", NULL);
        1: 2841:  poll_until(&mgr, 1, c_str_ne, buf, (void *) "");
        1: 2842:  ASSERT_STREQ(buf, "code 403");
        -: 2843:
        1: 2844:  mg_mgr_free(&mgr);
        -: 2845:
        1: 2846:  return NULL;
        -: 2847:}
        -: 2848:
        1: 2849:static const char *test_connect_ws(void) {
        -: 2850:  struct mg_mgr mgr;
        -: 2851:  struct mg_connection *nc;
        1: 2852:  const char *urls[] = {"ws://127.0.0.1:7778/ws", "http://127.0.0.1:7778/ws",
        -: 2853:                        "127.0.0.1:7778/ws", NULL};
        -: 2854:  const char **url;
        -: 2855:
        1: 2856:  mg_mgr_init(&mgr, NULL);
        -: 2857:  /* mgr.hexdump_file = "-"; */
        1: 2858:  ASSERT((nc = mg_bind(&mgr, "127.0.0.1:7778", cb3)) != NULL);
        1: 2859:  mg_set_protocol_http_websocket(nc);
        -: 2860:
        8: 2861:  for (url = urls; *url != NULL; url++) {
        3: 2862:    char buf[20] = "";
        3: 2863:    ASSERT((nc = mg_connect_ws(&mgr, cb4, "ws://127.0.0.1:7778/ws", NULL,
        -: 2864:                               NULL)) != NULL);
        3: 2865:    nc->user_data = buf;
        3: 2866:    poll_until(&mgr, 1, c_str_ne, buf, (void *) "");
        3: 2867:    ASSERT_STREQ(buf, "A");
        -: 2868:  }
        -: 2869:
        1: 2870:  mg_mgr_free(&mgr);
        -: 2871:
        1: 2872:  return NULL;
        -: 2873:}
        -: 2874:
        -: 2875:struct big_payload_params {
        -: 2876:  size_t size;
        -: 2877:  char *buf;
        -: 2878:};
        -: 2879:
      301: 2880:static void cb3_big(struct mg_connection *nc, int ev, void *ev_data) {
      301: 2881:  struct websocket_message *wm = (struct websocket_message *) ev_data;
        -: 2882:
      301: 2883:  if (ev == MG_EV_WEBSOCKET_FRAME) {
        2: 2884:    int success = 1;
        -: 2885:    size_t i;
    73729: 2886:    for (i = 0; i < wm->size; i++) {
    73727: 2887:      if (wm->data[i] != 'x') {
    #####: 2888:        success = 0;
    #####: 2889:        break;
        -: 2890:      }
        -: 2891:    }
        2: 2892:    mg_printf_websocket_frame(nc, WEBSOCKET_OP_TEXT, "%s",
        -: 2893:                              success ? "success" : "fail");
        -: 2894:  }
      301: 2895:}
        -: 2896:
      176: 2897:static void cb4_big(struct mg_connection *nc, int ev, void *ev_data) {
      176: 2898:  struct websocket_message *wm = (struct websocket_message *) ev_data;
      176: 2899:  struct big_payload_params *params =
        -: 2900:      (struct big_payload_params *) nc->user_data;
        -: 2901:
      176: 2902:  if (ev == MG_EV_WEBSOCKET_FRAME) {
        2: 2903:    memcpy(params->buf, wm->data, wm->size);
        2: 2904:    mg_send_websocket_frame(nc, WEBSOCKET_OP_CLOSE, NULL, 0);
      174: 2905:  } else if (ev == MG_EV_WEBSOCKET_HANDSHAKE_DONE) {
        -: 2906:    /* Send large payload to server. server must reply "success". */
        2: 2907:    char *payload = (char *) malloc(params->size);
        2: 2908:    memset(payload, 'x', params->size);
        2: 2909:    mg_printf_websocket_frame(nc, WEBSOCKET_OP_TEXT, "%.*s", params->size,
        -: 2910:                              payload);
        2: 2911:    free(payload);
        -: 2912:  }
      176: 2913:}
        -: 2914:
        -: 2915:/* Big payloads follow a different code path because it will use the extended
        -: 2916: * length field and possibly mg_avprintf will need to reallocate the buffer. */
        1: 2917:static const char *test_websocket_big(void) {
        -: 2918:  struct mg_mgr mgr;
        -: 2919:  struct mg_connection *nc;
        1: 2920:  const char *local_addr = "127.0.0.1:7778";
        1: 2921:  char buf[20] = "";
        -: 2922:  struct big_payload_params params;
        1: 2923:  params.buf = buf;
        -: 2924:
        1: 2925:  mg_mgr_init(&mgr, NULL);
        -: 2926:  /* mgr.hexdump_file = "-"; */
        1: 2927:  ASSERT((nc = mg_bind(&mgr, local_addr, cb3_big)) != NULL);
        1: 2928:  mg_set_protocol_http_websocket(nc);
        -: 2929:
        -: 2930:  /* Websocket request */
        1: 2931:  ASSERT((nc = mg_connect(&mgr, local_addr, cb4_big)) != NULL);
        1: 2932:  mg_set_protocol_http_websocket(nc);
        1: 2933:  params.size = 8192;
        1: 2934:  nc->user_data = &params;
        1: 2935:  params.buf[0] = '\0';
        1: 2936:  mg_send_websocket_handshake(nc, "/ws", NULL);
        1: 2937:  poll_until(&mgr, 1, c_str_ne, params.buf, (void *) "");
        -: 2938:
        -: 2939:  /* Check that test buffer has been filled by the callback properly. */
        1: 2940:  ASSERT_STREQ(buf, "success");
        -: 2941:
        -: 2942:  /* Websocket request */
        1: 2943:  ASSERT((nc = mg_connect(&mgr, local_addr, cb4_big)) != NULL);
        1: 2944:  mg_set_protocol_http_websocket(nc);
        1: 2945:  params.size = 65535;
        1: 2946:  nc->user_data = &params;
        1: 2947:  params.buf[0] = '\0';
        1: 2948:  mg_send_websocket_handshake(nc, "/ws", NULL);
        1: 2949:  poll_until(&mgr, 1, c_str_ne, params.buf, (void *) "");
        1: 2950:  mg_mgr_free(&mgr);
        -: 2951:
        -: 2952:  /* Check that test buffer has been filled by the callback properly. */
        1: 2953:  ASSERT_STREQ(buf, "success");
        -: 2954:
        1: 2955:  return NULL;
        -: 2956:}
        -: 2957:
        1: 2958:static const char *test_mqtt_handshake(void) {
        -: 2959:  struct mg_send_mqtt_handshake_opts opts;
        1: 2960:  struct mg_connection *nc = create_test_connection();
        1: 2961:  const char *client_id = "testclient";
        1: 2962:  const char *user_name = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
        1: 2963:  const char *password = "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB";
        1: 2964:  const char *will_topic = "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC";
        1: 2965:  const char *will_message = "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD";
        1: 2966:  double before = mg_time();
        -: 2967:  const char *got;
        -: 2968:
        1: 2969:  msleep(2);
        1: 2970:  mg_set_protocol_mqtt(nc);
        1: 2971:  mg_send_mqtt_handshake(nc, client_id);
        1: 2972:  got = nc->send_mbuf.buf;
        -: 2973:  /* handshake header + keepalive + client id len + client id */
        1: 2974:  ASSERT_EQ(nc->send_mbuf.len,
        -: 2975:            1 + 1 + 1 + 5 + 1 + 1 + 2 + 2 + strlen(client_id));
        1: 2976:  ASSERT_EQ(got[0], 0x10);
        1: 2977:  ASSERT_EQ(got[1], (int) nc->send_mbuf.len - 2);
        1: 2978:  ASSERT_EQ(got[2], 0);
        1: 2979:  ASSERT_EQ(got[3], 4);
        1: 2980:  ASSERT_STREQ_NZ(&got[4], "MQTT");
        1: 2981:  ASSERT_EQ(got[8], 4);
        1: 2982:  ASSERT_EQ(got[9], 0); /* connect flags */
        1: 2983:  ASSERT_EQ(got[10], 0);
        1: 2984:  ASSERT_EQ(got[11], 60);
        1: 2985:  ASSERT_EQ(got[12], 0);
        1: 2986:  ASSERT_EQ(got[13], (char) strlen(client_id));
        1: 2987:  ASSERT_EQ(strncmp(&got[14], client_id, strlen(client_id)), 0);
        1: 2988:  ASSERT_EQ(((struct mg_mqtt_proto_data *) nc->proto_data)->keep_alive, 60);
        1: 2989:  ASSERT_GT(((struct mg_mqtt_proto_data *) nc->proto_data)->last_control_time,
        -: 2990:            before);
        1: 2991:  mbuf_remove(&nc->send_mbuf, nc->send_mbuf.len);
        -: 2992:
        1: 2993:  memset(&opts, 0, sizeof(opts));
        1: 2994:  before = mg_time();
        1: 2995:  msleep(2);
        1: 2996:  opts.will_topic = will_topic;
        1: 2997:  opts.will_message = will_message;
        1: 2998:  opts.user_name = user_name;
        1: 2999:  opts.password = password;
        1: 3000:  opts.keep_alive = 0x1234;
        1: 3001:  mg_send_mqtt_handshake_opt(nc, client_id, opts);
        1: 3002:  got = nc->send_mbuf.buf;
        -: 3003:  /* handshake header + keepalive + client id len + client id */
        1: 3004:  ASSERT_EQ(nc->send_mbuf.len, 1 + 2 + 1 + 5 + 1 + 1 + 2 + 2 +
        -: 3005:                                   strlen(client_id) + 2 + strlen(will_topic) +
        -: 3006:                                   2 + strlen(will_message) + 2 +
        -: 3007:                                   strlen(user_name) + 2 + strlen(password));
        1: 3008:  ASSERT_EQ(got[0], 0x10);
        1: 3009:  ASSERT_EQ(((unsigned char *) got)[1], 223);
        1: 3010:  ASSERT_EQ(got[2], 1);
        1: 3011:  ASSERT_EQ(got[3], 0);
        1: 3012:  ASSERT_EQ(got[4], 4);
        1: 3013:  ASSERT_STREQ_NZ(&got[5], "MQTT");
        1: 3014:  ASSERT_EQ(got[9], 4);
        1: 3015:  ASSERT_EQ(((unsigned char *) got)[10], 0xc4); /* connect flags */
        1: 3016:  ASSERT_EQ(got[11], 0x12);
        1: 3017:  ASSERT_EQ(got[12], 0x34);
        1: 3018:  ASSERT_EQ(got[13], 0);
        1: 3019:  ASSERT_EQ(got[14], (char) strlen(client_id));
        1: 3020:  ASSERT_EQ(strncmp(&got[15], client_id, strlen(client_id)), 0);
        1: 3021:  ASSERT_EQ(((struct mg_mqtt_proto_data *) nc->proto_data)->keep_alive, 0x1234);
        1: 3022:  ASSERT_GT(((struct mg_mqtt_proto_data *) nc->proto_data)->last_control_time,
        -: 3023:            before);
        1: 3024:  mbuf_remove(&nc->send_mbuf, nc->send_mbuf.len);
        -: 3025:
        1: 3026:  destroy_test_connection(nc);
        1: 3027:  return NULL;
        -: 3028:}
        -: 3029:
        1: 3030:static const char *test_mqtt_publish(void) {
        1: 3031:  struct mg_connection *nc = create_test_connection();
        1: 3032:  const double before = mg_time();
        1: 3033:  char data[] = "dummy";
        -: 3034:  const char *got;
        -: 3035:
        1: 3036:  mg_set_protocol_mqtt(nc);
        1: 3037:  msleep(2);
        1: 3038:  mg_mqtt_publish(nc, "/test", 42, MG_MQTT_QOS(1) | MG_MQTT_RETAIN, data,
        -: 3039:                  sizeof(data));
        1: 3040:  got = nc->send_mbuf.buf;
        1: 3041:  ASSERT_EQ(nc->send_mbuf.len, 17);
        -: 3042:
        1: 3043:  ASSERT(got[0] & MG_MQTT_RETAIN);
        1: 3044:  ASSERT_EQ((got[0] & 0xf0), (MG_MQTT_CMD_PUBLISH << 4));
        1: 3045:  ASSERT_EQ(MG_MQTT_GET_QOS(got[0]), 1);
        1: 3046:  ASSERT_EQ((size_t) got[1], (nc->send_mbuf.len - 2));
        -: 3047:
        1: 3048:  ASSERT_EQ(got[2], 0);
        1: 3049:  ASSERT_EQ(got[3], 5);
        1: 3050:  ASSERT_STREQ_NZ(&got[4], "/test");
        -: 3051:
        1: 3052:  ASSERT_EQ(got[9], 0);
        1: 3053:  ASSERT_EQ(got[10], 42);
        -: 3054:
        1: 3055:  ASSERT_EQ(strncmp(&got[11], data, sizeof(data)), 0);
        -: 3056:
        1: 3057:  ASSERT_GT(((struct mg_mqtt_proto_data *) nc->proto_data)->last_control_time,
        -: 3058:            before);
        -: 3059:
        1: 3060:  destroy_test_connection(nc);
        1: 3061:  return NULL;
        -: 3062:}
        -: 3063:
        1: 3064:static const char *test_mqtt_subscribe(void) {
        1: 3065:  struct mg_connection *nc = create_test_connection();
        1: 3066:  const double before = mg_time();
        1: 3067:  const int qos = 1;
        -: 3068:  const char *got;
        1: 3069:  struct mg_mqtt_topic_expression topic_expressions[] = {{"/stuff", qos}};
        1: 3070:  mg_set_protocol_mqtt(nc);
        1: 3071:  msleep(2);
        -: 3072:
        1: 3073:  mg_mqtt_subscribe(nc, topic_expressions, 1, 42);
        1: 3074:  got = nc->send_mbuf.buf;
        1: 3075:  ASSERT_EQ(nc->send_mbuf.len, 13);
        1: 3076:  ASSERT_EQ((got[0] & 0xf0), (MG_MQTT_CMD_SUBSCRIBE << 4));
        1: 3077:  ASSERT_EQ((size_t) got[1], (nc->send_mbuf.len - 2));
        1: 3078:  ASSERT_EQ(got[2], 0);
        1: 3079:  ASSERT_EQ(got[3], 42);
        -: 3080:
        1: 3081:  ASSERT_EQ(got[4], 0);
        1: 3082:  ASSERT_EQ(got[5], 6);
        1: 3083:  ASSERT_STREQ_NZ(&got[6], "/stuff");
        1: 3084:  ASSERT_EQ(got[12], qos);
        -: 3085:
        1: 3086:  ASSERT_GT(((struct mg_mqtt_proto_data *) nc->proto_data)->last_control_time,
        -: 3087:            before);
        -: 3088:
        1: 3089:  destroy_test_connection(nc);
        1: 3090:  return NULL;
        -: 3091:}
        -: 3092:
        1: 3093:static const char *test_mqtt_unsubscribe(void) {
        1: 3094:  struct mg_connection *nc = create_test_connection();
        1: 3095:  char *topics[] = {(char *) "/stuff"};
        1: 3096:  const double before = mg_time();
        -: 3097:  const char *got;
        1: 3098:  mg_set_protocol_mqtt(nc);
        1: 3099:  msleep(2);
        -: 3100:
        1: 3101:  mg_mqtt_unsubscribe(nc, topics, 1, 42);
        1: 3102:  got = nc->send_mbuf.buf;
        1: 3103:  ASSERT_EQ(nc->send_mbuf.len, 12);
        1: 3104:  ASSERT_EQ((got[0] & 0xf0), (MG_MQTT_CMD_UNSUBSCRIBE << 4));
        1: 3105:  ASSERT_EQ((size_t) got[1], (nc->send_mbuf.len - 2));
        1: 3106:  ASSERT_EQ(got[2], 0);
        1: 3107:  ASSERT_EQ(got[3], 42);
        -: 3108:
        1: 3109:  ASSERT_EQ(got[4], 0);
        1: 3110:  ASSERT_EQ(got[5], 6);
        1: 3111:  ASSERT_STREQ_NZ(&got[6], "/stuff");
        -: 3112:
        1: 3113:  ASSERT_GT(((struct mg_mqtt_proto_data *) nc->proto_data)->last_control_time,
        -: 3114:            before);
        -: 3115:
        1: 3116:  destroy_test_connection(nc);
        1: 3117:  return NULL;
        -: 3118:}
        -: 3119:
        1: 3120:static const char *test_mqtt_connack(void) {
        1: 3121:  struct mg_connection *nc = create_test_connection();
        -: 3122:  const char *got;
        1: 3123:  mg_set_protocol_mqtt(nc);
        -: 3124:
        1: 3125:  mg_mqtt_connack(nc, 42);
        1: 3126:  got = nc->send_mbuf.buf;
        1: 3127:  ASSERT(nc->send_mbuf.len > 0);
        1: 3128:  ASSERT_EQ((got[0] & 0xf0), (MG_MQTT_CMD_CONNACK << 4));
        1: 3129:  ASSERT_EQ((size_t) got[1], (nc->send_mbuf.len - 2));
        1: 3130:  ASSERT_EQ(got[3], 42);
        -: 3131:
        1: 3132:  destroy_test_connection(nc);
        1: 3133:  return NULL;
        -: 3134:}
        -: 3135:
        1: 3136:static const char *test_mqtt_suback(void) {
        1: 3137:  struct mg_connection *nc = create_test_connection();
        1: 3138:  uint8_t qoss[] = {1};
        -: 3139:  const char *got;
        1: 3140:  mg_set_protocol_mqtt(nc);
        -: 3141:
        1: 3142:  mg_mqtt_suback(nc, qoss, 1, 42);
        -: 3143:
        1: 3144:  got = nc->send_mbuf.buf;
        1: 3145:  ASSERT_EQ(nc->send_mbuf.len, 5);
        1: 3146:  ASSERT_EQ((got[0] & 0xf0), (MG_MQTT_CMD_SUBACK << 4));
        1: 3147:  ASSERT_EQ(MG_MQTT_GET_QOS(got[0]), 1);
        1: 3148:  ASSERT_EQ((size_t) got[1], (nc->send_mbuf.len - 2));
        1: 3149:  ASSERT_EQ(got[2], 0);
        1: 3150:  ASSERT_EQ(got[3], 42);
        1: 3151:  ASSERT_EQ(got[4], 1);
        -: 3152:
        1: 3153:  destroy_test_connection(nc);
        1: 3154:  return NULL;
        -: 3155:}
        -: 3156:
        1: 3157:static const char *test_mqtt_simple_acks(void) {
        -: 3158:  unsigned long i;
        -: 3159:  struct {
        -: 3160:    uint8_t cmd;
        -: 3161:    void (*f)(struct mg_connection *, uint16_t);
        1: 3162:  } cases[] = {
        -: 3163:      {MG_MQTT_CMD_PUBACK, mg_mqtt_puback},
        -: 3164:      {MG_MQTT_CMD_PUBREC, mg_mqtt_pubrec},
        -: 3165:      {MG_MQTT_CMD_PUBREL, mg_mqtt_pubrel},
        -: 3166:      {MG_MQTT_CMD_PUBCOMP, mg_mqtt_pubcomp},
        -: 3167:      {MG_MQTT_CMD_UNSUBACK, mg_mqtt_unsuback},
        -: 3168:  };
        -: 3169:
        6: 3170:  for (i = 0; i < ARRAY_SIZE(cases); i++) {
        5: 3171:    struct mg_connection *nc = create_test_connection();
        5: 3172:    const double before = mg_time();
        -: 3173:    const char *got;
        5: 3174:    mg_set_protocol_mqtt(nc);
        5: 3175:    msleep(2);
        -: 3176:
        5: 3177:    cases[i].f(nc, 42);
        -: 3178:
        5: 3179:    got = nc->send_mbuf.buf;
        5: 3180:    ASSERT_EQ(nc->send_mbuf.len, 4);
        5: 3181:    ASSERT_EQ((got[0] & 0xf0), (cases[i].cmd << 4));
        5: 3182:    if (cases[i].cmd == MG_MQTT_CMD_PUBREL) {
        1: 3183:      ASSERT_EQ(got[0] & 0xf, 2);
        -: 3184:    } else {
        4: 3185:      ASSERT_EQ(got[0] & 0xf, 0);
        -: 3186:    }
        5: 3187:    ASSERT_EQ((size_t) got[1], (nc->send_mbuf.len - 2));
        5: 3188:    ASSERT_EQ(got[2], 0);
        5: 3189:    ASSERT_EQ(got[3], 42);
        5: 3190:    ASSERT_GT(((struct mg_mqtt_proto_data *) nc->proto_data)->last_control_time,
        -: 3191:              before);
        -: 3192:
        5: 3193:    destroy_test_connection(nc);
        -: 3194:  }
        1: 3195:  return NULL;
        -: 3196:}
        -: 3197:
        1: 3198:static const char *test_mqtt_nullary(void) {
        -: 3199:  unsigned long i;
        -: 3200:  struct {
        -: 3201:    uint8_t cmd;
        -: 3202:    void (*f)(struct mg_connection *);
        1: 3203:  } cases[] = {
        -: 3204:      {MG_MQTT_CMD_PINGREQ, mg_mqtt_ping},
        -: 3205:      {MG_MQTT_CMD_PINGRESP, mg_mqtt_pong},
        -: 3206:      {MG_MQTT_CMD_DISCONNECT, mg_mqtt_disconnect},
        -: 3207:  };
        -: 3208:
        8: 3209:  for (i = 0; i < ARRAY_SIZE(cases); i++) {
        3: 3210:    struct mg_connection *nc = create_test_connection();
        3: 3211:    const double before = mg_time();
        -: 3212:    struct mg_mqtt_message msg;
        -: 3213:    const char *got;
        3: 3214:    mg_set_protocol_mqtt(nc);
        3: 3215:    msleep(2);
        -: 3216:
        3: 3217:    cases[i].f(nc);
        -: 3218:
        3: 3219:    got = nc->send_mbuf.buf;
        3: 3220:    ASSERT_EQ(nc->send_mbuf.len, 2);
        3: 3221:    ASSERT_EQ((got[0] & 0xf0), (cases[i].cmd << 4));
        3: 3222:    ASSERT_EQ((size_t) got[1], (nc->send_mbuf.len - 2));
        3: 3223:    ASSERT_EQ(parse_mqtt(&nc->send_mbuf, &msg), (int) nc->send_mbuf.len);
        3: 3224:    ASSERT_GT(((struct mg_mqtt_proto_data *) nc->proto_data)->last_control_time,
        -: 3225:              before);
        -: 3226:
        3: 3227:    destroy_test_connection(nc);
        -: 3228:  }
        1: 3229:  return NULL;
        -: 3230:}
        -: 3231:
        -: 3232:static const size_t mqtt_long_payload_len = 200;
        -: 3233:static const size_t mqtt_very_long_payload_len = 20000;
        -: 3234:
      222: 3235:static void mqtt_eh(struct mg_connection *nc, int ev, void *ev_data) {
      222: 3236:  int *check = (int *) nc->user_data;
      222: 3237:  struct mg_mqtt_message *mm = (struct mg_mqtt_message *) ev_data;
        -: 3238:  size_t i;
        -: 3239:  (void) nc;
        -: 3240:  (void) ev_data;
        -: 3241:
      222: 3242:  switch (ev) {
        1: 3243:    case MG_EV_MQTT_SUBACK:
        1: 3244:      *check = 1;
        1: 3245:      break;
        3: 3246:    case MG_EV_MQTT_PUBLISH:
        3: 3247:      *check = 0;
        3: 3248:      if (mg_vcmp(&mm->topic, "/topic")) {
    #####: 3249:        *check = -1;
    #####: 3250:        break;
        -: 3251:      }
        -: 3252:
        3: 3253:      for (i = 0; i < mm->payload.len; i++) {
        3: 3254:        if (nc->recv_mbuf.buf[10 + i] != 'A') {
        3: 3255:          *check = -1;
        3: 3256:          break;
        -: 3257:        }
        -: 3258:      }
        -: 3259:
        3: 3260:      if (mm->payload.len == mqtt_long_payload_len) {
        1: 3261:        *check = 2;
        2: 3262:      } else if (mm->payload.len == mqtt_very_long_payload_len) {
        2: 3263:        *check = 3;
        -: 3264:      }
        3: 3265:      break;
        1: 3266:    case MG_EV_MQTT_CONNACK:
        1: 3267:      *check = 4;
        1: 3268:      break;
        -: 3269:  }
      222: 3270:}
        -: 3271:
        1: 3272:static const char *test_mqtt_parse_mqtt(void) {
        1: 3273:  struct mg_connection *nc = create_test_connection();
        1: 3274:  char msg[] = {(char) (MG_MQTT_CMD_SUBACK << 4), 2, 1, 1};
        -: 3275:  char *long_msg;
        1: 3276:  int check = 0;
        1: 3277:  int num_bytes = sizeof(msg), rest_len, i;
        -: 3278:
        1: 3279:  nc->user_data = &check;
        1: 3280:  nc->handler = mqtt_eh;
        1: 3281:  mg_set_protocol_mqtt(nc);
        -: 3282:
        1: 3283:  mbuf_append(&nc->recv_mbuf, msg, num_bytes);
        1: 3284:  nc->proto_handler(nc, MG_EV_RECV, &num_bytes);
        -: 3285:
        1: 3286:  ASSERT_EQ(check, 1);
        1: 3287:  mbuf_free(&nc->recv_mbuf);
        -: 3288:
        -: 3289:  /* test a payload whose length encodes as two bytes */
        1: 3290:  rest_len = 2 + 6 + mqtt_long_payload_len;
        1: 3291:  long_msg = (char *) malloc(512);
        1: 3292:  long_msg[0] = (char) (MG_MQTT_CMD_PUBLISH << 4);
        1: 3293:  long_msg[1] = (rest_len & 0x7f) | 0x80;
        1: 3294:  long_msg[2] = rest_len >> 7;
        1: 3295:  memcpy(&long_msg[3], "\0\006/topic", 8);
        1: 3296:  memset(&long_msg[11], 'A', mqtt_long_payload_len);
        -: 3297:
        1: 3298:  num_bytes = 3 + rest_len;
        1: 3299:  mbuf_append(&nc->recv_mbuf, long_msg, num_bytes);
        -: 3300:
        -: 3301:  /* Short read: handler is not run and data is not consumed */
      212: 3302:  for (i = 0; i < num_bytes; i++) {
      211: 3303:    check = 123;
      211: 3304:    nc->recv_mbuf.len = i;
      211: 3305:    nc->proto_handler(nc, MG_EV_RECV, &i);
      211: 3306:    ASSERT_EQ((int) nc->recv_mbuf.len, i);
      211: 3307:    ASSERT_EQ(check, 123);
        -: 3308:  }
        -: 3309:
        1: 3310:  nc->recv_mbuf.len = num_bytes;
        1: 3311:  nc->proto_handler(nc, MG_EV_RECV, &num_bytes);
        1: 3312:  ASSERT_EQ(check, 2);
        1: 3313:  mbuf_free(&nc->recv_mbuf);
        1: 3314:  free(long_msg);
        -: 3315:
        -: 3316:  /* test a payload whose length encodes as two bytes */
        1: 3317:  rest_len = 8 + mqtt_very_long_payload_len;
        1: 3318:  long_msg = (char *) malloc(20100);
        1: 3319:  long_msg[0] = (char) (MG_MQTT_CMD_PUBLISH << 4);
        1: 3320:  long_msg[1] = (rest_len & 127) | 0x80;
        1: 3321:  long_msg[2] = ((rest_len >> 7) & 127) | 0x80;
        1: 3322:  long_msg[3] = (rest_len >> 14);
        1: 3323:  memcpy(&long_msg[4], "\0\006/topic", 8);
        1: 3324:  memset(&long_msg[12], 'A', mqtt_very_long_payload_len);
        -: 3325:
        1: 3326:  num_bytes = 4 + rest_len;
        1: 3327:  mbuf_append(&nc->recv_mbuf, long_msg, num_bytes);
        1: 3328:  nc->proto_handler(nc, MG_EV_RECV, &num_bytes);
        -: 3329:
        1: 3330:  ASSERT_EQ(check, 3);
        1: 3331:  mbuf_remove(&nc->recv_mbuf, nc->recv_mbuf.len);
        -: 3332:
        -: 3333:  /* Message length encodings > 4 bytes are not allowed by the standard,
        -: 3334:   * connections should be closed immediately. */
        1: 3335:  long_msg[0] = (char) (MG_MQTT_CMD_PUBLISH << 4);
        1: 3336:  long_msg[1] = 0xff;
        1: 3337:  long_msg[2] = 0xff;
        1: 3338:  long_msg[3] = 0xff;
        1: 3339:  long_msg[4] = 0xff;
        1: 3340:  long_msg[5] = 0xff;
        1: 3341:  mbuf_append(&nc->recv_mbuf, long_msg, 10);
        1: 3342:  nc->proto_handler(nc, MG_EV_RECV, &num_bytes);
        1: 3343:  ASSERT(nc->flags & MG_F_CLOSE_IMMEDIATELY);
        -: 3344:
        1: 3345:  mbuf_free(&nc->recv_mbuf);
        1: 3346:  free(long_msg);
        -: 3347:
        -: 3348:  /* test encoding a large payload */
        1: 3349:  long_msg = (char *) malloc(mqtt_very_long_payload_len);
        1: 3350:  memset(long_msg, 'A', mqtt_very_long_payload_len);
        1: 3351:  mg_mqtt_publish(nc, "/topic", 0, 0, long_msg, mqtt_very_long_payload_len);
        1: 3352:  nc->recv_mbuf = nc->send_mbuf;
        1: 3353:  mbuf_init(&nc->send_mbuf, 0);
        1: 3354:  num_bytes = nc->recv_mbuf.len;
        1: 3355:  nc->proto_handler(nc, MG_EV_RECV, &num_bytes);
        -: 3356:
        1: 3357:  ASSERT_EQ(check, 3);
        1: 3358:  mbuf_free(&nc->recv_mbuf);
        1: 3359:  free(long_msg);
        -: 3360:
        -: 3361:  /* test connack parsing */
        1: 3362:  mg_mqtt_connack(nc, 0);
        1: 3363:  nc->recv_mbuf = nc->send_mbuf;
        1: 3364:  mbuf_init(&nc->send_mbuf, 0);
        1: 3365:  num_bytes = 4;
        1: 3366:  nc->proto_handler(nc, MG_EV_RECV, &num_bytes);
        -: 3367:
        1: 3368:  ASSERT_EQ(check, 4);
        1: 3369:  mbuf_free(&nc->recv_mbuf);
        -: 3370:
        1: 3371:  destroy_test_connection(nc);
        1: 3372:  return NULL;
        -: 3373:}
        -: 3374:
        1: 3375:static const char *test_mqtt_parse_mqtt_qos1(void) {
        -: 3376:  /* clang-format off */
        -: 3377:  struct mg_mqtt_message mm;
        1: 3378:  char msg_qos1[] = {
        -: 3379:      ((MG_MQTT_CMD_PUBLISH << 4) | (1 << 1)),
        -: 3380:      2 + 6 + 2 + 7,
        -: 3381:      0, 6, '/', 't', 'o', 'p', 'i', 'c',
        -: 3382:      0x12, 0x34,
        -: 3383:      'p', 'a', 'y', 'l', 'o', 'a', 'd',
        -: 3384:  };
        -: 3385:  /* clang-format on */
        -: 3386:  struct mbuf mb;
        1: 3387:  memset(&mm, 0, sizeof(mm));
        1: 3388:  mbuf_init(&mb, 0);
        1: 3389:  mbuf_append(&mb, msg_qos1, sizeof(msg_qos1));
        1: 3390:  ASSERT_EQ(parse_mqtt(&mb, &mm), (int) sizeof(msg_qos1));
        1: 3391:  ASSERT_EQ(mm.cmd, MG_MQTT_CMD_PUBLISH);
        1: 3392:  ASSERT_EQ(mm.qos, 1);
        1: 3393:  ASSERT_EQ(mm.message_id, 0x1234);
        1: 3394:  ASSERT_EQ(mm.topic.len, 6);
        1: 3395:  ASSERT_STREQ_NZ(mm.topic.p, "/topic");
        1: 3396:  ASSERT_EQ(mm.payload.len, 7);
        1: 3397:  ASSERT_STREQ_NZ(mm.payload.p, "payload");
        1: 3398:  mbuf_free(&mb);
        1: 3399:  return NULL;
        -: 3400:}
        -: 3401:
        1: 3402:static const char *test_mqtt_match_topic_expression(void) {
        1: 3403:  ASSERT(mg_mqtt_vmatch_topic_expression("foo", mg_mk_str("foo")));
        1: 3404:  ASSERT(mg_mqtt_vmatch_topic_expression("/foo", mg_mk_str("/foo")));
        1: 3405:  ASSERT(mg_mqtt_vmatch_topic_expression("+/foo", mg_mk_str("/foo")));
        1: 3406:  ASSERT(!mg_mqtt_vmatch_topic_expression("foo", mg_mk_str("foobar")));
        1: 3407:  ASSERT(mg_mqtt_vmatch_topic_expression("foo", mg_mk_str("foo/")));
        1: 3408:  ASSERT(mg_mqtt_vmatch_topic_expression("foo", mg_mk_str("foo//")));
        1: 3409:  ASSERT(!mg_mqtt_vmatch_topic_expression("foo", mg_mk_str("foo/bar")));
        1: 3410:  ASSERT(!mg_mqtt_vmatch_topic_expression("foo", mg_mk_str("foo/+")));
        1: 3411:  ASSERT(mg_mqtt_vmatch_topic_expression("foo/bar", mg_mk_str("foo/bar")));
        1: 3412:  ASSERT(mg_mqtt_vmatch_topic_expression("foo/+", mg_mk_str("foo/bar")));
        1: 3413:  ASSERT(mg_mqtt_vmatch_topic_expression("+/bar", mg_mk_str("foo/bar")));
        1: 3414:  ASSERT(mg_mqtt_vmatch_topic_expression("+/+", mg_mk_str("foo/bar")));
        1: 3415:  ASSERT(mg_mqtt_vmatch_topic_expression("foo/+/bar", mg_mk_str("foo//bar")));
        1: 3416:  ASSERT(!mg_mqtt_vmatch_topic_expression("foo/+/+", mg_mk_str("foo/bar")));
        1: 3417:  ASSERT(mg_mqtt_vmatch_topic_expression("foo/+/#", mg_mk_str("foo/bar")));
        1: 3418:  ASSERT(mg_mqtt_vmatch_topic_expression("+/foo/bar", mg_mk_str("/foo/bar")));
        -: 3419:
        1: 3420:  ASSERT(!mg_mqtt_vmatch_topic_expression("", mg_mk_str("")));
        1: 3421:  ASSERT(mg_mqtt_vmatch_topic_expression("/", mg_mk_str("")));
        1: 3422:  ASSERT(mg_mqtt_vmatch_topic_expression("/", mg_mk_str("/")));
        -: 3423:
        1: 3424:  ASSERT(mg_mqtt_vmatch_topic_expression("#", mg_mk_str("")));
        1: 3425:  ASSERT(mg_mqtt_vmatch_topic_expression("#", mg_mk_str("foo")));
        1: 3426:  ASSERT(mg_mqtt_vmatch_topic_expression("#", mg_mk_str("foo/bar")));
        1: 3427:  ASSERT(mg_mqtt_vmatch_topic_expression("foo/#", mg_mk_str("foo")));
        1: 3428:  ASSERT(mg_mqtt_vmatch_topic_expression("foo/#", mg_mk_str("foo/")));
        1: 3429:  ASSERT(mg_mqtt_vmatch_topic_expression("foo/#", mg_mk_str("foo/bar")));
        1: 3430:  ASSERT(mg_mqtt_vmatch_topic_expression("foo/#", mg_mk_str("foo/bar/baz")));
        1: 3431:  ASSERT(!mg_mqtt_vmatch_topic_expression("#/foo", mg_mk_str("foo")));
        1: 3432:  ASSERT(!mg_mqtt_vmatch_topic_expression("#/foo", mg_mk_str("bar/foo")));
        -: 3433:
        1: 3434:  return NULL;
        -: 3435:}
        -: 3436:
        -: 3437:#if MG_ENABLE_MQTT_BROKER
        -: 3438:struct mg_mqtt_topic_expression brk_test_te[] = {{"/dummy", 0}, {"/unit/#", 0}};
        -: 3439:
       29: 3440:static void brk_cln_cb1(struct mg_connection *nc, int ev, void *p) {
       29: 3441:  struct mg_mqtt_message *msg = (struct mg_mqtt_message *) p;
        -: 3442:
       29: 3443:  switch (ev) {
        1: 3444:    case MG_EV_CONNECT:
        1: 3445:      mg_set_protocol_mqtt(nc);
        1: 3446:      mg_send_mqtt_handshake(nc, "dummy");
        1: 3447:      break;
        1: 3448:    case MG_EV_MQTT_CONNACK:
        1: 3449:      mg_mqtt_subscribe(nc, brk_test_te, ARRAY_SIZE(brk_test_te), 42);
        1: 3450:      break;
        1: 3451:    case MG_EV_MQTT_SUBACK:
        1: 3452:      mg_mqtt_publish(nc, "/unit/test", 0, MG_MQTT_QOS(0), "payload", 7);
        1: 3453:      break;
        1: 3454:    case MG_EV_MQTT_PUBLISH:
        2: 3455:      if (mg_vcmp(&msg->topic, "/unit/test") == 0 && msg->payload.len == 7 &&
        1: 3456:          mg_vcmp(&msg->payload, "payload") == 0) {
        1: 3457:        *(int *) nc->user_data = 1;
        -: 3458:      }
        1: 3459:      break;
        -: 3460:  }
       29: 3461:}
        -: 3462:
        3: 3463:static void mqtt_dummy_eh(struct mg_connection *nc, int ev, void *ev_data) {
        -: 3464:  (void) nc;
        -: 3465:  (void) ev;
        -: 3466:  (void) ev_data;
        3: 3467:}
        -: 3468:
        1: 3469:static const char *test_mqtt_client_keep_alive(void) {
        -: 3470:  struct mg_send_mqtt_handshake_opts opts;
        1: 3471:  struct mg_connection *nc = create_test_connection();
        -: 3472:  struct mg_mqtt_proto_data *pd;
        1: 3473:  double before = mg_time();
        -: 3474:  const char *got;
        1: 3475:  mg_set_protocol_mqtt(nc);
        1: 3476:  pd = (struct mg_mqtt_proto_data *) nc->proto_data;
        1: 3477:  nc->handler = mqtt_dummy_eh;
        -: 3478:
        1: 3479:  memset(&opts, 0, sizeof(opts));
        1: 3480:  before = mg_time();
        1: 3481:  msleep(2);
        1: 3482:  opts.keep_alive = 2;
        1: 3483:  mg_send_mqtt_handshake_opt(nc, "testclient", opts);
        1: 3484:  ASSERT_EQ(pd->keep_alive, 2);
        1: 3485:  ASSERT_GT(pd->last_control_time, before);
        1: 3486:  mbuf_remove(&nc->send_mbuf, nc->send_mbuf.len); /* Remove the CONNECT. */
        -: 3487:
        1: 3488:  before = pd->last_control_time;
        1: 3489:  msleep(2);
        1: 3490:  nc->proto_handler(nc, MG_EV_POLL, NULL);
        1: 3491:  ASSERT_EQ(nc->send_mbuf.len, 0);
        1: 3492:  ASSERT_EQ(pd->last_control_time, before);
        1: 3493:  sleep(1);
        1: 3494:  nc->proto_handler(nc, MG_EV_POLL, NULL);
        1: 3495:  ASSERT_EQ(nc->send_mbuf.len, 0); /* Not yet */
        1: 3496:  ASSERT_EQ(pd->last_control_time, before);
        1: 3497:  sleep(1);
        1: 3498:  msleep(2);
        1: 3499:  nc->proto_handler(nc, MG_EV_POLL, NULL);
        1: 3500:  ASSERT_GT(nc->send_mbuf.len, 0); /* PINGREQ sent */
        1: 3501:  got = nc->send_mbuf.buf;
        1: 3502:  ASSERT_EQ(nc->send_mbuf.len, 2);
        1: 3503:  ASSERT_EQ((got[0] & 0xf0), (MG_MQTT_CMD_PINGREQ << 4));
        1: 3504:  ASSERT_GT(pd->last_control_time, before); /* Resets itself */
        -: 3505:
        1: 3506:  destroy_test_connection(nc);
        1: 3507:  return NULL;
        -: 3508:}
        -: 3509:
        1: 3510:static const char *test_mqtt_broker(void) {
        -: 3511:  struct mg_mgr mgr;
        -: 3512:  struct mg_mqtt_broker brk;
        -: 3513:  struct mg_connection *brk_nc;
        -: 3514:  struct mg_connection *cln_nc;
        1: 3515:  const char *brk_local_addr = "127.0.0.1:7777";
        1: 3516:  int brk_data = 0, cln_data = 0;
        -: 3517:
        1: 3518:  mg_mgr_init(&mgr, NULL);
        1: 3519:  mg_mqtt_broker_init(&brk, &brk_data);
        -: 3520:
        1: 3521:  ASSERT((brk_nc = mg_bind(&mgr, brk_local_addr, mg_mqtt_broker)) != NULL);
        1: 3522:  brk_nc->priv_2 = &brk;
        -: 3523:
        1: 3524:  ASSERT((cln_nc = mg_connect(&mgr, brk_local_addr, brk_cln_cb1)) != NULL);
        1: 3525:  cln_nc->user_data = &cln_data;
        -: 3526:
        -: 3527:  /* Run event loop. Use more cycles to let client and broker communicate. */
        1: 3528:  poll_until(&mgr, 1, c_int_eq, &cln_data, (void *) 1);
        -: 3529:
        1: 3530:  ASSERT_EQ(cln_data, 1);
        -: 3531:
        1: 3532:  mg_mgr_free(&mgr);
        -: 3533:
        1: 3534:  return NULL;
        -: 3535:}
        -: 3536:#endif /* MG_ENABLE_MQTT_BROKER */
        -: 3537:
        3: 3538:static void cb5(struct mg_connection *nc, int ev, void *ev_data) {
        3: 3539:  switch (ev) {
        1: 3540:    case MG_EV_CONNECT:
        1: 3541:      sprintf((char *) nc->user_data, "%d", *(int *) ev_data);
        1: 3542:      break;
        2: 3543:    default:
        2: 3544:      break;
        -: 3545:  }
        3: 3546:}
        -: 3547:
        1: 3548:static const char *test_connect_fail(void) {
        -: 3549:  struct mg_mgr mgr;
        -: 3550:  struct mg_connection *nc;
        1: 3551:  char buf[100] = "0";
        -: 3552:
        1: 3553:  mg_mgr_init(&mgr, NULL);
        1: 3554:  ASSERT((nc = mg_connect(&mgr, "127.0.0.1:33211", cb5)) != NULL);
        1: 3555:  nc->user_data = buf;
        1: 3556:  poll_until(&mgr, 1, c_str_ne, buf, (void *) "0");
        1: 3557:  mg_mgr_free(&mgr);
        -: 3558:
        -: 3559:/* printf("failed connect status: [%s]\n", buf); */
        -: 3560:/* TODO(lsm): fix this for Win32 */
        -: 3561:#ifndef _WIN32
        1: 3562:  ASSERT(strcmp(buf, "0") != 0);
        -: 3563:#endif
        -: 3564:
        1: 3565:  return NULL;
        -: 3566:}
        -: 3567:
        3: 3568:static void cb6(struct mg_connection *nc, int ev, void *ev_data) {
        -: 3569:  (void) ev;
        -: 3570:  (void) ev_data;
        3: 3571:  nc->flags |= MG_F_USER_4;
        3: 3572:  nc->flags |= MG_F_WANT_READ; /* Should not be allowed. */
        3: 3573:}
        -: 3574:
        1: 3575:static const char *test_connect_opts(void) {
        -: 3576:  struct mg_mgr mgr;
        -: 3577:  struct mg_connection *nc;
        -: 3578:  struct mg_connect_opts opts;
        -: 3579:
        1: 3580:  memset(&opts, 0, sizeof(opts));
        1: 3581:  opts.user_data = (void *) 0xdeadbeef;
        1: 3582:  opts.flags = MG_F_USER_6;
        1: 3583:  opts.flags |= MG_F_WANT_READ; /* Should not be allowed. */
        -: 3584:
        1: 3585:  mg_mgr_init(&mgr, NULL);
        1: 3586:  ASSERT((nc = mg_connect_opt(&mgr, "127.0.0.1:33211", cb6, opts)) != NULL);
        1: 3587:  ASSERT(nc->user_data == (void *) 0xdeadbeef);
        1: 3588:  ASSERT(nc->flags & MG_F_USER_6);
        1: 3589:  ASSERT(!(nc->flags & MG_F_WANT_READ));
        -: 3590:  /* TODO(rojer): find a way to test this w/o touching nc (already freed).
        -: 3591:    poll_mgr(&mgr, 25);
        -: 3592:    ASSERT(nc->flags & MG_F_USER_4);
        -: 3593:    ASSERT(nc->flags & MG_F_USER_6);
        -: 3594:    ASSERT(!(nc->flags & MG_F_WANT_READ));
        -: 3595:  */
        1: 3596:  mg_mgr_free(&mgr);
        1: 3597:  return NULL;
        -: 3598:}
        -: 3599:
        1: 3600:static const char *test_connect_opts_error_string(void) {
        -: 3601:  struct mg_mgr mgr;
        -: 3602:  struct mg_connection *nc;
        -: 3603:  struct mg_connect_opts opts;
        1: 3604:  const char *error_string = NULL;
        -: 3605:
        1: 3606:  memset(&opts, 0, sizeof(opts));
        1: 3607:  opts.error_string = &error_string;
        -: 3608:
        1: 3609:  mg_mgr_init(&mgr, NULL);
        1: 3610:  ASSERT((nc = mg_connect_opt(&mgr, "127.0.0.1:65537", cb6, opts)) == NULL);
        1: 3611:  ASSERT(error_string != NULL);
        1: 3612:  ASSERT_STREQ(error_string, "cannot parse address");
        1: 3613:  mg_mgr_free(&mgr);
        1: 3614:  return NULL;
        -: 3615:}
        -: 3616:
        -: 3617:#ifndef NO_DNS_TEST
        1: 3618:static const char *test_resolve(void) {
        -: 3619:  char buf[20];
        -: 3620:
        1: 3621:  ASSERT(mg_resolve("localhost", buf, sizeof(buf)) > 0);
        1: 3622:  ASSERT_STREQ(buf, "127.0.0.1");
        -: 3623:
        1: 3624:  ASSERT_EQ(mg_resolve("please_dont_name_a_host_like_ths", buf, sizeof(buf)),
        -: 3625:            0);
        1: 3626:  return NULL;
        -: 3627:}
        -: 3628:#endif
        -: 3629:
        1: 3630:static const char *test_base64(void) {
        1: 3631:  const char *cases[] = {"test", "longer string"};
        -: 3632:  unsigned long i;
        -: 3633:  char enc[8192];
        -: 3634:  char dec[8192];
        -: 3635:
        3: 3636:  for (i = 0; i < sizeof(cases) / sizeof(cases[0]); i++) {
        2: 3637:    mg_base64_encode((unsigned char *) cases[i], strlen(cases[i]), enc);
        2: 3638:    mg_base64_decode((unsigned char *) enc, strlen(enc), dec);
        -: 3639:
        2: 3640:    ASSERT_EQ(strcmp(cases[i], dec), 0);
        -: 3641:  }
        -: 3642:
        1: 3643:  ASSERT_EQ(mg_base64_decode((unsigned char *) "", 4, dec), 0);
        1: 3644:  ASSERT_EQ(mg_base64_decode((unsigned char *) "AAAA----", 8, dec), 4);
        1: 3645:  ASSERT_EQ(mg_base64_decode((unsigned char *) "Q2VzYW50YQ==", 12, dec), 12);
        1: 3646:  ASSERT_STREQ(dec, "Cesanta");
        -: 3647:
        1: 3648:  return NULL;
        -: 3649:}
        -: 3650:
        1: 3651:static const char *test_sock_addr_to_str(void) {
        -: 3652:  char buf[60];
        1: 3653:  buf[0] = '\0';
        -: 3654:  {
        -: 3655:    union socket_address a4;
        1: 3656:    memset(&a4, 0, sizeof(a4));
        1: 3657:    a4.sa.sa_family = AF_INET;
        1: 3658:    a4.sin.sin_addr.s_addr = inet_addr("127.0.0.1");
        1: 3659:    a4.sin.sin_port = htons(12345);
        1: 3660:    mg_sock_addr_to_str(&a4, buf, sizeof(buf), 0);
        1: 3661:    ASSERT_STREQ(buf, "");
        1: 3662:    mg_sock_addr_to_str(&a4, buf, sizeof(buf), MG_SOCK_STRINGIFY_IP);
        1: 3663:    ASSERT_STREQ(buf, "127.0.0.1");
        1: 3664:    mg_sock_addr_to_str(&a4, buf, sizeof(buf), MG_SOCK_STRINGIFY_PORT);
        1: 3665:    ASSERT_STREQ(buf, "12345");
        1: 3666:    mg_sock_addr_to_str(&a4, buf, sizeof(buf),
        -: 3667:                        MG_SOCK_STRINGIFY_IP | MG_SOCK_STRINGIFY_PORT);
        1: 3668:    ASSERT_STREQ(buf, "127.0.0.1:12345");
        -: 3669:  }
        -: 3670:#if MG_ENABLE_IPV6 && !defined(_WIN32)
        -: 3671:  {
        -: 3672:    union socket_address a6;
        1: 3673:    memset(&a6, 0, sizeof(a6));
        1: 3674:    a6.sa.sa_family = AF_INET6;
        2: 3675:    ASSERT_EQ(inet_pton(AF_INET6, "2001::123", &a6.sin6.sin6_addr), 1);
        1: 3676:    a6.sin6.sin6_port = htons(12345);
        1: 3677:    mg_sock_addr_to_str(&a6, buf, sizeof(buf), 0);
        1: 3678:    ASSERT_STREQ(buf, "");
        1: 3679:    mg_sock_addr_to_str(&a6, buf, sizeof(buf), MG_SOCK_STRINGIFY_IP);
        1: 3680:    ASSERT_STREQ(buf, "2001::123");
        1: 3681:    mg_sock_addr_to_str(&a6, buf, sizeof(buf), MG_SOCK_STRINGIFY_PORT);
        1: 3682:    ASSERT_STREQ(buf, "12345");
        1: 3683:    mg_sock_addr_to_str(&a6, buf, sizeof(buf),
        -: 3684:                        MG_SOCK_STRINGIFY_IP | MG_SOCK_STRINGIFY_PORT);
        1: 3685:    ASSERT_STREQ(buf, "[2001::123]:12345");
        -: 3686:  }
        -: 3687:#endif
        1: 3688:  return NULL;
        -: 3689:}
        -: 3690:
        1: 3691:static const char *test_hexdump(void) {
        1: 3692:  const char *src = "\1\2\3\4abcd";
        -: 3693:  char got[256];
        -: 3694:
        1: 3695:  const char *want =
        -: 3696:      "0000  01 02 03 04 61 62 63 64"
        -: 3697:      "                          ....abcd\n";
        1: 3698:  ASSERT_EQ(mg_hexdump(src, strlen(src), got, sizeof(got)), (int) strlen(want));
        1: 3699:  ASSERT_STREQ(got, want);
        1: 3700:  return NULL;
        -: 3701:}
        -: 3702:
        1: 3703:static const char *test_hexdump_file(void) {
        1: 3704:  const char *path = "test_hexdump";
        -: 3705:  char *data, *got;
        -: 3706:  size_t size;
        -: 3707:  FILE *fp;
        1: 3708:  struct mg_connection *nc = create_test_connection();
        -: 3709:
        -: 3710:  /* "In the GNU system, non-null pointers are printed as unsigned integers,
        -: 3711:   * as if a `%#x' conversion were used. Null pointers print as `(nil)'.
        -: 3712:   * (Pointers might print differently in other systems.)"
        -: 3713:   * indeed it prints 0x0 on apple.
        -: 3714:   */
        1: 3715:  nc->user_data = (void *) 0xbeef;
        -: 3716:
        -: 3717:  /* truncate file. open+O_TRUNC works on wine but not on real windows */
        1: 3718:  fp = fopen(path, "w");
        1: 3719:  ASSERT(fp != NULL);
        1: 3720:  fclose(fp);
        -: 3721:
        1: 3722:  mbuf_append(&nc->send_mbuf, "foo", 3);
        1: 3723:  mbuf_append(&nc->recv_mbuf, "bar", 3);
        1: 3724:  mg_hexdump_connection(nc, path, nc->send_mbuf.buf, 3, MG_EV_SEND);
        -: 3725:
        1: 3726:  mbuf_free(&nc->send_mbuf);
        1: 3727:  mbuf_free(&nc->recv_mbuf);
        1: 3728:  free(nc);
        -: 3729:
        1: 3730:  ASSERT((data = read_file(path, &size)) != NULL);
        1: 3731:  unlink(path);
        -: 3732:
        1: 3733:  got = data;
        1: 3734:  while (got - data < (int) size && *got++ != ' ')
        -: 3735:    ;
        1: 3736:  size -= got - data;
        -: 3737:
        1: 3738:  ASSERT(strstr(got,
        -: 3739:                "0000  66 6f 6f                "
        -: 3740:                "                         foo") != NULL);
        -: 3741:
        1: 3742:  free(data);
        1: 3743:  return NULL;
        -: 3744:}
        -: 3745:
        1: 3746:static const char *test_basic_auth_helpers() {
        -: 3747:  struct mbuf buf;
        1: 3748:  mbuf_init(&buf, 0);
        1: 3749:  mg_basic_auth_header(mg_mk_str("foo"), mg_mk_str("bar"), &buf);
        1: 3750:  ASSERT_EQ(buf.len, 35);
        1: 3751:  ASSERT_EQ(memcmp(buf.buf, "Authorization: Basic Zm9vOmJhcg==\r\n", 35), 0);
        -: 3752:
        1: 3753:  buf.len = 0;
        1: 3754:  mg_basic_auth_header(mg_mk_str("foo:bar"), mg_mk_str_n(NULL, 0), &buf);
        1: 3755:  ASSERT_EQ(buf.len, 35);
        1: 3756:  ASSERT_EQ(memcmp(buf.buf, "Authorization: Basic Zm9vOmJhcg==\r\n", 35), 0);
        -: 3757:
        1: 3758:  mbuf_free(&buf);
        -: 3759:
        -: 3760:  {
        -: 3761:    char user[256];
        -: 3762:    char pass[256];
        -: 3763:    size_t i;
        -: 3764:
        -: 3765:    struct {
        -: 3766:      const char *hdr;
        -: 3767:      const char *user;
        -: 3768:      const char *pass;
        -: 3769:      int res;
        1: 3770:    } cases[] = {
        -: 3771:        {"Basic Zm9vOmJhcg==", "foo", "bar", 0},         /* foo:bar */
        -: 3772:        {"Basic Zm9v", "foo", "", 0},                    /* foo */
        -: 3773:        {"Basic Zm9vOmJhcjpiYXo=", "foo", "bar:baz", 0}, /* foo:bar:baz */
        -: 3774:        {"Basic Zm9vOg==", "foo", "", 0},                /* foo: */
        -: 3775:        {"Basic OmJhcg==", "", "", -1},                  /* :bar */
        -: 3776:    };
        -: 3777:
       12: 3778:    for (i = 0; i < sizeof(cases) / sizeof(cases[0]); i++) {
        5: 3779:      struct mg_str hdr = mg_mk_str(cases[i].hdr);
        -: 3780:      int res;
        -: 3781:
        5: 3782:      memset(user, 0, sizeof(user));
        5: 3783:      memset(pass, 0, sizeof(pass));
        5: 3784:      res = mg_parse_http_basic_auth(&hdr, user, sizeof(user), pass,
        -: 3785:                                     sizeof(pass));
        5: 3786:      ASSERT_EQ(res, cases[i].res);
        5: 3787:      ASSERT_EQ(strcmp(user, cases[i].user), 0);
        5: 3788:      ASSERT_EQ(strcmp(pass, cases[i].pass), 0);
        -: 3789:    }
        -: 3790:  }
        1: 3791:  return NULL;
        -: 3792:}
        -: 3793:
       84: 3794:static void test_auth_server_handler(struct mg_connection *nc, int ev,
        -: 3795:                                     void *ev_data) {
       84: 3796:  struct http_message *hm = (struct http_message *) ev_data;
        -: 3797:  struct mg_str *hdr;
       84: 3798:  char user[256] = "";
       84: 3799:  char pass[256] = "";
        -: 3800:  int res;
        -: 3801:
       84: 3802:  switch (ev) {
        3: 3803:    case MG_EV_WEBSOCKET_HANDSHAKE_REQUEST:
        -: 3804:    case MG_EV_HTTP_REQUEST: {
        3: 3805:      hdr = mg_get_http_header(hm, "Sec-WebSocket-Protocol");
        3: 3806:      if (hdr != NULL) {
        1: 3807:        if (mg_vcmp(hdr, "myproto") == 0) {
        1: 3808:          *(int *) nc->user_data = 2;
        1: 3809:          break;
        -: 3810:        }
        -: 3811:      }
        -: 3812:
        2: 3813:      res = mg_get_http_basic_auth(hm, user, sizeof(user), pass, sizeof(pass));
        2: 3814:      if (res == -1) {
    #####: 3815:        *(int *) nc->user_data = -1;
    #####: 3816:        break;
        -: 3817:      }
        -: 3818:
        2: 3819:      if (strcmp(user, "foo") == 0 && strcmp(pass, "bar") == 0) {
        2: 3820:        *(int *) nc->user_data = 1;
        -: 3821:      } else {
    #####: 3822:        *(int *) nc->user_data = -2;
        -: 3823:      }
        -: 3824:
        2: 3825:      break;
        -: 3826:    }
        -: 3827:  }
       84: 3828:}
        -: 3829:
       60: 3830:static void test_auth_client_handler(struct mg_connection *nc, int ev,
        -: 3831:                                     void *ev_data) {
        -: 3832:  (void) nc;
        -: 3833:  (void) ev;
        -: 3834:  (void) ev_data;
       60: 3835:}
        -: 3836:
        1: 3837:static const char *test_http_auth() {
        -: 3838:  int connected;
        -: 3839:  struct mg_connection *nc;
        -: 3840:  struct mg_mgr mgr;
        1: 3841:  mg_mgr_init(&mgr, NULL);
        -: 3842:
        1: 3843:  nc = mg_bind(&mgr, "127.0.0.1:1234", test_auth_server_handler);
        1: 3844:  mg_set_protocol_http_websocket(nc);
        1: 3845:  nc->user_data = &connected;
        -: 3846:
        1: 3847:  connected = 0;
        1: 3848:  mg_connect_http(&mgr, test_auth_client_handler,
        -: 3849:                  "http://foo:bar@127.0.0.1:1234", NULL, NULL);
        1: 3850:  poll_until(&mgr, 4, c_int_eq, &connected, (void *) 1);
        1: 3851:  ASSERT_EQ(connected, 1);
        -: 3852:
        1: 3853:  connected = 0;
        1: 3854:  mg_connect_ws(&mgr, test_auth_client_handler, "ws://foo:bar@127.0.0.1:1234",
        -: 3855:                NULL, NULL);
        1: 3856:  poll_until(&mgr, 4, c_int_eq, &connected, (void *) 1);
        1: 3857:  ASSERT_EQ(connected, 1);
        -: 3858:
        -: 3859:  /* check that we didn't break proto or other headers */
        1: 3860:  connected = 0;
        1: 3861:  mg_connect_ws(&mgr, test_auth_client_handler, "ws://127.0.0.1:1234",
        -: 3862:                "myproto", NULL);
        1: 3863:  poll_until(&mgr, 4, c_int_eq, &connected, (void *) 2);
        1: 3864:  ASSERT_EQ(connected, 2);
        -: 3865:
        1: 3866:  mg_mgr_free(&mgr);
        1: 3867:  return NULL;
        -: 3868:}
        -: 3869:
    #####: 3870:void tunnel_server_test_handler(struct mg_connection *nc, int ev,
        -: 3871:                                void *ev_data) {
        -: 3872:  (void) ev_data;
    #####: 3873:  switch (ev) {
    #####: 3874:    case MG_EV_HTTP_REQUEST:
    #####: 3875:      if (nc->user_data) break;
        -: 3876:
    #####: 3877:      nc->user_data = (void *) malloc(sizeof(int));
    #####: 3878:      (*(int *) nc->user_data) = 0;
    #####: 3879:      mg_set_timer(nc, mg_time() + 0.01);
        -: 3880:
    #####: 3881:      mg_printf(nc, "%s",
        -: 3882:                "HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n");
    #####: 3883:      break;
    #####: 3884:    case MG_EV_TIMER:
    #####: 3885:      mg_printf_http_chunk(nc, "%d", (*(int *) nc->user_data)++);
    #####: 3886:      if (*(int *) nc->user_data == 10) {
    #####: 3887:        mg_send_http_chunk(nc, "", 0);
    #####: 3888:        nc->flags |= MG_F_SEND_AND_CLOSE;
        -: 3889:      } else {
    #####: 3890:        mg_set_timer(nc, mg_time() + 0.01);
        -: 3891:      }
    #####: 3892:      break;
    #####: 3893:    case MG_EV_CLOSE:
    #####: 3894:      free(nc->user_data);
    #####: 3895:    default:
    #####: 3896:      break;
        -: 3897:  }
    #####: 3898:}
        -: 3899:
    #####: 3900:void tunnel_client_test_handler(struct mg_connection *nc, int ev,
        -: 3901:                                void *ev_data) {
    #####: 3902:  struct http_message *hm = (struct http_message *) ev_data;
        -: 3903:  (void) nc;
        -: 3904:  (void) ev_data;
    #####: 3905:  switch (ev) {
    #####: 3906:    case MG_EV_HTTP_REPLY:
    #####: 3907:      if (hm->body.len == 10 && strcmp(hm->body.p, "0123456789") == 0) {
    #####: 3908:        *(int *) nc->user_data = 1;
        -: 3909:      } else {
    #####: 3910:        fprintf(stderr, "want: 10, got:%d \"%.*s\"\n", (int) hm->body.len,
    #####: 3911:                (int) hm->body.len, hm->body.p);
        -: 3912:      }
    #####: 3913:      break;
    #####: 3914:    default:
    #####: 3915:      break;
        -: 3916:  }
    #####: 3917:}
        -: 3918:
        1: 3919:static const char *test_http_chunk(void) {
        -: 3920:  struct mg_connection nc;
        1: 3921:  init_test_connection(&nc);
        -: 3922:
        1: 3923:  mg_printf_http_chunk(&nc, "%d %s", 123, ":-)");
        1: 3924:  ASSERT_EQ(nc.send_mbuf.len, 12);
        1: 3925:  ASSERT_EQ(memcmp(nc.send_mbuf.buf, "7\r\n123 :-)\r\n", 12), 0);
        1: 3926:  mbuf_free(&nc.send_mbuf);
        -: 3927:
        1: 3928:  mg_send_http_chunk(&nc, "", 0);
        1: 3929:  ASSERT_EQ(nc.send_mbuf.len, 5);
        1: 3930:  ASSERT_EQ(memcmp(nc.send_mbuf.buf, "0\r\n\r\n", 3), 0);
        1: 3931:  mbuf_free(&nc.send_mbuf);
        -: 3932:
        1: 3933:  return NULL;
        -: 3934:}
        -: 3935:
        -: 3936:static int s_handle_chunk_event = 0;
        -: 3937:static char s_events[100];
        -: 3938:
        4: 3939:static void eh_chunk2(struct mg_connection *nc, int ev, void *ev_data) {
        4: 3940:  if (ev == MG_EV_HTTP_CHUNK) {
        4: 3941:    if (s_handle_chunk_event) {
        1: 3942:      nc->flags |= MG_F_DELETE_CHUNK;
        -: 3943:    }
        -: 3944:  }
        4: 3945:  snprintf(s_events + strlen(s_events), sizeof(s_events) - strlen(s_events),
        -: 3946:           "_%d", ev);
        -: 3947:  (void) ev_data;
        4: 3948:}
        -: 3949:
        1: 3950:static const char *test_http_extra_headers(void) {
        -: 3951:  char buf[FETCH_BUF_SIZE];
        1: 3952:  const char *expect = "MyHdr: my_val\r\n";
        1: 3953:  s_http_server_opts.extra_headers = "MyHdr: my_val";
        1: 3954:  fetch_http(buf, "%s", "GET / HTTP/1.0\r\n\r\n");
        1: 3955:  ASSERT(strstr(buf, expect) != NULL);
        1: 3956:  s_http_server_opts.extra_headers = NULL;
        1: 3957:  return NULL;
        -: 3958:}
        -: 3959:
        1: 3960:static const char *test_http_not_modified(void) {
        -: 3961:  struct http_message hm;
        -: 3962:  cs_stat_t st;
        1: 3963:  const char *req1 =
        -: 3964:      "GET / HTTP/1.0\nIf-None-Match: \"0.123\"\n"
        -: 3965:      "If-Modified-Since: Tue 17 Nov 2015 21:01:56 GMT\n\n";
        1: 3966:  const char *req4 =
        -: 3967:      "GET / HTTP/1.0\nIf-None-Match: \"0.7\"\n"
        -: 3968:      "If-Modified-Since: Tue 17 Nov 2015 21:01:56 GMT\n\n";
        1: 3969:  const char *req2 =
        -: 3970:      "GET / HTTP/1.0\n"
        -: 3971:      "If-Modified-Since: Tue 17 Nov 2015 21:01:56 GMT\n\n";
        1: 3972:  const char *req3 = "GET / HTTP/1.0\n\n";
        -: 3973:
        1: 3974:  st.st_size = 7;
        1: 3975:  st.st_mtime = (time_t) 0;
        -: 3976:
        -: 3977:  /* Not modified according to If-Modified-Since, but modified by Etag. */
        1: 3978:  ASSERT(mg_parse_http(req1, strlen(req1), &hm, 1) > 0);
        1: 3979:  ASSERT(mg_is_not_modified(&hm, &st) == 0);
        -: 3980:
        -: 3981:  /* Not modified according to If-Modified-Since, and no Etag. */
        1: 3982:  ASSERT(mg_parse_http(req2, strlen(req2), &hm, 1) > 0);
        1: 3983:  ASSERT(mg_is_not_modified(&hm, &st) != 0);
        -: 3984:
        1: 3985:  ASSERT(mg_parse_http(req3, strlen(req3), &hm, 1) > 0);
        1: 3986:  ASSERT(mg_is_not_modified(&hm, &st) == 0);
        -: 3987:
        1: 3988:  ASSERT(mg_parse_http(req4, strlen(req4), &hm, 1) > 0);
        1: 3989:  ASSERT(mg_is_not_modified(&hm, &st) != 0);
        -: 3990:
        1: 3991:  return NULL;
        -: 3992:}
        -: 3993:
        1: 3994:static const char *test_http_chunk2(void) {
        -: 3995:  struct mg_connection nc;
        -: 3996:  struct http_message hm;
        1: 3997:  char buf[100] = "5\r\nhe";
        -: 3998:  struct mg_mgr mgr;
        1: 3999:  mg_mgr_init(&mgr, NULL);
        -: 4000:
        1: 4001:  memset(&nc, 0, sizeof(nc));
        1: 4002:  memset(&hm, 0, sizeof(hm));
        1: 4003:  nc.mgr = &mgr;
        1: 4004:  nc.sock = INVALID_SOCKET;
        1: 4005:  nc.handler = eh_chunk2;
        1: 4006:  hm.message.len = hm.body.len = ~0;
        -: 4007:
        1: 4008:  s_handle_chunk_event = 0;
        1: 4009:  ASSERT_EQ(mg_handle_chunked(&nc, &hm, buf, strlen(buf)), 0);
        -: 4010:
        -: 4011:  /* Simulate arrival of chunks. MG_EV_HTTP_CHUNK events are not handled. */
        1: 4012:  strcat(buf, "llo\r");
        1: 4013:  ASSERT_EQ(mg_handle_chunked(&nc, &hm, buf, strlen(buf)), 0);
        1: 4014:  ASSERT_STREQ(buf, "5\r\nhello\r");
        -: 4015:
        1: 4016:  strcat(buf, "\n");
        1: 4017:  ASSERT_EQ(mg_handle_chunked(&nc, &hm, buf, strlen(buf)), 5);
        1: 4018:  ASSERT_STREQ(buf, "hello");
        -: 4019:
        1: 4020:  s_handle_chunk_event = 1;
        1: 4021:  strcat(buf, "3\r\n:-)\r\n");
        1: 4022:  ASSERT_EQ(mg_handle_chunked(&nc, &hm, buf, strlen(buf)), 8);
        1: 4023:  ASSERT_STREQ(buf, "");
        -: 4024:
        1: 4025:  s_handle_chunk_event = 0;
        1: 4026:  strcat(buf, "3\r\n...\r\na\r\n0123456789\r\n0\r");
        1: 4027:  ASSERT_EQ(mg_handle_chunked(&nc, &hm, buf, strlen(buf)), 13);
        1: 4028:  ASSERT_STREQ(buf, "...01234567890\r");
        1: 4029:  ASSERT_EQ64(hm.message.len, (size_t) ~0);
        -: 4030:
        1: 4031:  strcat(buf, "\n\r\n");
        1: 4032:  ASSERT_EQ(mg_handle_chunked(&nc, &hm, buf, strlen(buf)), 13);
        1: 4033:  ASSERT_STREQ(buf, "...0123456789");
        1: 4034:  ASSERT_EQ(hm.message.len, 13);
        -: 4035:
        1: 4036:  ASSERT_STREQ(s_events, "_102_102_102_102");
        -: 4037:
        1: 4038:  ASSERT(nc.proto_data != NULL);
        1: 4039:  nc.proto_data_destructor(nc.proto_data);
        -: 4040:
        1: 4041:  mg_mgr_free(&mgr);
        -: 4042:
        1: 4043:  return NULL;
        -: 4044:}
        -: 4045:
        1: 4046:static const char *test_parse_date_string(void) {
        1: 4047:  ASSERT_EQ(mg_parse_date_string("Sat, 31 Oct 2019 10:51:12 GMT"), 1572519072);
        1: 4048:  ASSERT_EQ(mg_parse_date_string("31/Oct/2019 10:51:12 GMT"), 1572519072);
        1: 4049:  ASSERT_EQ(mg_parse_date_string("31 Oct 2019 10:51:12 GMT"), 1572519072);
        1: 4050:  ASSERT_EQ(mg_parse_date_string("31-Oct-2019 10:51:12 GMT"), 1572519072);
        1: 4051:  return NULL;
        -: 4052:}
        -: 4053:
        -: 4054:#if MG_ENABLE_HTTP_STREAMING_MULTIPART
        -: 4055:struct cb_mp_srv_data {
        -: 4056:  struct mbuf res;
        -: 4057:  int request_end;
        -: 4058:};
        -: 4059:
     6992: 4060:static void cb_mp_srv(struct mg_connection *nc, int ev, void *p) {
     6992: 4061:  struct cb_mp_srv_data *mpd = (struct cb_mp_srv_data *) nc->user_data;
     6992: 4062:  struct mbuf *data = &mpd->res;
     6992: 4063:  if (nc->listener == NULL) return;
        -: 4064:
     4605: 4065:  switch (ev) {
        7: 4066:    case MG_EV_HTTP_MULTIPART_REQUEST: {
        7: 4067:      struct http_message *hm = (struct http_message *) p;
        7: 4068:      mbuf_append(data, "<MPRQ", 5);
        7: 4069:      mbuf_append(data, hm->uri.p, hm->uri.len);
        7: 4070:      break;
        -: 4071:    }
       19: 4072:    case MG_EV_HTTP_PART_BEGIN: {
       19: 4073:      struct mg_http_multipart_part *mp = (struct mg_http_multipart_part *) p;
       19: 4074:      if (mp->status < 0) {
    #####: 4075:        mbuf_append(data, "ERROR", 5);
        -: 4076:      } else {
       19: 4077:        DBG(("BEGIN %s %s", mp->var_name, mp->file_name));
       19: 4078:        mbuf_append(data, mp->var_name, strlen(mp->var_name));
       19: 4079:        mbuf_append(data, mp->file_name, strlen(mp->file_name));
        -: 4080:      }
       19: 4081:      break;
        -: 4082:    }
     1057: 4083:    case MG_EV_HTTP_PART_DATA: {
     1057: 4084:      struct mg_http_multipart_part *mp = (struct mg_http_multipart_part *) p;
     1057: 4085:      if (mp->status < 0) {
    #####: 4086:        mbuf_append(data, "ERROR", 5);
        -: 4087:      } else {
     1057: 4088:        DBG(("DATA %d", (int) mp->data.len));
     1057: 4089:        mbuf_append(data, mp->data.p, mp->data.len);
        -: 4090:      }
     1057: 4091:      break;
        -: 4092:    }
       19: 4093:    case MG_EV_HTTP_PART_END: {
       19: 4094:      struct mg_http_multipart_part *mp = (struct mg_http_multipart_part *) p;
       19: 4095:      struct mbuf *data = (struct mbuf *) nc->listener->user_data;
       19: 4096:      mbuf_append(data, mp->var_name, strlen(mp->var_name));
       19: 4097:      mbuf_append(data, mp->file_name, strlen(mp->file_name));
       19: 4098:      if (mp->status < 0) {
        1: 4099:        DBG(("PARTERR %s %s", mp->var_name, mp->file_name));
        1: 4100:        mbuf_append(data, "ERROR", 5);
        -: 4101:      } else {
       18: 4102:        DBG(("END %s %s", mp->var_name, mp->file_name));
       18: 4103:        mbuf_append(data, "FIN", 3);
        -: 4104:      }
       19: 4105:      break;
        -: 4106:    }
        7: 4107:    case MG_EV_HTTP_MULTIPART_REQUEST_END: {
        7: 4108:      struct mg_http_multipart_part *mp = (struct mg_http_multipart_part *) p;
        7: 4109:      DBG(("RQEND %p %p", (void *) mp->var_name, (void *) mp->file_name));
        7: 4110:      mbuf_append(data, (mp->status < 0 ? "-" : "+"), 1);
        7: 4111:      mbuf_append(data, (mp->var_name == NULL ? "1" : "0"), 1);
        7: 4112:      mbuf_append(data, (mp->file_name == NULL ? "1" : "0"), 1);
        7: 4113:      mbuf_append(data, "MPRQ>", 5);
        7: 4114:      mpd->request_end = 1;
        7: 4115:      break;
        -: 4116:    }
        -: 4117:  }
        -: 4118:}
        -: 4119:
     6908: 4120:static void cb_mp_send_one_byte(struct mg_connection *nc, int ev, void *p) {
        -: 4121:  static int i = -1;
        -: 4122:  (void) p;
     6908: 4123:  if (ev == MG_EV_CONNECT) {
        2: 4124:    i = 0;
     6906: 4125:  } else if (i >= 0 && ev == MG_EV_POLL) {
     4598: 4126:    char ch = ((char *) nc->user_data)[i++];
     4598: 4127:    int l = strlen((char *) nc->user_data);
     4598: 4128:    if (ch != '\0') {
     4596: 4129:      mg_send(nc, &ch, 1);
     4596: 4130:      DBG(("%p sent %d of %d", (void *) nc, i, l));
        -: 4131:    } else {
        2: 4132:      nc->flags |= MG_F_SEND_AND_CLOSE;
        2: 4133:      i = -1;
        -: 4134:    }
        -: 4135:  }
     6908: 4136:}
        -: 4137:
      233: 4138:static void cb_mp_empty(struct mg_connection *nc, int ev, void *p) {
        -: 4139:  (void) nc;
        -: 4140:  (void) ev;
        -: 4141:  (void) p;
      233: 4142:}
        -: 4143:
        -: 4144:static const char b1[] =
        -: 4145:    "111111111111111111111111111111111111111111111111111111111111111\r\n"
        -: 4146:    "111111111111111111111111111111111111111111111111111111111111111\r\n"
        -: 4147:    "111111111111111111111111111111111111111111111111111111111111111\r\n"
        -: 4148:    "111111111111111111111111111111111111111111111111111111111111111\r\n"
        -: 4149:    "111111111111111111111111111111111111111111111111111111111111111\r\n"
        -: 4150:    "111111111111111111111111111111111111111111111111111111111111111\r\n"
        -: 4151:    "111111111111111111111111111111111111111111111111111111111111111\r\n"
        -: 4152:    "111111111111111111111111111111111111111111111111111111111111111\r\n"
        -: 4153:    "111111111111111111111111111111111111111111111111111111111111111\r\n"
        -: 4154:    "111111111111111111111111111111111111111111111111111111111111111";
        -: 4155:static const char b2[] =
        -: 4156:    "222222222222222222222222222222222222222222222222222222222222222\r\n"
        -: 4157:    "222222222222222222222222222222222222222222222222222222222222222\r\n"
        -: 4158:    "222222222222222222222222222222222222222222222222222222222222222\r\n"
        -: 4159:    "222222222222222222222222222222222222222222222222222222222222222\r\n"
        -: 4160:    "222222222222222222222222222222222222222222222222222222222222222\r\n"
        -: 4161:    "222222222222222222222222222222222222222222222222222222222222222\r\n"
        -: 4162:    "222222222222222222222222222222222222222222222222222222222222222\r\n"
        -: 4163:    "222222222222222222222222222222222222222222222222222222222222222\r\n"
        -: 4164:    "222222222222222222222222222222222222222222222222222222222222222\r\n"
        -: 4165:    "222222222222222222222222222222222222222222222222222222222222222\r\n"
        -: 4166:    "222222222222222222222222222222222222222222222222222222222222222\r\n";
        -: 4167:static const char b4[] =
        -: 4168:    "444444444444444444444444444444444444444444444444444444444444444\r\n"
        -: 4169:    "444444444444444444444444444444444444444444444444444444444444444\r\n"
        -: 4170:    "444444444444444444444444444444444444444444444444444444444444444\r\n"
        -: 4171:    "444444444444444444444444444444444444444444444444444444444444444\r\n"
        -: 4172:    "444444444444444444444444444444444444444444444444444444444444444\r\n"
        -: 4173:    "444444444444444444444444444444444444444444444444444444444444444\r\n"
        -: 4174:    "444444444444444444444444444444444444444444444444444444444444444\r\n"
        -: 4175:    "444444444444444444444444444444444444444444444444444444444444444\r\n"
        -: 4176:    "444444444444444444444444444444444444444444444444444444444444444\r\n"
        -: 4177:    "444444444444444444444444444444444444444444444444444444444444444\r\n"
        -: 4178:    "444444444444444444444444444444444444444444444444444444444444444";
        -: 4179:
        3: 4180:static const char *test_http_multipart_check_res(struct mbuf *res) {
        3: 4181:  const char *ptr = res->buf;
        3: 4182:  ASSERT_STREQ_NZ(ptr, "<MPRQ/test");
        3: 4183:  ptr += 10;
        3: 4184:  ASSERT_STREQ_NZ(ptr, "afoo");
        3: 4185:  ptr += 4;
        3: 4186:  ASSERT_STREQ_NZ(ptr, b1);
        3: 4187:  ptr += sizeof(b1) - 1;
        3: 4188:  ASSERT_STREQ_NZ(ptr, "afooFIN");
        3: 4189:  ptr += 7;
        -: 4190:  /* No file_name for second part */
        3: 4191:  ASSERT_STREQ_NZ(ptr, "b");
        3: 4192:  ptr++;
        3: 4193:  ASSERT_STREQ_NZ(ptr, b2);
        3: 4194:  ptr += sizeof(b2) - 1;
        3: 4195:  ASSERT_STREQ_NZ(ptr, "bFIN");
        3: 4196:  ptr += 4;
        3: 4197:  ASSERT_STREQ_NZ(ptr, "cbar");
        3: 4198:  ptr += 4;
        3: 4199:  ASSERT_STREQ_NZ(ptr, b4);
        3: 4200:  ptr += sizeof(b4) - 1;
        3: 4201:  ASSERT_STREQ_NZ(ptr, "cbarFIN");
        3: 4202:  ptr += 7;
        3: 4203:  ASSERT_STREQ_NZ(ptr, "+11MPRQ>");
        3: 4204:  ptr += 8;
        3: 4205:  ASSERT_EQ((size_t)(ptr - res->buf), res->len);
        3: 4206:  return NULL;
        -: 4207:}
        -: 4208:
        1: 4209:static const char *test_http_multipart2(void) {
        -: 4210:  struct mg_mgr mgr;
        -: 4211:  struct mg_connection *nc_listen;
        -: 4212:
        1: 4213:  const char multi_part_req_fmt[] =
        -: 4214:      "%s"
        -: 4215:      "Content-Disposition: form-data; name=\"a\"; filename=\"foo\"\r\n"
        -: 4216:      "\r\n"
        -: 4217:      "%s"
        -: 4218:      "\r\n--Asrf456BGe4h\r\n"
        -: 4219:      "Content-Disposition: form-data; name=\"b\"\r\n"
        -: 4220:      "\r\n"
        -: 4221:      "%s"
        -: 4222:      "\r\n--Asrf456BGe4h\r\n"
        -: 4223:      "Content-Disposition: form-data; name=\"c\"; filename=\"bar\"\r\n"
        -: 4224:      "\r\n"
        -: 4225:      "%s"
        -: 4226:      "\r\n--Asrf456BGe4h--\r\n"
        -: 4227:      "\r\n";
        -: 4228:
        -: 4229:  char multi_part_req[1024 * 5];
        -: 4230:  int i;
        -: 4231:  struct mg_connection *c;
        -: 4232:  const char *r;
        -: 4233:
        -: 4234:  struct cb_mp_srv_data mpd;
        1: 4235:  memset(&mpd, 0, sizeof(mpd));
        1: 4236:  mbuf_init(&mpd.res, 0);
        -: 4237:
        1: 4238:  mg_mgr_init(&mgr, NULL);
        1: 4239:  nc_listen = mg_bind(&mgr, "8765", cb_mp_srv);
        1: 4240:  nc_listen->user_data = &mpd;
        -: 4241:
        1: 4242:  mg_set_protocol_http_websocket(nc_listen);
        -: 4243:
        1: 4244:  snprintf(multi_part_req, sizeof(multi_part_req), multi_part_req_fmt, "", b1,
        -: 4245:           b2, b4);
        -: 4246:
        1: 4247:  ASSERT((c = mg_connect_http(&mgr, cb_mp_send_one_byte,
        -: 4248:                              "http://127.0.0.1:8765/test",
        -: 4249:                              "Content-Type: "
        -: 4250:                              "multipart/form-data;boundary=Asrf456BGe4h",
        -: 4251:                              "\r\n--Asrf456BGe4h\r\n")) != NULL);
        -: 4252:
        1: 4253:  c->user_data = multi_part_req;
        -: 4254:
        1: 4255:  poll_until(&mgr, 10, c_int_eq, &mpd.request_end, (void *) 1);
        -: 4256:
        1: 4257:  if ((r = test_http_multipart_check_res(&mpd.res)) != NULL) return r;
        -: 4258:
        1: 4259:  mbuf_free(&mpd.res);
        1: 4260:  memset(&mpd, 0, sizeof(mpd));
        1: 4261:  mbuf_init(&mpd.res, 0);
        -: 4262:
        1: 4263:  snprintf(multi_part_req, sizeof(multi_part_req), multi_part_req_fmt,
        -: 4264:           "\r\n--Asrf456BGe4h\r\n", b1, b2, b4);
        -: 4265:
        -: 4266:  /* Testing delivering to endpoint handler*/
        1: 4267:  nc_listen = mg_bind(&mgr, "8766", cb_mp_empty);
        1: 4268:  nc_listen->user_data = &mpd;
        -: 4269:
        1: 4270:  mg_set_protocol_http_websocket(nc_listen);
        1: 4271:  mg_register_http_endpoint(nc_listen, "/test", cb_mp_srv MG_UD_ARG(NULL));
        -: 4272:
        1: 4273:  ASSERT((c = mg_connect_http(&mgr, cb_mp_empty, "http://127.0.0.1:8766/test",
        -: 4274:                              "Connection: keep-alive\r\nContent-Type: "
        -: 4275:                              "multipart/form-data; boundary=Asrf456BGe4h",
        -: 4276:                              multi_part_req)) != NULL);
        -: 4277:
        1: 4278:  poll_until(&mgr, 3, c_int_eq, &mpd.request_end, (void *) 1);
        1: 4279:  mg_mgr_poll(&mgr, 1); /* Consume epilogue. */
        -: 4280:
        1: 4281:  if ((r = test_http_multipart_check_res(&mpd.res)) != NULL) return r;
        -: 4282:
        -: 4283:  /* Keep the connection alive */
        -: 4284:
        1: 4285:  mbuf_free(&mpd.res);
        1: 4286:  memset(&mpd, 0, sizeof(mpd));
        1: 4287:  mbuf_init(&mpd.res, 0);
        -: 4288:
        1: 4289:  mg_printf(c,
        -: 4290:            "POST /test HTTP/1.1\r\nHost: 127.0.0.1:8766\r\nContent-Length: "
        -: 4291:            "%" SIZE_T_FMT
        -: 4292:            "\r\nConnection: keep-alive\r\nContent-Type: multipart/form-data; "
        -: 4293:            "boundary=Asrf456BGe4h\r\n%s",
        -: 4294:            strlen(multi_part_req), multi_part_req);
        -: 4295:
        1: 4296:  poll_until(&mgr, 3, c_int_eq, &mpd.request_end, (void *) 1);
        -: 4297:
        1: 4298:  if ((r = test_http_multipart_check_res(&mpd.res)) != NULL) return r;
        -: 4299:
        1: 4300:  c->flags |= MG_F_CLOSE_IMMEDIATELY;
        -: 4301:
        1: 4302:  mbuf_free(&mpd.res);
        1: 4303:  memset(&mpd, 0, sizeof(mpd));
        1: 4304:  mbuf_init(&mpd.res, 0);
        1: 4305:  mbuf_remove(&c->recv_mbuf, c->recv_mbuf.len);
        -: 4306:
        -: 4307:  /* Test interrupted request */
        1: 4308:  multi_part_req[1800] = '\0';
        1: 4309:  c = mg_connect_http(
        -: 4310:      &mgr, cb_mp_empty, "http://127.0.0.1:8765",
        -: 4311:      "Content-Type: multipart/form-data; boundary=Asrf456BGe4h",
        -: 4312:      multi_part_req);
        -: 4313:
        1: 4314:  ASSERT(c != NULL);
       21: 4315:  for (i = 0; i < 20; i++) {
       20: 4316:    mg_mgr_poll(&mgr, 1);
        -: 4317:  }
        -: 4318:
        1: 4319:  c->flags |= MG_F_CLOSE_IMMEDIATELY;
        -: 4320:
        1: 4321:  poll_until(&mgr, 3, c_int_eq, &mpd.request_end, (void *) 1);
        -: 4322:
        1: 4323:  ASSERT_STREQ_NZ(mpd.res.buf + mpd.res.len - 17, "cbarERROR-11MPRQ>");
        -: 4324:
        1: 4325:  mbuf_free(&mpd.res);
        1: 4326:  memset(&mpd, 0, sizeof(mpd));
        1: 4327:  mbuf_init(&mpd.res, 0);
        -: 4328:
        1: 4329:  ASSERT(
        -: 4330:      mg_connect_http(
        -: 4331:          &mgr, cb_mp_empty, "http://127.0.0.1:8766/test",
        -: 4332:          "Content-Type: multipart/form-data; boundary=Asrf456BGe4h",
        -: 4333:          "\r\n--Asrf456BGe4h\r\n"
        -: 4334:          "Content-Disposition: form-data; name=\"d\"; filename=\"small\"\r\n"
        -: 4335:          "\r\n"
        -: 4336:          "boooo"
        -: 4337:          "\r\n--Asrf456BGe4h--\r\n"
        -: 4338:          "\r\n") != NULL);
        -: 4339:
        1: 4340:  poll_until(&mgr, 3, c_int_eq, &mpd.request_end, (void *) 1);
        -: 4341:
        1: 4342:  ASSERT(mpd.res.len != 0);
        1: 4343:  ASSERT_STREQ_NZ(mpd.res.buf, "<MPRQ/testdsmallboooodsmallFIN+11MPRQ>");
        1: 4344:  mbuf_free(&mpd.res);
        -: 4345:
        -: 4346:  /*
        -: 4347:   * Test malformed packet
        -: 4348:   * See https://github.com/cesanta/dev/issues/6974
        -: 4349:   * This request should not lead to crash
        -: 4350:   */
        1: 4351:  c = mg_connect(&mgr, "127.0.0.1:8766", cb_mp_empty);
        1: 4352:  mg_printf(c,
        -: 4353:            "POST /test HTTP/1.1\r\n"
        -: 4354:            "Connection: keep-alive\r\n"
        -: 4355:            "Content-Type: multipart/form-data; Content-Length: 1\r\n"
        -: 4356:            "1\r\n\r\n");
       21: 4357:  for (i = 0; i < 20; i++) {
       20: 4358:    mg_mgr_poll(&mgr, 1);
        -: 4359:  }
        -: 4360:
        1: 4361:  mg_mgr_free(&mgr);
        -: 4362:
        1: 4363:  return NULL;
        -: 4364:}
        -: 4365:
        1: 4366:static const char *test_http_multipart_pipeline(void) {
        -: 4367:  struct mg_mgr mgr;
        -: 4368:  struct mg_connection *nc_listen;
        -: 4369:
        1: 4370:  const char multi_part_req_fmt[] =
        -: 4371:      "%s"
        -: 4372:      "Content-Disposition: form-data; name=\"a\"; filename=\"foo\"\r\n"
        -: 4373:      "\r\n"
        -: 4374:      "%s"
        -: 4375:      "\r\n--Asrf456BGe4h\r\n"
        -: 4376:      "Content-Disposition: form-data; name=\"b\"\r\n"
        -: 4377:      "\r\n"
        -: 4378:      "%s"
        -: 4379:      "\r\n--Asrf456BGe4h\r\n"
        -: 4380:      "Content-Disposition: form-data; name=\"c\"; filename=\"bar\"\r\n"
        -: 4381:      "\r\n"
        -: 4382:      "%s"
        -: 4383:      "\r\n--Asrf456BGe4h--\r\n"
        -: 4384:      "\r\n";
        -: 4385:
        -: 4386:  char multi_part_req[1024 * 5];
        -: 4387:  struct mg_connection *c;
        -: 4388:  const char *ptr;
        -: 4389:  int i;
        -: 4390:
        -: 4391:  struct cb_mp_srv_data mpd;
        1: 4392:  memset(&mpd, 0, sizeof(mpd));
        1: 4393:  mbuf_init(&mpd.res, 0);
        -: 4394:
        1: 4395:  mg_mgr_init(&mgr, NULL);
        1: 4396:  nc_listen = mg_bind(&mgr, "8765", cb_mp_srv);
        1: 4397:  nc_listen->user_data = &mpd;
        -: 4398:
        1: 4399:  mg_set_protocol_http_websocket(nc_listen);
        -: 4400:
        1: 4401:  snprintf(multi_part_req, sizeof(multi_part_req), multi_part_req_fmt,
        -: 4402:           "\r\n--Asrf456BGe4h\r\n", b1, b2, b4);
        -: 4403:
        1: 4404:  ASSERT((c = mg_connect_http(&mgr, cb_mp_empty, "http://127.0.0.1:8765/test",
        -: 4405:                              "Content-Type: "
        -: 4406:                              "multipart/form-data;boundary=Asrf456BGe4h\r\n"
        -: 4407:                              "Connection: keep-alive",
        -: 4408:                              multi_part_req)) != NULL);
        -: 4409:
        1: 4410:  c->user_data = multi_part_req;
        -: 4411:
        1: 4412:  mg_printf(c,
        -: 4413:            "POST /test HTTP/1.1\r\n"
        -: 4414:            "Connection: keep-alive\r\n"
        -: 4415:            "Content-Type: multipart/form-data;boundary=Asrf456BGe4h\r\n"
        -: 4416:            "Content-Length: %d\r\n%s",
        1: 4417:            (int) strlen(multi_part_req), multi_part_req);
        -: 4418:
        1: 4419:  poll_until(&mgr, 10, c_int_eq, &mpd.request_end, (void *) 1);
        -: 4420:
        1: 4421:  ptr = mpd.res.buf;
        3: 4422:  for (i = 0; i < 2; i++) {
        2: 4423:    ASSERT_STREQ_NZ(ptr, "<MPRQ/test");
        2: 4424:    ptr += 10;
        2: 4425:    ASSERT_STREQ_NZ(ptr, "afoo");
        2: 4426:    ptr += 4;
        2: 4427:    ASSERT_STREQ_NZ(ptr, b1);
        2: 4428:    ptr += sizeof(b1) - 1;
        2: 4429:    ASSERT_STREQ_NZ(ptr, "afooFIN");
        2: 4430:    ptr += 7;
        -: 4431:    /* No file_name for second part */
        2: 4432:    ASSERT_STREQ_NZ(ptr, "b");
        2: 4433:    ptr++;
        2: 4434:    ASSERT_STREQ_NZ(ptr, b2);
        2: 4435:    ptr += sizeof(b2) - 1;
        2: 4436:    ASSERT_STREQ_NZ(ptr, "bFIN");
        2: 4437:    ptr += 4;
        2: 4438:    ASSERT_STREQ_NZ(ptr, "cbar");
        2: 4439:    ptr += 4;
        2: 4440:    ASSERT_STREQ_NZ(ptr, b4);
        2: 4441:    ptr += sizeof(b4) - 1;
        2: 4442:    ASSERT_STREQ_NZ(ptr, "cbarFIN");
        2: 4443:    ptr += 7;
        2: 4444:    ASSERT_STREQ_NZ(ptr, "+11MPRQ>");
        2: 4445:    ptr += 8;
        -: 4446:  }
        1: 4447:  ASSERT_EQ((size_t)(ptr - mpd.res.buf), mpd.res.len);
        -: 4448:
        1: 4449:  mbuf_free(&mpd.res);
        1: 4450:  mg_mgr_free(&mgr);
        -: 4451:
        1: 4452:  return NULL;
        -: 4453:}
        -: 4454:
        3: 4455:static struct mg_str upload_lfn_same(struct mg_connection *nc,
        -: 4456:                                     struct mg_str fn) {
        3: 4457:  if (fn.len == 0) {
        1: 4458:    fn = mg_strdup(mg_mk_str("bar"));
        -: 4459:  }
        -: 4460:  (void) nc;
        3: 4461:  return fn;
        -: 4462:}
        -: 4463:
     6801: 4464:static void cb_mp_srv_upload(struct mg_connection *nc, int ev, void *p) {
     6801: 4465:  mg_file_upload_handler(nc, ev, p, upload_lfn_same);
     6801: 4466:  if (ev == MG_EV_CLOSE && nc->listener != NULL) {
        1: 4467:    *((int *) nc->listener->user_data) = 1;
        -: 4468:  }
        -: 4469:  (void) p;
     6801: 4470:}
        -: 4471:
        1: 4472:static const char *test_http_multipart_upload(void) {
        -: 4473:  struct mg_mgr mgr;
        1: 4474:  const char req_fmt[] =
        -: 4475:      "%s"
        -: 4476:      "Content-Disposition: form-data; name=\"a\"; filename=\"foo\"\r\n"
        -: 4477:      "\r\n"
        -: 4478:      "%s"
        -: 4479:      "\r\n--Asrf456BGe4h\r\n"
        -: 4480:      "Content-Disposition: form-data; name=\"b\"\r\n"
        -: 4481:      "\r\n"
        -: 4482:      "%s"
        -: 4483:      "\r\n--Asrf456BGe4h\r\n"
        -: 4484:      "Content-Disposition: form-data; name=\"c\"; filename=\"baz\"\r\n"
        -: 4485:      "\r\n"
        -: 4486:      "%s"
        -: 4487:      "\r\n--Asrf456BGe4h--\r\n"
        -: 4488:      "\r\n";
        -: 4489:
        -: 4490:  char req[1024 * 5], *data;
        -: 4491:  struct mg_connection *c, *lc;
        -: 4492:  size_t size;
        1: 4493:  int done = 0;
        -: 4494:
        1: 4495:  mg_mgr_init(&mgr, NULL);
        1: 4496:  lc = mg_bind(&mgr, "8766", cb_mp_srv_upload);
        1: 4497:  mg_set_protocol_http_websocket(lc);
        1: 4498:  lc->user_data = &done;
        -: 4499:
        1: 4500:  (void) remove("foo");
        1: 4501:  (void) remove("bar");
        1: 4502:  (void) remove("baz");
        -: 4503:
        1: 4504:  snprintf(req, sizeof(req), req_fmt, "", b1, b2, b4);
        -: 4505:
        1: 4506:  ASSERT((c = mg_connect_http(&mgr, cb_mp_send_one_byte,
        -: 4507:                              "http://127.0.0.1:8766/test",
        -: 4508:                              "Content-Type: "
        -: 4509:                              "multipart/form-data;boundary=Asrf456BGe4h",
        -: 4510:                              "\r\n--Asrf456BGe4h\r\n")) != NULL);
        1: 4511:  c->user_data = req;
        -: 4512:
        1: 4513:  poll_until(&mgr, 5, c_int_eq, &done, (void *) 1);
        -: 4514:
        1: 4515:  data = read_file("foo", &size);
        1: 4516:  ASSERT_PTRNE(data, NULL);
        1: 4517:  ASSERT_STREQ_NZ(data, b1);
        1: 4518:  (void) remove("foo");
        1: 4519:  free(data);
        -: 4520:
        1: 4521:  data = read_file("bar", &size);
        1: 4522:  ASSERT_PTRNE(data, NULL);
        1: 4523:  ASSERT_STREQ_NZ(data, b2);
        1: 4524:  (void) remove("bar");
        1: 4525:  free(data);
        -: 4526:
        1: 4527:  data = read_file("baz", &size);
        1: 4528:  ASSERT_PTRNE(data, NULL);
        1: 4529:  ASSERT_STREQ_NZ(data, b4);
        1: 4530:  (void) remove("baz");
        1: 4531:  free(data);
        -: 4532:
        1: 4533:  mg_mgr_free(&mgr);
        1: 4534:  return NULL;
        -: 4535:}
        -: 4536:
        -: 4537:#endif /* MG_ENABLE_HTTP_STREAMING_MULTIPART */
        -: 4538:
        1: 4539:static const char *test_http_multipart(void) {
        -: 4540:  struct http_message hm;
        1: 4541:  char buf[FETCH_BUF_SIZE] = "", var_name[100], file_name[100];
        -: 4542:  const char *chunk;
        -: 4543:  size_t chunk_len, ofs;
        -: 4544:
        1: 4545:  fetch_http(buf, "%s", "GET /data/multipart.txt HTTP/1.0\r\n\r\n");
        1: 4546:  mg_parse_http(buf, strlen(buf), &hm, 1);
        -: 4547:
        1: 4548:  ofs = mg_parse_multipart(hm.body.p, hm.body.len, var_name, sizeof(var_name),
        -: 4549:                           file_name, sizeof(file_name), &chunk, &chunk_len);
        1: 4550:  ASSERT(ofs < hm.body.len);
        1: 4551:  ASSERT(ofs > 0);
        1: 4552:  ASSERT_EQ(chunk_len, 10);
        1: 4553:  ASSERT_EQ(memcmp(chunk, "file1 data", chunk_len), 0);
        -: 4554:
        1: 4555:  ofs = mg_parse_multipart(hm.body.p + ofs, hm.body.len - ofs, var_name,
        -: 4556:                           sizeof(var_name), file_name, sizeof(file_name),
        -: 4557:                           &chunk, &chunk_len);
        1: 4558:  ASSERT(ofs < hm.body.len);
        1: 4559:  ASSERT(ofs > 0);
        1: 4560:  ASSERT_EQ(chunk_len, 10);
        1: 4561:  ASSERT_EQ(memcmp(chunk, "file2 data", chunk_len), 0);
        -: 4562:
        1: 4563:  ofs = mg_parse_multipart(hm.body.p + ofs, hm.body.len - ofs, var_name,
        -: 4564:                           sizeof(var_name), file_name, sizeof(file_name),
        -: 4565:                           &chunk, &chunk_len);
        1: 4566:  ASSERT(ofs == 0);
        -: 4567:
        1: 4568:  return NULL;
        -: 4569:}
        -: 4570:
        1: 4571:static const char *test_dns_encode(void) {
        -: 4572:  struct mg_connection nc;
        -: 4573:  const char *got;
        1: 4574:  int query_types[] = {MG_DNS_A_RECORD, MG_DNS_AAAA_RECORD};
        -: 4575:  size_t i;
        1: 4576:  init_test_connection(&nc);
        -: 4577:
        -: 4578:  /*
        -: 4579:   * Testing TCP encoding since when the connection
        -: 4580:   * is in UDP mode the data is not stored in the send buffer.
        -: 4581:   */
        -: 4582:
        3: 4583:  for (i = 0; i < ARRAY_SIZE(query_types); i++) {
        2: 4584:    mg_send_dns_query(&nc, "www.cesanta.com", query_types[i]);
        2: 4585:    got = nc.send_mbuf.buf;
        2: 4586:    ASSERT_EQ(nc.send_mbuf.len, 12 + 4 + 13 + 4 + 2);
        2: 4587:    ASSERT_EQ(got[14], 3);
        2: 4588:    ASSERT_STREQ_NZ(&got[15], "www");
        2: 4589:    ASSERT_EQ(got[18], 7);
        2: 4590:    ASSERT_STREQ_NZ(&got[19], "cesanta");
        2: 4591:    ASSERT_EQ(got[26], 3);
        2: 4592:    ASSERT_STREQ_NZ(&got[27], "com");
        2: 4593:    ASSERT_EQ(got[30], 0);
        2: 4594:    ASSERT_EQ(got[31], 0);
        2: 4595:    ASSERT_EQ(got[32], query_types[i]);
        2: 4596:    ASSERT_EQ(got[33], 0);
        2: 4597:    ASSERT_EQ(got[34], 1);
        -: 4598:
        2: 4599:    mbuf_free(&nc.send_mbuf);
        -: 4600:  }
        1: 4601:  return NULL;
        -: 4602:}
        -: 4603:
        1: 4604:static const char *test_dns_uncompress(void) {
        -: 4605:  /*
        -: 4606:   * Order or string constants is important. Names being uncompressed
        -: 4607:   * must be before the end of the DNS packet end.
        -: 4608:   */
        1: 4609:  const char *s =
        -: 4610:      "\03www\07cesanta\03com\0\03www\xc0\06\05dummy\07cesanta\3com\0";
        -: 4611:  struct mg_dns_message msg;
        1: 4612:  struct mg_str name = mg_mk_str(s);
        1: 4613:  struct mg_str comp_name = mg_mk_str_n(s + 17, 6);
        -: 4614:  struct mg_str n;
        -: 4615:  char dst[256];
        -: 4616:  int len;
        -: 4617:  size_t i;
        -: 4618:
        1: 4619:  const char *cases[] = {"www.cesanta.com", "www", "ww", "www.", "www.c"};
        -: 4620:
        1: 4621:  memset(&msg, 0, sizeof(msg));
        1: 4622:  msg.pkt.p = s + 23;
        1: 4623:  msg.pkt.len = strlen(msg.pkt.p) + 1;
        -: 4624:
        1: 4625:  memset(dst, 'X', sizeof(dst));
        1: 4626:  n = mg_mk_str_n(msg.pkt.p, msg.pkt.len);
        1: 4627:  len = mg_dns_uncompress_name(&msg, &n, dst, sizeof(dst));
        1: 4628:  ASSERT_EQ(len, 17);
        1: 4629:  ASSERT_EQ(len, (int) strlen(dst));
        1: 4630:  ASSERT_STREQ_NZ(dst, "dummy.cesanta.com");
        -: 4631:
        6: 4632:  for (i = 0; i < ARRAY_SIZE(cases); i++) {
        5: 4633:    size_t l = strlen(cases[i]);
        5: 4634:    memset(dst, 'X', sizeof(dst));
        5: 4635:    len = mg_dns_uncompress_name(&msg, &name, dst, l);
        5: 4636:    ASSERT_EQ(len, (int) l);
        5: 4637:    ASSERT_EQ(strncmp(dst, cases[i], l), 0);
        5: 4638:    ASSERT_EQ(dst[l], 'X');
        -: 4639:  }
        -: 4640:
        -: 4641:  /* if dst has enough space, check the trailing '\0' */
        1: 4642:  memset(dst, 'X', sizeof(dst));
        1: 4643:  len = mg_dns_uncompress_name(&msg, &name, dst, sizeof(dst));
        1: 4644:  ASSERT_EQ(len, 15);
        1: 4645:  ASSERT_EQ(len, (int) strlen(dst));
        1: 4646:  ASSERT_STREQ_NZ(dst, "www.cesanta.com");
        1: 4647:  ASSERT_EQ(dst[15], 0);
        -: 4648:
        -: 4649:  /* check compressed name */
        1: 4650:  memset(dst, 'X', sizeof(dst));
        1: 4651:  len = mg_dns_uncompress_name(&msg, &comp_name, dst, sizeof(dst));
        1: 4652:  printf("%d [%s]\n", len, dst);
        1: 4653:  ASSERT_EQ(len, 15);
        1: 4654:  ASSERT_EQ(len, (int) strlen(dst));
        1: 4655:  ASSERT_STREQ_NZ(dst, "www.cesanta.com");
        1: 4656:  ASSERT_EQ(dst[15], 0);
        -: 4657:
        -: 4658:  /* check parsing loop avoidance */
        1: 4659:  msg.pkt.p = "\05dummy\xc0\x06\0";
        1: 4660:  msg.pkt.len = strlen(msg.pkt.p) + 1;
        1: 4661:  memset(dst, 'X', sizeof(dst));
        1: 4662:  len = mg_dns_uncompress_name(&msg, &comp_name, dst, sizeof(dst));
        1: 4663:  ASSERT_EQ(len, 0);
        -: 4664:
        1: 4665:  return NULL;
        -: 4666:}
        -: 4667:
        1: 4668:static const char *test_dns_decode(void) {
        -: 4669:  struct mg_dns_message msg;
        -: 4670:  char name[256];
        1: 4671:  const char *hostname = "go.cesanta.com";
        1: 4672:  const char *cname = "ghs.googlehosted.com";
        -: 4673:  struct mg_dns_resource_record *r;
        -: 4674:  uint16_t tiny;
        -: 4675:  struct in_addr ina;
        -: 4676:  int n;
        -: 4677:
        -: 4678:  /*
        -: 4679:   * Response for a record A query host for `go.cesanta.com`.
        -: 4680:   * The response contains two answers:
        -: 4681:   *
        -: 4682:   * CNAME go.cesanta.com -> ghs.googlehosted.com
        -: 4683:   * A ghs.googlehosted.com -> 74.125.136.121
        -: 4684:   *
        -: 4685:   * Captured from a reply generated by Google DNS server (8.8.8.8)
        -: 4686:   */
        1: 4687:  const unsigned char pkt[] = {
        -: 4688:      0xa1, 0x00, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
        -: 4689:      0x02, 0x67, 0x6f, 0x07, 0x63, 0x65, 0x73, 0x61, 0x6e, 0x74, 0x61, 0x03,
        -: 4690:      0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x05,
        -: 4691:      0x00, 0x01, 0x00, 0x00, 0x09, 0x52, 0x00, 0x13, 0x03, 0x67, 0x68, 0x73,
        -: 4692:      0x0c, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x68, 0x6f, 0x73, 0x74, 0x65,
        -: 4693:      0x64, 0xc0, 0x17, 0xc0, 0x2c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01,
        -: 4694:      0x2b, 0x00, 0x04, 0x4a, 0x7d, 0x88, 0x79};
        -: 4695:
        1: 4696:  ASSERT_EQ(mg_parse_dns((const char *) pkt, sizeof(pkt), &msg), 0);
        1: 4697:  ASSERT_EQ(msg.num_questions, 1);
        1: 4698:  ASSERT_EQ(msg.num_answers, 2);
        -: 4699:
        1: 4700:  r = &msg.questions[0];
        1: 4701:  ASSERT_EQ(mg_dns_uncompress_name(&msg, &r->name, name, sizeof(name)),
        -: 4702:            strlen(hostname));
        1: 4703:  ASSERT_EQ(strncmp(name, hostname, strlen(hostname)), 0);
        -: 4704:
        1: 4705:  r = &msg.answers[0];
        1: 4706:  ASSERT_EQ(mg_dns_uncompress_name(&msg, &r->name, name, sizeof(name)),
        -: 4707:            strlen(hostname));
        1: 4708:  ASSERT_EQ(strncmp(name, hostname, strlen(hostname)), 0);
        -: 4709:
        1: 4710:  ASSERT_EQ(mg_dns_uncompress_name(&msg, &r->rdata, name, sizeof(name)),
        -: 4711:            strlen(cname));
        1: 4712:  ASSERT_EQ(strncmp(name, cname, strlen(cname)), 0);
        -: 4713:
        1: 4714:  r = &msg.answers[1];
        1: 4715:  ASSERT_EQ(mg_dns_uncompress_name(&msg, &r->name, name, sizeof(name)),
        -: 4716:            strlen(cname));
        1: 4717:  ASSERT_EQ(strncmp(name, cname, strlen(cname)), 0);
        1: 4718:  ASSERT_EQ(mg_dns_parse_record_data(&msg, r, &tiny, sizeof(tiny)), -1);
        1: 4719:  ASSERT_EQ(mg_dns_parse_record_data(&msg, r, &ina, sizeof(ina)), 0);
        1: 4720:  ASSERT_EQ(ina.s_addr, inet_addr("74.125.136.121"));
        -: 4721:
        -: 4722:  /* Test iteration */
        1: 4723:  n = 0;
        1: 4724:  r = NULL;
        3: 4725:  while ((r = mg_dns_next_record(&msg, MG_DNS_A_RECORD, r))) {
        1: 4726:    n++;
        -: 4727:  }
        1: 4728:  ASSERT_EQ(n, 1);
        -: 4729:
        1: 4730:  n = 0;
        1: 4731:  r = NULL;
        3: 4732:  while ((r = mg_dns_next_record(&msg, MG_DNS_CNAME_RECORD, r))) {
        1: 4733:    n++;
        -: 4734:  }
        1: 4735:  ASSERT_EQ(n, 1);
        -: 4736:
        -: 4737:  /* Test unknown record type */
        1: 4738:  r = mg_dns_next_record(&msg, MG_DNS_A_RECORD, r);
        1: 4739:  r->rtype = 0xff;
        1: 4740:  ASSERT_EQ(mg_dns_parse_record_data(&msg, r, &ina, sizeof(ina)), -1);
        -: 4741:
        1: 4742:  return NULL;
        -: 4743:}
        -: 4744:
        1: 4745:static const char *test_dns_decode_truncated(void) {
        -: 4746:  struct mg_dns_message msg;
        -: 4747:  char name[256];
        1: 4748:  const char *hostname = "go.cesanta.com";
        1: 4749:  const char *cname = "ghs.googlehosted.com";
        -: 4750:  struct mg_dns_resource_record *r;
        -: 4751:  uint16_t tiny;
        -: 4752:  struct in_addr ina;
        -: 4753:  int n;
        -: 4754:  int i;
        -: 4755:
        1: 4756:  const unsigned char src[] = {
        -: 4757:      0xa1, 0x00, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
        -: 4758:      0x02, 0x67, 0x6f, 0x07, 0x63, 0x65, 0x73, 0x61, 0x6e, 0x74, 0x61, 0x03,
        -: 4759:      0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x05,
        -: 4760:      0x00, 0x01, 0x00, 0x00, 0x09, 0x52, 0x00, 0x13, 0x03, 0x67, 0x68, 0x73,
        -: 4761:      0x0c, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x68, 0x6f, 0x73, 0x74, 0x65,
        -: 4762:      0x64, 0xc0, 0x17, 0xc0, 0x2c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01,
        -: 4763:      0x2b, 0x00, 0x04, 0x4a, 0x7d, 0x88, 0x79};
        1: 4764:  char *pkt = NULL;
        -: 4765:
        -: 4766:#define WONDER(expr) \
        -: 4767:  if (!(expr)) continue
        -: 4768:
       79: 4769:  for (i = sizeof(src) - 1; i > 0; i--) {
       78: 4770:    free(pkt);
       78: 4771:    pkt = (char *) malloc(i);
       78: 4772:    memcpy(pkt, src, i);
        -: 4773:
       78: 4774:    WONDER(mg_parse_dns((const char *) pkt, i, &msg) == 0);
        3: 4775:    WONDER(msg.num_questions == 1);
        3: 4776:    WONDER(msg.num_answers == 2);
        -: 4777:
        3: 4778:    r = &msg.questions[0];
        3: 4779:    WONDER(mg_dns_uncompress_name(&msg, &r->name, name, sizeof(name)) ==
        -: 4780:           strlen(hostname));
        3: 4781:    WONDER(strncmp(name, hostname, strlen(hostname)) == 0);
        -: 4782:
        3: 4783:    r = &msg.answers[0];
        3: 4784:    WONDER(mg_dns_uncompress_name(&msg, &r->name, name, sizeof(name)) ==
        -: 4785:           strlen(hostname));
        3: 4786:    WONDER(strncmp(name, hostname, strlen(hostname)) == 0);
        -: 4787:
        3: 4788:    WONDER(mg_dns_uncompress_name(&msg, &r->rdata, name, sizeof(name)) ==
        -: 4789:           strlen(cname));
        3: 4790:    WONDER(strncmp(name, cname, strlen(cname)) == 0);
        -: 4791:
        3: 4792:    r = &msg.answers[1];
        3: 4793:    WONDER(mg_dns_uncompress_name(&msg, &r->name, name, sizeof(name)) ==
        -: 4794:           strlen(cname));
        3: 4795:    WONDER(strncmp(name, cname, strlen(cname)) == 0);
        3: 4796:    WONDER(mg_dns_parse_record_data(&msg, r, &tiny, sizeof(tiny)) == -1);
        3: 4797:    WONDER(mg_dns_parse_record_data(&msg, r, &ina, sizeof(ina)) == 0);
    #####: 4798:    WONDER(ina.s_addr == inet_addr("74.125.136.121"));
        -: 4799:
        -: 4800:    /* Test iteration */
    #####: 4801:    n = 0;
    #####: 4802:    r = NULL;
    #####: 4803:    while ((r = mg_dns_next_record(&msg, MG_DNS_A_RECORD, r))) {
    #####: 4804:      n++;
        -: 4805:    }
    #####: 4806:    WONDER(n == 1);
        -: 4807:
    #####: 4808:    n = 0;
    #####: 4809:    r = NULL;
    #####: 4810:    while ((r = mg_dns_next_record(&msg, MG_DNS_CNAME_RECORD, r))) {
    #####: 4811:      n++;
        -: 4812:    }
    #####: 4813:    WONDER(n == 1);
        -: 4814:
        -: 4815:    /* Test unknown record type */
    #####: 4816:    r = mg_dns_next_record(&msg, MG_DNS_A_RECORD, r);
    #####: 4817:    WONDER(r != NULL);
    #####: 4818:    printf("GOT %p\n", (void *) r);
    #####: 4819:    r->rtype = 0xff;
    #####: 4820:    WONDER(mg_dns_parse_record_data(&msg, r, &ina, sizeof(ina)) == -1);
        -: 4821:
    #####: 4822:    ASSERT("Should have failed" == NULL);
        -: 4823:  }
        1: 4824:  free(pkt);
        1: 4825:  return NULL;
        -: 4826:}
        -: 4827:
        2: 4828:static const char *check_www_cesanta_com_reply(const char *pkt, size_t len) {
        -: 4829:  char name[256];
        -: 4830:
        2: 4831:  in_addr_t addr = inet_addr("54.194.65.250");
        -: 4832:  struct in_addr ina;
        -: 4833:  struct mg_dns_message msg;
        -: 4834:
        2: 4835:  memset(&msg, 0, sizeof(msg));
        2: 4836:  ASSERT(mg_parse_dns(pkt, len, &msg) != -1);
        -: 4837:
        2: 4838:  memset(name, 0, sizeof(name));
        2: 4839:  ASSERT(mg_dns_uncompress_name(&msg, &msg.questions[0].name, name,
        -: 4840:                                sizeof(name)) > 0);
        2: 4841:  ASSERT_STREQ_NZ(name, "www.cesanta.com");
        2: 4842:  memset(name, 0, sizeof(name));
        2: 4843:  ASSERT(mg_dns_uncompress_name(&msg, &msg.answers[0].name, name,
        -: 4844:                                sizeof(name)) > 0);
        2: 4845:  ASSERT_STREQ_NZ(name, "www.cesanta.com");
        2: 4846:  ASSERT_EQ(msg.answers[0].rtype, MG_DNS_CNAME_RECORD);
        2: 4847:  memset(name, 0, sizeof(name));
        2: 4848:  ASSERT(mg_dns_parse_record_data(&msg, &msg.answers[0], name, sizeof(name)) !=
        -: 4849:         -1);
        2: 4850:  ASSERT_STREQ_NZ(name, "cesanta.com");
        2: 4851:  memset(name, 0, sizeof(name));
        2: 4852:  ASSERT(mg_dns_uncompress_name(&msg, &msg.answers[1].name, name,
        -: 4853:                                sizeof(name)) > 0);
        2: 4854:  ASSERT_STREQ_NZ(name, "cesanta.com");
        -: 4855:
        2: 4856:  ASSERT_EQ(msg.answers[1].rtype, MG_DNS_A_RECORD);
        2: 4857:  ASSERT(mg_dns_parse_record_data(&msg, &msg.answers[1], &ina, sizeof(ina)) !=
        -: 4858:         -1);
        2: 4859:  ASSERT_EQ(ina.s_addr, addr);
        -: 4860:
        2: 4861:  return NULL;
        -: 4862:}
        -: 4863:
        1: 4864:static const char *test_dns_reply_encode(void) {
        -: 4865:  const char *err;
        -: 4866:  struct mg_dns_message msg;
        -: 4867:  struct mg_dns_resource_record *rr;
        -: 4868:  char name[256];
        1: 4869:  in_addr_t addr = inet_addr("54.194.65.250");
        -: 4870:  struct mbuf pkt;
        -: 4871:  struct mg_connection nc;
        -: 4872:
        1: 4873:  mbuf_init(&pkt, 0);
        1: 4874:  init_test_connection(&nc);
        -: 4875:
        -: 4876:  /* create a fake query */
        -: 4877:
        1: 4878:  mg_send_dns_query(&nc, "www.cesanta.com", MG_DNS_A_RECORD);
        -: 4879:  /* remove message length from tcp buffer */
        1: 4880:  mbuf_remove(&nc.send_mbuf, 2);
        -: 4881:
        1: 4882:  ASSERT_EQ(mg_parse_dns(nc.send_mbuf.buf, nc.send_mbuf.len, &msg), 0);
        -: 4883:
        -: 4884:  /* build an answer */
        -: 4885:
        1: 4886:  msg.num_answers = 2;
        1: 4887:  mg_dns_insert_header(&pkt, 0, &msg);
        1: 4888:  mg_dns_copy_questions(&pkt, &msg);
        -: 4889:
        1: 4890:  mg_dns_uncompress_name(&msg, &msg.questions[0].name, name, sizeof(name));
        -: 4891:
        1: 4892:  rr = &msg.answers[0];
        1: 4893:  *rr = msg.questions[0];
        1: 4894:  rr->rtype = MG_DNS_CNAME_RECORD;
        1: 4895:  rr->ttl = 3600;
        1: 4896:  rr->kind = MG_DNS_ANSWER;
        1: 4897:  ASSERT(mg_dns_encode_record(&pkt, rr, "www.cesanta.com", 15,
        -: 4898:                              (void *) "cesanta.com", 11) != -1);
        -: 4899:
        1: 4900:  rr = &msg.answers[1];
        1: 4901:  *rr = msg.questions[0];
        1: 4902:  rr->ttl = 3600;
        1: 4903:  rr->kind = MG_DNS_ANSWER;
        1: 4904:  ASSERT(mg_dns_encode_record(&pkt, rr, "cesanta.com", 11, &addr, 4) != -1);
        -: 4905:
        1: 4906:  if ((err = check_www_cesanta_com_reply(pkt.buf, pkt.len)) != NULL) {
    #####: 4907:    return err;
        -: 4908:  }
        -: 4909:
        1: 4910:  mbuf_free(&pkt);
        1: 4911:  mbuf_free(&nc.send_mbuf);
        1: 4912:  return NULL;
        -: 4913:}
        -: 4914:
        -: 4915:#if MG_ENABLE_DNS_SERVER
        5: 4916:static void dns_server_eh(struct mg_connection *nc, int ev, void *ev_data) {
        -: 4917:  struct mg_dns_message *msg;
        -: 4918:  struct mg_dns_resource_record *rr;
        -: 4919:  struct mg_dns_reply reply;
        -: 4920:  char name[512];
        -: 4921:  int i;
        -: 4922:
        5: 4923:  name[511] = 0;
        5: 4924:  switch (ev) {
        2: 4925:    case MG_DNS_MESSAGE:
        2: 4926:      msg = (struct mg_dns_message *) ev_data;
        2: 4927:      reply = mg_dns_create_reply(&nc->send_mbuf, msg);
        -: 4928:
        4: 4929:      for (i = 0; i < msg->num_questions; i++) {
        2: 4930:        rr = &msg->questions[i];
        2: 4931:        if (rr->rtype == MG_DNS_A_RECORD) {
        2: 4932:          mg_dns_uncompress_name(msg, &rr->name, name, sizeof(name) - 1);
        -: 4933:
        2: 4934:          if (strcmp(name, "cesanta.com") == 0) {
        1: 4935:            mg_dns_reply_record(&reply, rr, NULL, rr->rtype, 3600,
        1: 4936:                                nc->user_data, 4);
        1: 4937:          } else if (strcmp(name, "www.cesanta.com") == 0) {
        1: 4938:            mg_dns_reply_record(&reply, rr, NULL, MG_DNS_CNAME_RECORD, 3600,
        -: 4939:                                "cesanta.com", strlen("cesanta.com"));
        -: 4940:
        1: 4941:            mg_dns_reply_record(&reply, rr, "cesanta.com", rr->rtype, 3600,
        1: 4942:                                nc->user_data, 4);
        -: 4943:          }
        -: 4944:        }
        -: 4945:      }
        -: 4946:
        -: 4947:      /*
        -: 4948:       * We don't set the error flag even if there were no answers
        -: 4949:       * maching the MG_DNS_A_RECORD query type.
        -: 4950:       * This indicates that we have (syntetic) answers for MG_DNS_A_RECORD.
        -: 4951:       * See http://goo.gl/QWvufr for a distinction between NXDOMAIN and NODATA.
        -: 4952:       */
        -: 4953:
        2: 4954:      mg_dns_send_reply(nc, &reply);
        2: 4955:      nc->flags |= MG_F_SEND_AND_CLOSE;
        2: 4956:      break;
        -: 4957:  }
        5: 4958:}
        -: 4959:
        1: 4960:static int check_record_name(struct mg_dns_message *msg, struct mg_str *n,
        -: 4961:                             const char *want) {
        -: 4962:  char name[512];
        1: 4963:  if (mg_dns_uncompress_name(msg, n, name, sizeof(name)) == 0) {
    #####: 4964:    return 0;
        -: 4965:  }
        1: 4966:  return strncmp(name, want, sizeof(name)) == 0;
        -: 4967:}
        -: 4968:
        1: 4969:static const char *test_dns_server(void) {
        -: 4970:  const char *err;
        -: 4971:  struct mg_connection nc;
        -: 4972:  struct mg_dns_message msg;
        1: 4973:  in_addr_t addr = inet_addr("54.194.65.250");
        -: 4974:  int ilen;
        -: 4975:
        1: 4976:  init_test_connection(&nc);
        -: 4977:
        1: 4978:  nc.handler = dns_server_eh;
        1: 4979:  nc.user_data = &addr;
        1: 4980:  mg_set_protocol_dns(&nc);
        -: 4981:
        1: 4982:  mg_send_dns_query(&nc, "www.cesanta.com", MG_DNS_A_RECORD);
        -: 4983:
        1: 4984:  nc.recv_mbuf = nc.send_mbuf;
        1: 4985:  mbuf_init(&nc.send_mbuf, 0);
        -: 4986:
        1: 4987:  ilen = nc.recv_mbuf.len;
        1: 4988:  nc.proto_handler(&nc, MG_EV_RECV, &ilen);
        1: 4989:  mbuf_free(&nc.recv_mbuf);
        -: 4990:  /* remove message length from tcp buffer before manually checking */
        1: 4991:  mbuf_remove(&nc.send_mbuf, 2);
        -: 4992:
        1: 4993:  if ((err = check_www_cesanta_com_reply(nc.send_mbuf.buf, nc.send_mbuf.len)) !=
        -: 4994:      NULL) {
    #####: 4995:    mbuf_free(&nc.send_mbuf);
    #####: 4996:    return err;
        -: 4997:  }
        -: 4998:
        1: 4999:  mbuf_free(&nc.send_mbuf);
        -: 5000:
        -: 5001:  /* test mg_dns_reply_record */
        1: 5002:  mg_send_dns_query(&nc, "cesanta.com", MG_DNS_A_RECORD);
        -: 5003:
        1: 5004:  nc.recv_mbuf = nc.send_mbuf;
        1: 5005:  mbuf_init(&nc.send_mbuf, 0);
        -: 5006:
        1: 5007:  ilen = nc.recv_mbuf.len;
        1: 5008:  nc.proto_handler(&nc, MG_EV_RECV, &ilen);
        -: 5009:  /* remove message length from tcp buffer before manually checking */
        1: 5010:  mbuf_remove(&nc.send_mbuf, 2);
        -: 5011:
        1: 5012:  ASSERT(mg_parse_dns(nc.send_mbuf.buf, nc.send_mbuf.len, &msg) != -1);
        1: 5013:  ASSERT_EQ(msg.num_answers, 1);
        1: 5014:  ASSERT_EQ(msg.answers[0].rtype, MG_DNS_A_RECORD);
        1: 5015:  ASSERT(check_record_name(&msg, &msg.answers[0].name, "cesanta.com"));
        -: 5016:
        1: 5017:  mbuf_free(&nc.send_mbuf);
        1: 5018:  mbuf_free(&nc.recv_mbuf);
        -: 5019:
        -: 5020:  /* check malformed request error */
        1: 5021:  memset(&msg, 0, sizeof(msg));
        1: 5022:  ilen = 0;
        1: 5023:  nc.proto_handler(&nc, MG_EV_RECV, &ilen);
        -: 5024:  /* remove message length from tcp buffer before manually checking */
        1: 5025:  mbuf_remove(&nc.send_mbuf, 2);
        -: 5026:
        1: 5027:  ASSERT(mg_parse_dns(nc.send_mbuf.buf, nc.send_mbuf.len, &msg) != -1);
        1: 5028:  ASSERT(msg.flags & 1);
        1: 5029:  ASSERT_EQ(msg.num_questions, 0);
        1: 5030:  ASSERT_EQ(msg.num_answers, 0);
        -: 5031:
        1: 5032:  mbuf_free(&nc.recv_mbuf);
        1: 5033:  mbuf_free(&nc.send_mbuf);
        1: 5034:  return NULL;
        -: 5035:}
        -: 5036:#endif /* MG_ENABLE_DNS_SERVER */
        -: 5037:
        3: 5038:static void dns_resolve_cb(struct mg_dns_message *msg, void *data,
        -: 5039:                           enum mg_resolve_err e) {
        -: 5040:  struct mg_dns_resource_record *rr;
        -: 5041:  char cname[256];
        -: 5042:  struct in_addr got_addr;
        3: 5043:  in_addr_t want_addr = inet_addr("131.107.255.255");
        -: 5044:
        -: 5045:  (void) e;
        3: 5046:  rr = mg_dns_next_record(msg, MG_DNS_A_RECORD, NULL);
        3: 5047:  if (rr != NULL) {
        3: 5048:    mg_dns_parse_record_data(msg, rr, &got_addr, sizeof(got_addr));
        -: 5049:  }
        -: 5050:
        3: 5051:  rr = mg_dns_next_record(msg, MG_DNS_CNAME_RECORD, NULL);
        3: 5052:  if (rr != NULL) {
    #####: 5053:    mg_dns_parse_record_data(msg, rr, cname, sizeof(cname));
        -: 5054:  }
        -: 5055:
        -: 5056:  /*
        -: 5057:   * We saw cases when A query returns only A record, or A and CNAME records.
        -: 5058:   * Expect A answer, and optionally CNAME answer.
        -: 5059:   */
        3: 5060:  if (want_addr == got_addr.s_addr || strcmp(cname, "dns.msftncsi.com") == 0) {
        3: 5061:    *(int *) data = 1; /* Success */
        -: 5062:  } else {
    #####: 5063:    *(int *) data = 2; /* Error */
        -: 5064:  }
        3: 5065:}
        -: 5066:
        1: 5067:static const char *test_dns_resolve(void) {
        -: 5068:  struct mg_mgr mgr;
        -: 5069:  struct mg_mgr_init_opts opts;
        -: 5070:
        1: 5071:  int data = 0;
        -: 5072:
        1: 5073:  mg_mgr_init(&mgr, NULL);
        -: 5074:
        -: 5075:  /* Microsoft promises dns.msftncsi.com is always 131.107.255.255 */
        1: 5076:  mg_resolve_async(&mgr, "dns.msftncsi.com", MG_DNS_A_RECORD, dns_resolve_cb,
        -: 5077:                   &data);
        -: 5078:
        1: 5079:  poll_until(&mgr, 1, c_int_ne, &data, (void *) 0);
        1: 5080:  ASSERT_EQ(data, 1);
        -: 5081:
        1: 5082:  mg_mgr_free(&mgr);
        -: 5083:
        1: 5084:  data = 0;
        1: 5085:  memset(&opts, 0, sizeof(opts));
        1: 5086:  opts.nameserver = "8.8.4.4";
        1: 5087:  mg_mgr_init_opt(&mgr, NULL, opts);
        -: 5088:
        -: 5089:  /* Microsoft promises dns.msftncsi.com is always 131.107.255.255 */
        1: 5090:  mg_resolve_async(&mgr, "dns.msftncsi.com", MG_DNS_A_RECORD, dns_resolve_cb,
        -: 5091:                   &data);
        -: 5092:
        1: 5093:  poll_until(&mgr, 1, c_int_ne, &data, (void *) 0);
        1: 5094:  ASSERT_EQ(data, 1);
        -: 5095:
        1: 5096:  mg_mgr_free(&mgr);
        -: 5097:
        1: 5098:  data = 0;
        1: 5099:  mg_mgr_init(&mgr, NULL);
        1: 5100:  mg_set_nameserver(&mgr, "8.8.4.4");
        -: 5101:
        -: 5102:  /* Microsoft promises dns.msftncsi.com is always 131.107.255.255 */
        1: 5103:  mg_resolve_async(&mgr, "dns.msftncsi.com", MG_DNS_A_RECORD, dns_resolve_cb,
        -: 5104:                   &data);
        -: 5105:
        1: 5106:  poll_until(&mgr, 1, c_int_ne, &data, (void *) 0);
        1: 5107:  ASSERT_EQ(data, 1);
        -: 5108:
        1: 5109:  mg_mgr_free(&mgr);
        -: 5110:
        1: 5111:  return NULL;
        -: 5112:}
        -: 5113:
        1: 5114:static void dns_resolve_timeout_cb(struct mg_dns_message *msg, void *data,
        -: 5115:                                   enum mg_resolve_err e) {
        -: 5116:  (void) e;
        1: 5117:  if (msg == NULL) {
        1: 5118:    *(int *) data = 1;
        -: 5119:  }
        1: 5120:}
        -: 5121:
        -: 5122:extern char mg_dns_server[256];
        -: 5123:
        1: 5124:static const char *test_dns_resolve_timeout(void) {
        -: 5125:  struct mg_mgr mgr;
        -: 5126:  struct mg_resolve_async_opts opts;
        1: 5127:  int data = 0;
        1: 5128:  mg_mgr_init(&mgr, NULL);
        1: 5129:  memset(&opts, 0, sizeof(opts));
        -: 5130:
        1: 5131:  opts.nameserver = "7.7.7.7";
        1: 5132:  opts.timeout = -1; /* 0 would be the default timeout */
        1: 5133:  opts.max_retries = 1;
        1: 5134:  mg_resolve_async_opt(&mgr, "www.cesanta.com", MG_DNS_A_RECORD,
        -: 5135:                       dns_resolve_timeout_cb, &data, opts);
        -: 5136:
        1: 5137:  poll_until(&mgr, 5, c_int_eq, &data, (void *) 1);
        1: 5138:  ASSERT_EQ(data, 1);
        -: 5139:
        1: 5140:  mg_mgr_free(&mgr);
        1: 5141:  return NULL;
        -: 5142:}
        -: 5143:
        -: 5144:#ifndef NO_RESOLVE_HOSTS_TEST
        1: 5145:static const char *test_dns_resolve_hosts(void) {
        -: 5146:  union socket_address sa;
        1: 5147:  in_addr_t want_addr = inet_addr("127.0.0.1");
        -: 5148:
        1: 5149:  memset(&sa, 0, sizeof(sa));
        1: 5150:  ASSERT_EQ(mg_resolve_from_hosts_file("localhost", &sa), 0);
        1: 5151:  ASSERT_EQ(sa.sin.sin_addr.s_addr, want_addr);
        1: 5152:  ASSERT_EQ(mg_resolve_from_hosts_file("does_not,exist!in_host*file", &sa), -1);
        -: 5153:
        1: 5154:  return NULL;
        -: 5155:}
        -: 5156:#endif
        -: 5157:
      514: 5158:static void ehb_srv(struct mg_connection *nc, int ev, void *p) {
      514: 5159:  struct mbuf *io = &nc->recv_mbuf;
        -: 5160:  (void) io;
        -: 5161:  (void) p;
        -: 5162:
      514: 5163:  if (ev == MG_EV_RECV) {
        4: 5164:    if (*(int *) p == 1) (*(int *) nc->mgr->user_data)++;
        4: 5165:    mbuf_remove(io, *(int *) p);
        -: 5166:  }
      514: 5167:}
        -: 5168:
      995: 5169:static void ehb_srv2(struct mg_connection *c, int ev, void *p) {
      995: 5170:  if (ev == MG_EV_CLOSE) {
        3: 5171:    if (c->recv_mbuf.size == 1) (*(int *) c->mgr->user_data) = 1;
        -: 5172:    (void) p;
        -: 5173:  }
      995: 5174:}
        -: 5175:
        1: 5176:static const char *test_buffer_limit(void) {
        -: 5177:  struct mg_mgr mgr;
        -: 5178:  struct mg_connection *clnt, *srv;
        1: 5179:  const char *address = "tcp://127.0.0.1:7878";
        1: 5180:  int res = 0;
        -: 5181:
        1: 5182:  mg_mgr_init(&mgr, &res);
        1: 5183:  ASSERT((srv = mg_bind(&mgr, address, ehb_srv)) != NULL);
        1: 5184:  srv->recv_mbuf_limit = 1;
        1: 5185:  ASSERT((clnt = mg_connect(&mgr, address, NULL)) != NULL);
        1: 5186:  mg_printf(clnt, "abcd");
        -: 5187:
        1: 5188:  poll_until(&mgr, 1, c_int_eq, &res, (void *) 4);
        -: 5189:
        -: 5190:  /* expect four single byte read events */
        1: 5191:  ASSERT_EQ(res, 4);
        -: 5192:
        -: 5193:  /*
        -: 5194:   * Make sure we're not closing full non-drained connections without any
        -: 5195:   * protocol handler
        -: 5196:   */
        1: 5197:  res = 0;
        1: 5198:  srv->handler = ehb_srv2;
        1: 5199:  ASSERT((clnt = mg_connect(&mgr, address, NULL)) != NULL);
        1: 5200:  mg_printf(clnt, "abcd");
        1: 5201:  poll_until(&mgr, 1, c_int_eq, &res, (void *) 1);
        1: 5202:  ASSERT_EQ(res, 0);
        -: 5203:
        -: 5204:  /*
        -: 5205:   * Make sure we're closing full non-drained connections with mqtt protocol
        -: 5206:   * handler
        -: 5207:   */
        1: 5208:  res = 0;
        1: 5209:  srv->handler = ehb_srv2;
        1: 5210:  mg_set_protocol_mqtt(srv);
        1: 5211:  ASSERT((clnt = mg_connect(&mgr, address, NULL)) != NULL);
        1: 5212:  mg_printf(clnt, "abcd");
        1: 5213:  poll_until(&mgr, 1, c_int_eq, &res, (void *) 1);
        1: 5214:  ASSERT_EQ(res, 1);
        -: 5215:
        1: 5216:  mg_mgr_free(&mgr);
        1: 5217:  return NULL;
        -: 5218:}
        -: 5219:
        1: 5220:static const char *test_http_parse_header(void) {
        -: 5221:  static struct mg_str h = MG_MK_STR(
        -: 5222:      "xx=1 kl yy, ert=234 kl=123, qq=ww;"
        -: 5223:      "uri=\"/?naii=x,y\";ii=\"12\\\"34\" zz='aa bb',tt=2,gf=\"xx d=1234");
        -: 5224:  char buf[20];
        -: 5225:  char *buf2;
        -: 5226:
        1: 5227:  ASSERT_EQ(mg_http_parse_header(&h, "ert", buf, sizeof(buf)), 3);
        1: 5228:  ASSERT_STREQ(buf, "234");
        -: 5229:
        1: 5230:  ASSERT_EQ(mg_http_parse_header(&h, "ert", buf, 2), 0);
        1: 5231:  ASSERT_EQ(mg_http_parse_header(&h, "ert", buf, 3), 0);
        1: 5232:  ASSERT_EQ(mg_http_parse_header(&h, "ert", buf, 4), 3);
        -: 5233:
        1: 5234:  buf2 = buf;
        1: 5235:  ASSERT_EQ(mg_http_parse_header2(&h, "ert", &buf2, 2), 3);
        1: 5236:  ASSERT(buf2 != buf);
        1: 5237:  free(buf2);
        -: 5238:
        1: 5239:  buf2 = buf;
        1: 5240:  ASSERT_EQ(mg_http_parse_header2(&h, "ert", &buf2, 3), 3);
        1: 5241:  ASSERT(buf2 != buf);
        1: 5242:  free(buf2);
        -: 5243:
        1: 5244:  buf2 = buf;
        1: 5245:  ASSERT_EQ(mg_http_parse_header2(&h, "ert", &buf2, 4), 3);
        1: 5246:  ASSERT(buf2 == buf);
        -: 5247:
        1: 5248:  buf2 = NULL;
        1: 5249:  ASSERT_EQ(mg_http_parse_header2(&h, "ert", &buf2, 0), 3);
        1: 5250:  ASSERT_STREQ(buf2, "234");
        1: 5251:  free(buf2);
        -: 5252:
        1: 5253:  ASSERT_EQ(mg_http_parse_header(&h, "gf", buf, sizeof(buf)), 0);
        1: 5254:  ASSERT_EQ(mg_http_parse_header(&h, "zz", buf, sizeof(buf)), 5);
        1: 5255:  ASSERT_STREQ(buf, "aa bb");
        1: 5256:  ASSERT_EQ(mg_http_parse_header(&h, "d", buf, sizeof(buf)), 4);
        1: 5257:  ASSERT_STREQ(buf, "1234");
        1: 5258:  buf[0] = 'x';
        1: 5259:  ASSERT_EQ(mg_http_parse_header(&h, "MMM", buf, sizeof(buf)), 0);
        1: 5260:  ASSERT_EQ(buf[0], '\0');
        1: 5261:  ASSERT_EQ(mg_http_parse_header(&h, "kl", buf, sizeof(buf)), 3);
        1: 5262:  ASSERT_STREQ(buf, "123");
        1: 5263:  ASSERT_EQ(mg_http_parse_header(&h, "xx", buf, sizeof(buf)), 1);
        1: 5264:  ASSERT_STREQ(buf, "1");
        1: 5265:  ASSERT_EQ(mg_http_parse_header(&h, "ii", buf, sizeof(buf)), 5);
        1: 5266:  ASSERT_STREQ(buf, "12\"34");
        1: 5267:  ASSERT_EQ(mg_http_parse_header(&h, "tt", buf, sizeof(buf)), 1);
        1: 5268:  ASSERT_STREQ(buf, "2");
        1: 5269:  ASSERT(mg_http_parse_header(&h, "uri", buf, sizeof(buf)) > 0);
        1: 5270:  ASSERT_STREQ(buf, "/?naii=x,y");
        1: 5271:  ASSERT(mg_http_parse_header(&h, "qq", buf, sizeof(buf)) > 0);
        1: 5272:  ASSERT_STREQ(buf, "ww");
        -: 5273:
        1: 5274:  return NULL;
        -: 5275:}
        -: 5276:
        -: 5277:#if MG_ENABLE_COAP
        -: 5278:struct results {
        -: 5279:  int server;
        -: 5280:  int client;
        -: 5281:};
        -: 5282:
       34: 5283:static void coap_handler_1(struct mg_connection *nc, int ev, void *p) {
       34: 5284:  switch (ev) {
        1: 5285:    case MG_EV_CONNECT: {
        -: 5286:      struct mg_coap_message cm;
        1: 5287:      memset(&cm, 0, sizeof(cm));
        1: 5288:      cm.msg_id = 1;
        1: 5289:      cm.msg_type = MG_COAP_MSG_CON;
        1: 5290:      mg_coap_send_message(nc, &cm);
        1: 5291:      break;
        -: 5292:    }
        1: 5293:    case MG_EV_COAP_ACK: {
        1: 5294:      struct mg_coap_message *cm = (struct mg_coap_message *) p;
        1: 5295:      ((struct results *) (nc->user_data))->client = cm->msg_id + cm->msg_type;
        1: 5296:      break;
        -: 5297:    }
        1: 5298:    case MG_EV_COAP_CON: {
        1: 5299:      struct mg_coap_message *cm = (struct mg_coap_message *) p;
        1: 5300:      ((struct results *) (nc->user_data))->server = cm->msg_id + cm->msg_type;
        1: 5301:      mg_coap_send_ack(nc, cm->msg_id);
        1: 5302:      break;
        -: 5303:    }
        -: 5304:  }
       34: 5305:}
        -: 5306:
        1: 5307:static const char *test_coap(void) {
        -: 5308:  struct mbuf packet_in, packet_out;
        -: 5309:  struct mg_coap_message cm;
        -: 5310:  uint32_t res;
        -: 5311:
        1: 5312:  unsigned char coap_packet_1[] = {0x42, 0x01, 0xe9, 0x1b, 0x07, 0x90, 0xb8,
        -: 5313:                                   0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74,
        -: 5314:                                   0x65, 0x10, 0xd1, 0x23, 0x11};
        1: 5315:  unsigned char coap_packet_2[] = {0x60, 0x00, 0xe9, 0x1b};
        1: 5316:  unsigned char coap_packet_3[] = {
        -: 5317:      0x42, 0x45, 0x57, 0x0f, 0x07, 0x90, 0xff, 0x54, 0x68, 0x69, 0x73, 0x20,
        -: 5318:      0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x77, 0x61, 0x73, 0x20,
        -: 5319:      0x73, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x73, 0x65,
        -: 5320:      0x70, 0x61, 0x72, 0x61, 0x74, 0x65, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f,
        -: 5321:      0x6e, 0x73, 0x65, 0x2e, 0x0a, 0x59, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x6c,
        -: 5322:      0x69, 0x65, 0x6e, 0x74, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x65,
        -: 5323:      0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x63, 0x6b, 0x6e, 0x6f, 0x77,
        -: 5324:      0x6c, 0x65, 0x64, 0x67, 0x65, 0x20, 0x69, 0x74, 0x2c, 0x20, 0x6f, 0x74,
        -: 5325:      0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x69, 0x74, 0x20, 0x77,
        -: 5326:      0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x74, 0x72, 0x61,
        -: 5327:      0x6e, 0x73, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64, 0x2e};
        1: 5328:  unsigned char coap_packet_4[] = {0x60, 0x00, 0x57, 0x0f};
        1: 5329:  unsigned char coap_packet_5[] = {
        -: 5330:      0x40, 0x03, 0x95, 0x22, 0xb7, 0x73, 0x74, 0x6f, 0x72, 0x61,
        -: 5331:      0x67, 0x65, 0x0a, 0x6d, 0x79, 0x72, 0x65, 0x73, 0x6f, 0x75,
        -: 5332:      0x72, 0x63, 0x65, 0xff, 0x6d, 0x79, 0x64, 0x61, 0x74, 0x61};
        1: 5333:  unsigned char coap_packet_6[] = {0xFF, 0x00, 0xFF, 0x00};
        1: 5334:  unsigned char coap_packet_7[] = {
        -: 5335:      0x40, 0x03, 0x95, 0x22, 0xb7, 0x73, 0x74, 0x6f, 0x72, 0x61,
        -: 5336:      0x67, 0x65, 0x0a, 0x6d, 0x79, 0x72, 0x65, 0x73, 0x6f, 0x75,
        -: 5337:      0x72, 0x63, 0x65, 0xf1, 0x6d, 0x79, 0x64, 0x61, 0x74, 0x61};
        -: 5338:
        1: 5339:  mbuf_init(&packet_in, 0);
        -: 5340:  /* empty buf */
        1: 5341:  res = mg_coap_parse(&packet_in, &cm);
        1: 5342:  ASSERT((res & MG_COAP_NOT_ENOUGH_DATA) != 0);
        1: 5343:  mg_coap_free_options(&cm);
        1: 5344:  mbuf_free(&packet_in);
        -: 5345:
        1: 5346:  mbuf_init(&packet_out, 0);
        -: 5347:  /* ACK, MID: 59675, Empty Message */
        1: 5348:  packet_in.buf = (char *) coap_packet_2;
        1: 5349:  packet_in.len = sizeof(coap_packet_2);
        1: 5350:  res = mg_coap_parse(&packet_in, &cm);
        1: 5351:  ASSERT_EQ((res & MG_COAP_ERROR), 0);
        1: 5352:  ASSERT_EQ(cm.code_class, 0);
        1: 5353:  ASSERT_EQ(cm.code_detail, 0);
        1: 5354:  ASSERT_EQ(cm.msg_id, 59675);
        1: 5355:  ASSERT_EQ(cm.msg_type, MG_COAP_MSG_ACK);
        1: 5356:  ASSERT(cm.options == NULL);
        1: 5357:  ASSERT_EQ(cm.payload.len, 0);
        1: 5358:  ASSERT(cm.payload.p == NULL);
        1: 5359:  ASSERT_EQ(cm.token.len, 0);
        1: 5360:  ASSERT(cm.token.p == NULL);
        1: 5361:  res = mg_coap_compose(&cm, &packet_out);
        1: 5362:  ASSERT_EQ(res, 0);
        1: 5363:  ASSERT_EQ(packet_out.len, sizeof(coap_packet_2));
        1: 5364:  ASSERT_EQ(memcmp(packet_out.buf, coap_packet_2, packet_out.len), 0);
        1: 5365:  mg_coap_free_options(&cm);
        1: 5366:  mbuf_free(&packet_out);
        -: 5367:
        -: 5368:  /* ACK, MID: 22287, Empty Message */
        1: 5369:  packet_in.buf = (char *) coap_packet_4;
        1: 5370:  packet_in.len = sizeof(coap_packet_4);
        1: 5371:  res = mg_coap_parse(&packet_in, &cm);
        1: 5372:  ASSERT_EQ((res & MG_COAP_ERROR), 0);
        1: 5373:  ASSERT_EQ(cm.code_class, 0);
        1: 5374:  ASSERT_EQ(cm.code_detail, 0);
        1: 5375:  ASSERT_EQ(cm.msg_id, 22287);
        1: 5376:  ASSERT_EQ(cm.msg_type, MG_COAP_MSG_ACK);
        1: 5377:  ASSERT(cm.options == NULL);
        1: 5378:  ASSERT_EQ(cm.payload.len, 0);
        1: 5379:  ASSERT(cm.payload.p == NULL);
        1: 5380:  ASSERT_EQ(cm.token.len, 0);
        1: 5381:  ASSERT(cm.token.p == NULL);
        1: 5382:  res = mg_coap_compose(&cm, &packet_out);
        1: 5383:  ASSERT_EQ(res, 0);
        1: 5384:  ASSERT_EQ(packet_out.len, sizeof(coap_packet_4));
        1: 5385:  ASSERT_EQ(memcmp(packet_out.buf, coap_packet_4, packet_out.len), 0);
        1: 5386:  mg_coap_free_options(&cm);
        1: 5387:  mbuf_free(&packet_out);
        -: 5388:
        -: 5389:  /* CON, MID: 59675 ... */
        1: 5390:  packet_in.buf = (char *) coap_packet_1;
        1: 5391:  packet_in.len = sizeof(coap_packet_1);
        1: 5392:  res = mg_coap_parse(&packet_in, &cm);
        1: 5393:  ASSERT_EQ((res & MG_COAP_ERROR), 0);
        1: 5394:  ASSERT_EQ(cm.code_class, 0);
        1: 5395:  ASSERT_EQ(cm.code_detail, 1);
        1: 5396:  ASSERT_EQ(cm.msg_id, 59675);
        1: 5397:  ASSERT_EQ(cm.msg_type, MG_COAP_MSG_CON);
        1: 5398:  ASSERT(cm.options != 0);
        1: 5399:  ASSERT_EQ(cm.options->number, 11);
        1: 5400:  ASSERT_EQ(cm.options->value.len, 8);
        1: 5401:  ASSERT_STREQ_NZ(cm.options->value.p, "separate");
        1: 5402:  ASSERT(cm.options->next != 0);
        1: 5403:  ASSERT_EQ(cm.options->next->number, 12);
        1: 5404:  ASSERT_EQ(cm.options->next->value.len, 0);
        1: 5405:  ASSERT(cm.options->next->next != 0);
        1: 5406:  ASSERT_EQ(cm.options->next->next->number, 60);
        1: 5407:  ASSERT_EQ(cm.options->next->next->value.len, 1);
        1: 5408:  ASSERT_EQ(*cm.options->next->next->value.p, 0x11);
        1: 5409:  ASSERT(cm.options->next->next->next == NULL);
        1: 5410:  ASSERT_EQ(cm.payload.len, 0);
        1: 5411:  ASSERT(cm.payload.p == NULL);
        1: 5412:  ASSERT_EQ(cm.token.len, 2);
        1: 5413:  ASSERT_EQ(*cm.token.p, 0x07);
        1: 5414:  ASSERT_EQ((unsigned char) *(cm.token.p + 1), 0x90);
        1: 5415:  res = mg_coap_compose(&cm, &packet_out);
        1: 5416:  ASSERT_EQ(res, 0);
        1: 5417:  ASSERT_EQ(packet_out.len, sizeof(coap_packet_1));
        1: 5418:  ASSERT_EQ(memcmp(packet_out.buf, coap_packet_1, packet_out.len), 0);
        1: 5419:  mg_coap_free_options(&cm);
        1: 5420:  mbuf_free(&packet_out);
        -: 5421:
        -: 5422:  /* CON, MID: 22287 ... */
        1: 5423:  packet_in.buf = (char *) coap_packet_3;
        1: 5424:  packet_in.len = sizeof(coap_packet_3);
        1: 5425:  res = mg_coap_parse(&packet_in, &cm);
        1: 5426:  ASSERT_EQ((res & MG_COAP_ERROR), 0);
        1: 5427:  ASSERT_EQ(cm.code_class, 2);
        1: 5428:  ASSERT_EQ(cm.code_detail, 5);
        1: 5429:  ASSERT_EQ(cm.msg_id, 22287);
        1: 5430:  ASSERT_EQ(cm.msg_type, MG_COAP_MSG_CON);
        1: 5431:  ASSERT(cm.options == NULL);
        1: 5432:  ASSERT_EQ(cm.token.len, 2);
        1: 5433:  ASSERT_EQ(*cm.token.p, 0x07);
        1: 5434:  ASSERT_EQ((unsigned char) *(cm.token.p + 1), 0x90);
        1: 5435:  ASSERT_EQ(cm.payload.len, 122);
        1: 5436:  ASSERT(strncmp(cm.payload.p,
        -: 5437:                 "This message was sent by a separate response.\n"
        -: 5438:                 "Your client will need to acknowledge it,"
        -: 5439:                 " otherwise it will be retransmitted.",
        -: 5440:                 122) == 0);
        1: 5441:  res = mg_coap_compose(&cm, &packet_out);
        1: 5442:  ASSERT_EQ(res, 0);
        1: 5443:  ASSERT_EQ(packet_out.len, sizeof(coap_packet_3));
        1: 5444:  ASSERT_EQ(memcmp(packet_out.buf, coap_packet_3, packet_out.len), 0);
        1: 5445:  mg_coap_free_options(&cm);
        1: 5446:  mbuf_free(&packet_out);
        -: 5447:
        1: 5448:  packet_in.buf = (char *) coap_packet_5;
        1: 5449:  packet_in.len = sizeof(coap_packet_5);
        1: 5450:  res = mg_coap_parse(&packet_in, &cm);
        1: 5451:  ASSERT_EQ((res & MG_COAP_ERROR), 0);
        1: 5452:  ASSERT_EQ(cm.code_class, 0);
        1: 5453:  ASSERT_EQ(cm.code_detail, 3);
        1: 5454:  ASSERT_EQ(cm.msg_id, 38178);
        1: 5455:  ASSERT_EQ(cm.msg_type, MG_COAP_MSG_CON);
        1: 5456:  ASSERT(cm.options != 0);
        1: 5457:  ASSERT_EQ(cm.options->number, 11);
        1: 5458:  ASSERT_EQ(cm.options->value.len, 7);
        1: 5459:  ASSERT_STREQ_NZ(cm.options->value.p, "storage");
        1: 5460:  ASSERT(cm.options->next != 0);
        1: 5461:  ASSERT_EQ(cm.options->next->number, 11);
        1: 5462:  ASSERT_EQ(cm.options->next->value.len, 10);
        1: 5463:  ASSERT_STREQ_NZ(cm.options->next->value.p, "myresource");
        1: 5464:  ASSERT(cm.options->next->next == NULL);
        1: 5465:  ASSERT_EQ(cm.token.len, 0);
        1: 5466:  ASSERT_EQ(cm.payload.len, 6);
        1: 5467:  ASSERT_STREQ_NZ(cm.payload.p, "mydata");
        1: 5468:  res = mg_coap_compose(&cm, &packet_out);
        1: 5469:  ASSERT_EQ(res, 0);
        1: 5470:  ASSERT_EQ(packet_out.len, sizeof(coap_packet_5));
        1: 5471:  ASSERT_EQ(memcmp(packet_out.buf, coap_packet_5, packet_out.len), 0);
        1: 5472:  mg_coap_free_options(&cm);
        1: 5473:  mbuf_free(&packet_out);
        -: 5474:
        1: 5475:  packet_in.buf = (char *) coap_packet_6;
        1: 5476:  packet_in.len = sizeof(coap_packet_6);
        1: 5477:  res = mg_coap_parse(&packet_in, &cm);
        1: 5478:  ASSERT((res & MG_COAP_ERROR) != 0);
        1: 5479:  mg_coap_free_options(&cm);
        -: 5480:
        1: 5481:  packet_in.buf = (char *) coap_packet_7;
        1: 5482:  packet_in.len = sizeof(coap_packet_7);
        1: 5483:  res = mg_coap_parse(&packet_in, &cm);
        1: 5484:  ASSERT((res & MG_COAP_ERROR) != 0);
        1: 5485:  mg_coap_free_options(&cm);
        -: 5486:
        -: 5487:  {
        1: 5488:    unsigned char coap_packet_2_broken[] = {0x6F, 0x00, 0xe9, 0x1b};
        1: 5489:    packet_in.buf = (char *) coap_packet_2_broken;
        1: 5490:    packet_in.len = sizeof(coap_packet_2_broken);
        1: 5491:    res = mg_coap_parse(&packet_in, &cm);
        1: 5492:    ASSERT((res & MG_COAP_FORMAT_ERROR) != 0);
        -: 5493:  }
        -: 5494:
        -: 5495:  {
        1: 5496:    unsigned char coap_packet_2_broken[] = {0x65, 0x00, 0xe9, 0x1b};
        1: 5497:    packet_in.buf = (char *) coap_packet_2_broken;
        1: 5498:    packet_in.len = sizeof(coap_packet_2_broken);
        1: 5499:    res = mg_coap_parse(&packet_in, &cm);
        1: 5500:    ASSERT((res & MG_COAP_NOT_ENOUGH_DATA) != 0);
        -: 5501:  }
        -: 5502:
        1: 5503:  memset(&cm, 0, sizeof(cm));
        1: 5504:  mg_coap_add_option(&cm, 10, 0, 0);
        1: 5505:  ASSERT_EQ(cm.options->number, 10);
        1: 5506:  ASSERT(cm.options->next == NULL);
        1: 5507:  mg_coap_add_option(&cm, 5, 0, 0);
        1: 5508:  ASSERT_EQ(cm.options->number, 5);
        1: 5509:  ASSERT_EQ(cm.options->next->number, 10);
        1: 5510:  ASSERT(cm.options->next->next == NULL);
        1: 5511:  mg_coap_add_option(&cm, 7, 0, 0);
        1: 5512:  ASSERT_EQ(cm.options->number, 5);
        1: 5513:  ASSERT_EQ(cm.options->next->number, 7);
        1: 5514:  ASSERT_EQ(cm.options->next->next->number, 10);
        1: 5515:  ASSERT(cm.options->next->next->next == NULL);
        1: 5516:  mg_coap_add_option(&cm, 1, 0, 0);
        1: 5517:  ASSERT_EQ(cm.options->number, 1);
        1: 5518:  ASSERT_EQ(cm.options->next->number, 5);
        1: 5519:  ASSERT_EQ(cm.options->next->next->number, 7);
        1: 5520:  ASSERT_EQ(cm.options->next->next->next->number, 10);
        1: 5521:  ASSERT(cm.options->next->next->next->next == NULL);
        1: 5522:  mg_coap_free_options(&cm);
        -: 5523:
        -: 5524:  {
        1: 5525:    unsigned char value16[] = {0xCC, 0xDD};
        1: 5526:    packet_in.buf = (char *) coap_packet_4;
        1: 5527:    packet_in.len = sizeof(coap_packet_4);
        1: 5528:    res = mg_coap_parse(&packet_in, &cm);
        1: 5529:    ASSERT_EQ((res & MG_COAP_ERROR), 0);
        1: 5530:    mg_coap_add_option(&cm, 0xAABB, (char *) value16, sizeof(value16));
        1: 5531:    res = mg_coap_compose(&cm, &packet_out);
        1: 5532:    mg_coap_free_options(&cm);
        1: 5533:    ASSERT_EQ(res, 0);
        1: 5534:    res = mg_coap_parse(&packet_out, &cm);
        1: 5535:    ASSERT_EQ((res & MG_COAP_ERROR), 0);
        1: 5536:    ASSERT_EQ(cm.options->number, 0xAABB);
        1: 5537:    ASSERT_EQ(cm.options->value.len, 2);
        1: 5538:    ASSERT_EQ(memcmp(cm.options->value.p, value16, cm.options->value.len), 0);
        1: 5539:    mg_coap_free_options(&cm);
        1: 5540:    mbuf_free(&packet_out);
        -: 5541:  }
        -: 5542:
        1: 5543:  memset(&cm, 0, sizeof(cm));
        1: 5544:  cm.msg_id = 1;
        1: 5545:  cm.msg_type = MG_COAP_MSG_MAX + 1;
        1: 5546:  res = mg_coap_compose(&cm, &packet_out);
        2: 5547:  ASSERT((res & MG_COAP_ERROR) != 0 && (res & MG_COAP_MSG_TYPE_FIELD) != 0);
        -: 5548:
        1: 5549:  cm.msg_type = MG_COAP_MSG_ACK;
        1: 5550:  cm.token.len = 10000;
        1: 5551:  res = mg_coap_compose(&cm, &packet_out);
        1: 5552:  ASSERT((res & MG_COAP_ERROR) != 0 && (res & MG_COAP_TOKEN_FIELD) != 0);
        -: 5553:
        1: 5554:  cm.token.len = 0;
        1: 5555:  cm.code_class = 0xFF;
        1: 5556:  res = mg_coap_compose(&cm, &packet_out);
        1: 5557:  ASSERT((res & MG_COAP_ERROR) != 0 && (res & MG_COAP_CODE_CLASS_FIELD) != 0);
        -: 5558:
        1: 5559:  cm.code_class = 0;
        1: 5560:  cm.code_detail = 0xFF;
        1: 5561:  res = mg_coap_compose(&cm, &packet_out);
        1: 5562:  ASSERT((res & MG_COAP_ERROR) != 0 && (res & MG_COAP_CODE_DETAIL_FIELD) != 0);
        -: 5563:
        1: 5564:  cm.code_detail = 0;
        1: 5565:  mg_coap_add_option(&cm, 0xFFFFFFF, 0, 0);
        1: 5566:  res = mg_coap_compose(&cm, &packet_out);
        1: 5567:  ASSERT((res & MG_COAP_ERROR) != 0 && (res & MG_COAP_OPTIOMG_FIELD) != 0);
        1: 5568:  mg_coap_free_options(&cm);
        -: 5569:
        -: 5570:  {
        -: 5571:    struct mg_mgr mgr;
        -: 5572:    struct mg_connection *nc;
        1: 5573:    const char *address = "tcp://127.0.0.1:8686";
        -: 5574:
        1: 5575:    mg_mgr_init(&mgr, 0);
        -: 5576:
        1: 5577:    nc = mg_bind(&mgr, address, coap_handler_1);
        1: 5578:    ASSERT(nc != NULL);
        1: 5579:    ASSERT_EQ(mg_set_protocol_coap(nc), -1);
        -: 5580:
        1: 5581:    mg_mgr_free(&mgr);
        -: 5582:  }
        -: 5583:
        -: 5584:  {
        -: 5585:    struct results res;
        -: 5586:    struct mg_mgr mgr;
        -: 5587:    struct mg_connection *nc1, *nc2;
        1: 5588:    const char *address = "udp://127.0.0.1:5683";
        -: 5589:
        1: 5590:    mg_mgr_init(&mgr, 0);
        -: 5591:
        1: 5592:    nc1 = mg_bind(&mgr, address, coap_handler_1);
        1: 5593:    mg_set_protocol_coap(nc1);
        1: 5594:    nc1->user_data = &res;
        -: 5595:
        1: 5596:    nc2 = mg_connect(&mgr, address, coap_handler_1);
        1: 5597:    mg_set_protocol_coap(nc2);
        1: 5598:    nc2->user_data = &res;
        -: 5599:
        1: 5600:    poll_until(&mgr, 5, c_int_eq, &res.client, (void *) 3);
        -: 5601:
        1: 5602:    mg_mgr_free(&mgr);
        -: 5603:
        2: 5604:    ASSERT_EQ(res.server, 1);
        1: 5605:    ASSERT_EQ(res.client, 3);
        -: 5606:  }
        -: 5607:
        1: 5608:  return NULL;
        -: 5609:}
        -: 5610:#endif
        -: 5611:
        1: 5612:static const char *test_strcmp(void) {
        -: 5613:  struct mg_str s1;
        -: 5614:
        1: 5615:  s1.p = "aa";
        1: 5616:  s1.len = strlen(s1.p);
        1: 5617:  ASSERT_EQ(mg_vcasecmp(&s1, "aa"), 0);
        1: 5618:  ASSERT_EQ(mg_vcmp(&s1, "aa"), 0);
        1: 5619:  ASSERT(mg_vcasecmp(&s1, "ab") < 0);
        1: 5620:  ASSERT(mg_vcmp(&s1, "ab") < 0);
        1: 5621:  ASSERT(mg_vcasecmp(&s1, "abb") < 0);
        1: 5622:  ASSERT(mg_vcmp(&s1, "abb") < 0);
        1: 5623:  ASSERT(mg_vcasecmp(&s1, "b") < 0);
        1: 5624:  ASSERT(mg_vcmp(&s1, "b") < 0);
        1: 5625:  return NULL;
        -: 5626:}
        -: 5627:
        -: 5628:#if MG_ENABLE_SNTP
        1: 5629:static const char *test_sntp(void) {
        1: 5630:  const char sntp_good[] =
        -: 5631:      "\x24\x02\x00\xeb\x00\x00\x00\x1e\x00\x00\x07\xb6\x3e"
        -: 5632:      "\xc9\xd6\xa2\xdb\xde\xea\x30\x91\x86\xb7\x10\xdb\xde"
        -: 5633:      "\xed\x98\x00\x00\x00\xde\xdb\xde\xed\x99\x0a\xe2\xc7"
        -: 5634:      "\x96\xdb\xde\xed\x99\x0a\xe4\x6b\xda";
        1: 5635:  const char bad_good[] =
        -: 5636:      "\x55\x02\x00\xeb\x00\x00\x00\x1e\x00\x00\x07\xb6\x3e"
        -: 5637:      "\xc9\xd6\xa2\xdb\xde\xea\x30\x91\x86\xb7\x10\xdb\xde"
        -: 5638:      "\xed\x98\x00\x00\x00\xde\xdb\xde\xed\x99\x0a\xe2\xc7"
        -: 5639:      "\x96\xdb\xde\xed\x99\x0a\xe4\x6b\xda";
        -: 5640:
        -: 5641:  int res;
        -: 5642:  struct mg_sntp_message msg;
        -: 5643:  struct tm *tm;
        -: 5644:  time_t t;
        1: 5645:  memset(&msg, 0, sizeof(0));
        -: 5646:
        1: 5647:  res = mg_sntp_parse_reply(sntp_good, sizeof(sntp_good) - 1, &msg);
        1: 5648:  ASSERT_EQ(res, 0);
        1: 5649:  t = (time_t) msg.time;
        1: 5650:  tm = gmtime(&t);
        1: 5651:  ASSERT_EQ(tm->tm_year, 116);
        1: 5652:  ASSERT_EQ(tm->tm_mon, 10);
        1: 5653:  ASSERT_EQ(tm->tm_mday, 22);
        1: 5654:  ASSERT_EQ(tm->tm_hour, 16);
        1: 5655:  ASSERT_EQ(tm->tm_min, 15);
        1: 5656:  ASSERT_EQ(tm->tm_sec, 21);
        1: 5657:  res = mg_sntp_parse_reply(bad_good, sizeof(bad_good) - 1, &msg);
        1: 5658:  ASSERT_EQ(res, -1);
        -: 5659:
        1: 5660:  return NULL;
        -: 5661:}
        -: 5662:#endif
        -: 5663:
        -: 5664:#if MG_ENABLE_SOCKS
        1: 5665:static const char *test_socks(void) {
        -: 5666:  struct mg_mgr mgr;
        -: 5667:  struct mg_connection *c;
        -: 5668:  struct mg_connect_opts opts;
        -: 5669:  const char *this_binary;
        1: 5670:  const char *web_addr = "127.0.0.1:7257";
        1: 5671:  const char *proxy_addr = "127.0.0.1:7258";
        1: 5672:  char status[100] = "";
        -: 5673:
        1: 5674:  mg_mgr_init(&mgr, NULL);
        -: 5675:#if 0
        -: 5676:  mgr.hexdump_file = "-";
        -: 5677:#endif
        -: 5678:
        -: 5679:#if 1
        1: 5680:  cs_log_set_level(LL_INFO);
        -: 5681:#endif
        -: 5682:
        -: 5683:  /* Start web server */
        1: 5684:  ASSERT((c = mg_bind(&mgr, web_addr, cb1)) != NULL);
        1: 5685:  mg_set_protocol_http_websocket(c);
        -: 5686:
        -: 5687:  /* Start socks proxy */
        1: 5688:  ASSERT((c = mg_bind(&mgr, proxy_addr, ev_handler_empty)) != NULL);
        1: 5689:  mg_set_protocol_socks(c);
        -: 5690:
        -: 5691:  /* Create HTTP client that uses socks proxy */
        1: 5692:  memset(&opts, 0, sizeof(opts));
        1: 5693:  opts.iface = mg_socks_mk_iface(&mgr, proxy_addr);
        -: 5694:
        1: 5695:  ASSERT((c = mg_connect_opt(&mgr, web_addr, cb7, opts)) != NULL);
        1: 5696:  mg_set_protocol_http_websocket(c);
        1: 5697:  c->user_data = status;
        -: 5698:  /* Wine and GDB set argv0 to full path: strip the dir component */
        1: 5699:  if ((this_binary = strrchr(g_argv_0, '\\')) != NULL) {
    #####: 5700:    this_binary++;
        1: 5701:  } else if ((this_binary = strrchr(g_argv_0, '/')) != NULL) {
        1: 5702:    this_binary++;
        -: 5703:  } else {
    #####: 5704:    this_binary = g_argv_0;
        -: 5705:  }
        1: 5706:  mg_printf(c, "GET /%s HTTP/1.0\n\n", this_binary);
        1: 5707:  mbuf_resize(&c->recv_mbuf, 10000000);
        -: 5708:
        -: 5709:  /* Run event loop. Use more cycles to let file download complete. */
        1: 5710:  poll_until(&mgr, 15, c_str_ne, status, (void *) "");
        1: 5711:  ASSERT_STREQ(status, "success");
        -: 5712:
        1: 5713:  mg_mgr_free(&mgr);
        -: 5714:
        1: 5715:  return NULL;
        -: 5716:}
        -: 5717:#endif
        -: 5718:
        1: 5719:void tests_setup(void) {
        1: 5720:  test_iface = mg_if_create_iface(mg_ifaces[MG_MAIN_IFACE], NULL);
        1: 5721:}
        -: 5722:
        1: 5723:const char *tests_run(const char *filter) {
        1: 5724:  RUN_TEST(test_mbuf);
        1: 5725:  RUN_TEST(test_parse_uri);
        1: 5726:  RUN_TEST(test_assemble_uri);
        1: 5727:  RUN_TEST(test_parse_address);
        1: 5728:  RUN_TEST(test_mg_normalize_uri_path);
        1: 5729:  RUN_TEST(test_mg_uri_to_local_path);
        1: 5730:  RUN_TEST(test_mg_url_encode);
        1: 5731:  RUN_TEST(test_check_ip_acl);
        1: 5732:  RUN_TEST(test_connect_opts);
        1: 5733:  RUN_TEST(test_connect_opts_error_string);
        1: 5734:  RUN_TEST(test_to64);
        1: 5735:  RUN_TEST(test_alloc_vprintf);
        1: 5736:  RUN_TEST(test_socketpair);
        1: 5737:  RUN_TEST(test_timer);
        -: 5738:#ifdef __linux__
        1: 5739:  RUN_TEST(test_simple);
        -: 5740:#endif
        -: 5741:#if MG_ENABLE_THREADS
        1: 5742:  RUN_TEST(test_thread);
        -: 5743:#endif
        1: 5744:  RUN_TEST(test_mgr);
        1: 5745:  RUN_TEST(test_parse_http_message);
        1: 5746:  RUN_TEST(test_get_http_var);
        1: 5747:  RUN_TEST(test_http_serve_file);
        1: 5748:  RUN_TEST(test_http_serve_file_streaming);
        1: 5749:  RUN_TEST(test_http);
        1: 5750:  RUN_TEST(test_http_pipeline);
        1: 5751:  RUN_TEST(test_http_send_redirect);
        1: 5752:  RUN_TEST(test_http_digest_auth);
        1: 5753:  RUN_TEST(test_http_errors);
        1: 5754:  RUN_TEST(test_http_index);
        1: 5755:  RUN_TEST(test_http_parse_header);
        1: 5756:  RUN_TEST(test_ssi);
        -: 5757:#ifndef NO_CGI_TEST
        1: 5758:  RUN_TEST(test_cgi);
        -: 5759:#endif
        1: 5760:  RUN_TEST(test_http_rewrites);
        1: 5761:  RUN_TEST(test_http_dav);
        1: 5762:  RUN_TEST(test_http_range);
        1: 5763:  RUN_TEST(test_http_multipart);
        -: 5764:#if MG_ENABLE_HTTP_STREAMING_MULTIPART
        1: 5765:  RUN_TEST(test_http_multipart2);
        1: 5766:  RUN_TEST(test_http_multipart_pipeline);
        1: 5767:  RUN_TEST(test_http_multipart_upload);
        -: 5768:#endif
        1: 5769:  RUN_TEST(test_parse_date_string);
        1: 5770:  RUN_TEST(test_websocket);
        1: 5771:  RUN_TEST(test_websocket_endpoint);
        1: 5772:  RUN_TEST(test_connect_ws);
        1: 5773:  RUN_TEST(test_websocket_big);
        1: 5774:  RUN_TEST(test_http_chunk);
        1: 5775:  RUN_TEST(test_http_chunk2);
        1: 5776:  RUN_TEST(test_http_not_modified);
        1: 5777:  RUN_TEST(test_http_extra_headers);
        1: 5778:  RUN_TEST(test_http_endpoints);
        1: 5779:  RUN_TEST(test_mqtt_handshake);
        1: 5780:  RUN_TEST(test_mqtt_publish);
        1: 5781:  RUN_TEST(test_mqtt_subscribe);
        1: 5782:  RUN_TEST(test_mqtt_unsubscribe);
        1: 5783:  RUN_TEST(test_mqtt_connack);
        1: 5784:  RUN_TEST(test_mqtt_suback);
        1: 5785:  RUN_TEST(test_mqtt_simple_acks);
        1: 5786:  RUN_TEST(test_mqtt_nullary);
        1: 5787:  RUN_TEST(test_mqtt_parse_mqtt);
        1: 5788:  RUN_TEST(test_mqtt_parse_mqtt_qos1);
        1: 5789:  RUN_TEST(test_mqtt_match_topic_expression);
        1: 5790:  RUN_TEST(test_mqtt_client_keep_alive);
        -: 5791:#if MG_ENABLE_MQTT_BROKER
        1: 5792:  RUN_TEST(test_mqtt_broker);
        -: 5793:#endif
        1: 5794:  RUN_TEST(test_dns_encode);
        1: 5795:  RUN_TEST(test_dns_uncompress);
        1: 5796:  RUN_TEST(test_dns_decode);
        1: 5797:  RUN_TEST(test_dns_decode_truncated);
        1: 5798:  RUN_TEST(test_dns_reply_encode);
        -: 5799:#if MG_ENABLE_DNS_SERVER
        1: 5800:  RUN_TEST(test_dns_server);
        -: 5801:#endif
        1: 5802:  RUN_TEST(test_dns_resolve);
        1: 5803:  RUN_TEST(test_dns_resolve_timeout);
        -: 5804:#ifndef NO_RESOLVE_HOSTS_TEST
        1: 5805:  RUN_TEST(test_dns_resolve_hosts);
        -: 5806:#endif
        1: 5807:  RUN_TEST(test_buffer_limit);
        1: 5808:  RUN_TEST(test_connection_errors);
        1: 5809:  RUN_TEST(test_connect_fail);
        -: 5810:#ifndef NO_DNS_TEST
        1: 5811:  RUN_TEST(test_resolve);
        -: 5812:#endif
        1: 5813:  RUN_TEST(test_base64);
        1: 5814:  RUN_TEST(test_sock_addr_to_str);
        1: 5815:  RUN_TEST(test_hexdump);
        1: 5816:  RUN_TEST(test_hexdump_file);
        1: 5817:  RUN_TEST(test_basic_auth_helpers);
        1: 5818:  RUN_TEST(test_http_auth);
        -: 5819:#if MG_ENABLE_SSL
        1: 5820:  RUN_TEST(test_ssl);
        -: 5821:#ifdef OPENSSL_VERSION_NUMBER
        -: 5822:  RUN_TEST(test_modern_crypto);
        -: 5823:#endif
        -: 5824:#endif
        1: 5825:  RUN_TEST(test_udp);
        -: 5826:#if MG_ENABLE_COAP
        1: 5827:  RUN_TEST(test_coap);
        -: 5828:#endif
        -: 5829:#if MG_ENABLE_SNTP
        1: 5830:  RUN_TEST(test_sntp);
        -: 5831:#endif
        1: 5832:  RUN_TEST(test_strcmp);
        -: 5833:#if MG_ENABLE_SOCKS
        1: 5834:  RUN_TEST(test_socks);
        -: 5835:#endif
        1: 5836:  return NULL;
        -: 5837:}
        -: 5838:
        1: 5839:void tests_teardown(void) {
        1: 5840:  free(test_iface);
        1: 5841:}
